/*
 *       /\        Guillaume Delay 2018,2019
 *      /__\       guillaume.delay@enpc.fr
 *     /_\/_\      École Nationale des Ponts et Chaussées - CERMICS
 *    /\    /\
 *   /__\  /__\    This is ProtoN, a library for fast Prototyping of
 *  /_\/_\/_\/_\   Numerical methods.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * If you use this code or parts of it for scientific publications, you
 * are required to cite it as following:
 *
 * Implementation of Discontinuous Skeletal methods on arbitrary-dimensional,
 * polytopal meshes using generic programming.
 * M. Cicuttin, D. A. Di Pietro, A. Ern.
 * Journal of Computational and Applied Mathematics.
 * DOI: 10.1016/j.cam.2017.09.017
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <array>
#include <algorithm>
#include <numeric>
#include <cassert>
#include <cmath>
#include <memory>
#include <sstream>
#include <list>
#include <map>

#include <Eigen/Dense>
#include <Eigen/SparseCore>
#include <Eigen/SparseLU>
#include <unsupported/Eigen/SparseExtra>
#include <Spectra/SymEigsSolver.h>
#include <Spectra/MatOp/SparseSymMatProd.h>

#include <unsupported/Eigen/MatrixFunctions> // ADD BY STEFANO

using namespace Eigen;

#include "core/core"
#include "core/solvers"
#include "dataio/silo_io.hpp"

#include "methods/hho"
#include "methods/cuthho"

//#include "tbb/tbb.h"
//#define HAVE_INTEL_TBB
//#include "/usr/local/Cellar/tbb/2020_U2/include/tbb/tbb.h"
//#include "/opt/intel/compilers_and_libraries_2020.1.216⁩/mac/tbb/include/tbb/tbb.h"

//using namespace tbb;


///////////////////////   STEFANO FUNCTIONS  ///////////////////////////
/// NEW VERSIONE OF PREVIOUS FUNCTIONS REWRITTEN FOR DISCRETE LEVEL SET FUNCTIONS

/// Each mesh has memory of the original nodes: useful to link agglomerated - original mesh
template<typename Mesh>
void offset_definition( Mesh& msh)
{
    //size_t counter = 0;
    for (auto& cl:msh.cells) {
        auto offset_orig = offset(msh,cl);
        //if( !cl.user_data.offset_subcells.empty() )
         //   cl.user_data.offset_subcells.erase( cl.user_data.offset_subcells.begin(),cl.user_data.offset_subcells.end() ) ;
        cl.user_data.offset_subcells.push_back(offset_orig);
       // counter++;
       // std::cout<<"Initialisation cell num "<< cl.user_data.offset_subcells[offset_orig]<<std::endl;
    }
}


/// Useful to plot level set pre FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function>
void
output_mesh_info2_pre_FEM(const Mesh& msh, const Function& level_set_function)
{
    using RealType = typename Mesh::coordinate_type;

    /************** OPEN SILO DATABASE **************/
    silo_database silo;
    silo.create("cuthho_meshinfo_preFEM_Stokes.silo");
    silo.add_mesh(msh, "mesh");

    /************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector<RealType> cut_cell_markers;
    for (auto& cl : msh.cells)
    {
        if ( location(msh, cl) == element_location::IN_POSITIVE_SIDE )
            cut_cell_markers.push_back(1.0);
        else if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            cut_cell_markers.push_back(-1.0);
        else if ( location(msh, cl) == element_location::ON_INTERFACE )
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
    std::vector<RealType> highlight_markers;
    for (auto& cl : msh.cells)
    {
        if ( cl.user_data.highlight )
            highlight_markers.push_back(1.0);
        else
            highlight_markers.push_back(0.0);

    }
    silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector<RealType> level_set_vals;
    // for (auto& pt : msh.points)
    //    level_set_vals.push_back( level_set_function(pt) );
    for (auto& n : msh.nodes)
        level_set_vals.push_back( level_set_function(n) );

    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

    /************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector<RealType> node_pos;
    for (auto& n : msh.nodes)
        node_pos.push_back( location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0 );
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

    std::vector<RealType> cell_set;
    for (auto& cl : msh.cells)
    {
        RealType r;

        switch ( cl.user_data.agglo_set )
        {
            case cell_agglo_set::UNDEF:
                r = 0.0;
                break;

            case cell_agglo_set::T_OK:
                r = 1.0;
                break;

            case cell_agglo_set::T_KO_NEG:
                r = 2.0;
                break;

            case cell_agglo_set::T_KO_POS:
                r = 3.0;
                break;

        }

        cell_set.push_back( r );
    }
    silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

    silo.close();

    /*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
    std::vector<RealType> int_pts_x;
    std::vector<RealType> int_pts_y;

    for (auto& fc : msh.faces)
    {
        if( fc.user_data.location != element_location::ON_INTERFACE ) continue;

        RealType x = fc.user_data.intersection_point.x();
        RealType y = fc.user_data.intersection_point.y();

        int_pts_x.push_back(x);
        int_pts_y.push_back(y);
    }

    std::ofstream points_file_pre_FEM("int_points_pre_FEM.3D", std::ios::out | std::ios::trunc);

    if(points_file_pre_FEM)
    {
        // instructions
        points_file_pre_FEM << "X   Y   Z   val" << std::endl;

        for( size_t i = 0; i<int_pts_x.size(); i++)
        {
            points_file_pre_FEM << int_pts_x[i] << "   " <<  int_pts_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        points_file_pre_FEM.close();
    }

    else
        std::cerr << "points_file_pre_FEM has not been opened" << std::endl;


    /*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector<RealType> int_x;
    std::vector<RealType> int_y;

    for (auto& cl : msh.cells)
    {
        if( cl.user_data.location != element_location::ON_INTERFACE ) continue;

        for(size_t i = 0; i < cl.user_data.interface.size(); i++)
        {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }
    std::ofstream interface_file_preFEM("interface_pre_FEM_Stokes.3D", std::ios::out | std::ios::trunc);

    if(interface_file_preFEM)
    {
        // instructions
        interface_file_preFEM << "X   Y   Z   val" << std::endl;

        for( size_t i = 0; i<int_x.size(); i++)
        {
            interface_file_preFEM << int_x[i] << "   " <<  int_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        interface_file_preFEM.close();
    }

    else
        std::cerr << "interface_file_preFEM has not been opened" << std::endl;
}


template<typename Mesh, typename VEC , typename T >
void
goal_quantities_time_fast_para(const Mesh& msh,const VEC& interface_gamma  , const VEC& tangent_gamma,const VEC& normal_gamma , const std::vector<T>& curvature_gamma)
{

    std::string filename_stokes4 = "tangent_gamma_para.3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if(interface_file4)
    {
        // instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<(*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
            << tangent_gamma[i](0) << "   " <<tangent_gamma[i](1)<< std::endl;

            i++;

        }

        interface_file4.close();
    }
    else
        std::cerr << "File 'tangent_gamma' has not been opened" << std::endl;
    
    std::string filename_stokes0 = "normal_gamma_para.3D";
       std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

       if(interface_file0)
       {
           // instructions
           interface_file0 << "X   Y   val0   val1" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
           {
               //std::cout<<val_u_nx[i]<<std::endl;
               interface_file0 << std::setprecision(std::numeric_limits<long double>::digits10 + 1) << (*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
               << normal_gamma[i](0) << "   " <<normal_gamma[i](1)<< std::endl;

               i++;

           }

           interface_file0.close();
       }
       else
           std::cerr << "File 'normal_gamma' has not been opened" << std::endl;
    
    std::string filename_stokes1 = "curvature_gamma_para.3D";
          std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

          if(interface_file1)
          {
              // instructions
              interface_file1 << "X   Y   val0" << std::endl;
              size_t i = 0;
              for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
              {
                  //std::cout<<val_u_nx[i]<<std::endl;
                  interface_file1 << std::setprecision(std::numeric_limits<long double>::digits10 + 1)  << (*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
                  << curvature_gamma[i] << std::endl;

                  i++;

              }

              interface_file1.close();
          }
          else
              std::cerr << "File 'curvature_gamma' has not been opened" << std::endl;


}


template<typename Mesh, typename VEC , typename T >
void
goal_quantities_time_fast_para_cont(const Mesh& msh,const VEC& interface_gamma  , const VEC& tangent_gamma,const VEC& normal_gamma , const std::vector<T>& curvature_gamma)
{

    std::string filename_stokes4 = "tangent_gamma_para_cont.3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if(interface_file4)
    {
        // instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<(*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
            << tangent_gamma[i](0) << "   " <<tangent_gamma[i](1)<< std::endl;

            i++;

        }

        interface_file4.close();
    }
    else
        std::cerr << "File 'tangent_gamma' has not been opened" << std::endl;
    
    std::string filename_stokes0 = "normal_gamma_para_cont.3D";
       std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

       if(interface_file0)
       {
           // instructions
           interface_file0 << "X   Y   val0   val1" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
           {
               //std::cout<<val_u_nx[i]<<std::endl;
               interface_file0 << std::setprecision(std::numeric_limits<long double>::digits10 + 1) << (*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
               << normal_gamma[i](0) << "   " <<normal_gamma[i](1)<< std::endl;

               i++;

           }

           interface_file0.close();
       }
       else
           std::cerr << "File 'normal_gamma' has not been opened" << std::endl;
    
    std::string filename_stokes1 = "curvature_gamma_para_cont.3D";
          std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

          if(interface_file1)
          {
              // instructions
              interface_file1 << "X   Y   val0" << std::endl;
              size_t i = 0;
              for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
              {
                  //std::cout<<val_u_nx[i]<<std::endl;
                  interface_file1 << std::setprecision(std::numeric_limits<long double>::digits10 + 1)  << (*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
                  << curvature_gamma[i] << std::endl;

                  i++;

              }

              interface_file1.close();
          }
          else
              std::cerr << "File 'curvature_gamma' has not been opened" << std::endl;


}


template<typename Mesh, typename VEC , typename T >
void
goal_quantities_time_fast(const Mesh& msh,const VEC& interface_gamma  , const VEC& tangent_gamma,const VEC& normal_gamma , const std::vector<T>& curvature_gamma)
{

    std::string filename_stokes4 = "tangent_gamma.3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if(interface_file4)
    {
        // instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<(*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
            << tangent_gamma[i](0) << "   " <<tangent_gamma[i](1)<< std::endl;

            i++;

        }

        interface_file4.close();
    }
    else
        std::cerr << "File 'tangent_gamma' has not been opened" << std::endl;
    
    std::string filename_stokes0 = "normal_gamma.3D";
       std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

       if(interface_file0)
       {
           // instructions
           interface_file0 << "X   Y   val0   val1" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
           {
               //std::cout<<val_u_nx[i]<<std::endl;
               interface_file0 << std::setprecision(std::numeric_limits<long double>::digits10 + 1) << (*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
               << normal_gamma[i](0) << "   " <<normal_gamma[i](1)<< std::endl;

               i++;

           }

           interface_file0.close();
       }
       else
           std::cerr << "File 'normal_gamma' has not been opened" << std::endl;
    
    std::string filename_stokes1 = "curvature_gamma.3D";
          std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

          if(interface_file1)
          {
              // instructions
              interface_file1 << "X   Y   val0" << std::endl;
              size_t i = 0;
              for(auto interface_point = interface_gamma.begin() ; interface_point < interface_gamma.end() ; interface_point++ )
              {
                  //std::cout<<val_u_nx[i]<<std::endl;
                  interface_file1 << std::setprecision(std::numeric_limits<long double>::digits10 + 1)  << (*interface_point)(0) << "   " <<  (*interface_point)(1) << "   "
                  << curvature_gamma[i] << std::endl;

                  i++;

              }

              interface_file1.close();
          }
          else
              std::cerr << "File 'curvature_gamma' has not been opened" << std::endl;


}

template<typename Mesh, typename VEC , typename T >
void
goal_quantities_time_fast(const Mesh& msh,const VEC& interface_points , const std::vector<T>& val_u_n , const std::vector<std::pair<T,T>>& vec_n , size_t time_step )
{

    std::string filename_stokes4 = "vec_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if(interface_file4)
    {
        // instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i]*vec_n[i].first << "   " << val_u_n[i]*vec_n[i].second<< std::endl;

            i++;

        }

        interface_file4.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;
    
    std::string filename_stokes7 = "vec_normal_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file7(filename_stokes7, std::ios::out | std::ios::trunc);

    if(interface_file7)
    {
        // instructions
        interface_file7 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file7 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << vec_n[i].first << "   " << vec_n[i].second<< std::endl;

            i++;

        }

        interface_file7.close();
    }
    else
        std::cerr << "File 'vec_normal_' has not been opened" << std::endl;

}



template<typename Mesh, typename VEC , typename T >
void
goal_quantities_time(const Mesh& msh, T time ,const VEC& interface_points , const std::vector<T>& val_u_nx , const std::vector<T>& val_u_ny , const std::vector<T>& val_u_n , const std::vector<std::pair<T,T>>& vec_u_n , const std::vector<std::pair<T,T>>& velocity_interface , const std::vector<std::pair<T,T>>& velocity_field , const std::vector<std::pair<T,T>>& points_vel_field , size_t time_step )
{
    /*
    std::string filename_stokes0 = "val_u_nx_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if(interface_file0)
    {
        // instructions
        interface_file0 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file0 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_nx[i] << "    0.0"<< std::endl;

            i++;

        }

        interface_file0.close();
    }
    else
        std::cerr << "File 'val_u_nx' has not been opened" << std::endl;

    std::string filename_stokes1 = "val_u_ny_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

       if(interface_file1)
       {
           // instructions
           interface_file1 << "X   Y   Z   val" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
           {
               //std::cout<<val_u_ny[i]<<std::endl;
               interface_file1 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
               << val_u_ny[i] << "    0.0"<< std::endl;
               i++;
           }

           interface_file1.close();
       }
       else
           std::cerr << "File 'val_u_ny' has not been opened" << std::endl;


    std::string filename_stokes2 = "val_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file2(filename_stokes2, std::ios::out | std::ios::trunc);

    if(interface_file2)
    {
        // instructions
        interface_file2 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_n[i]<<std::endl;
            interface_file2 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i] << "    0.0"<< std::endl;
            i++;
        }

        interface_file2.close();
    }
    else
        std::cerr << "File 'val_u_n' has not been opened" << std::endl;



    postprocess_output<double> postoutput_vec_u_n;
    std::string filename_stokes3 = "vec_u_n_" + std::to_string(time_step) + ".dat";
    auto test_vec_u_n = std::make_shared< gnuplot_output_object_vec<double> >(filename_stokes3);

    size_t i = 0;
    for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
    {
        test_vec_u_n->add_data(*interface_point,std::make_pair( val_u_n[i]*vec_u_n[i].first , val_u_n[i]*vec_u_n[i].second ) );
        i++;
    }

    postoutput_vec_u_n.add_object(test_vec_u_n);
    postoutput_vec_u_n.write();

   */
    std::string filename_stokes4 = "vec_u_n_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if(interface_file4)
    {
        // instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i]*vec_u_n[i].first << "   " << val_u_n[i]*vec_u_n[i].second<< std::endl;

            i++;

        }

        interface_file4.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

    /*
    std::string filename_stokes5 = "velocity_interface_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file5(filename_stokes5, std::ios::out | std::ios::trunc);

    if(interface_file5)
    {
        // instructions
        interface_file5 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file5 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << velocity_interface[i].first << "   " << velocity_interface[i].second<< std::endl;

            i++;

        }

        interface_file5.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;


    std::string filename_stokes6 = "velocity_field_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file6(filename_stokes6, std::ios::out | std::ios::trunc);

    if(interface_file6)
    {
        // instructions
        interface_file6 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto point_vel = points_vel_field.begin() ; point_vel < points_vel_field.end() ; point_vel++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file6 << (*point_vel).first << "   " <<  (*point_vel).second << "   "
            << velocity_field[i].first << "   " << velocity_field[i].second<< std::endl;

            i++;

        }

        interface_file6.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;

    std::string filename_stokes7 = "vec_normal_" + std::to_string(time_step) + ".3D";
    std::ofstream interface_file7(filename_stokes7, std::ios::out | std::ios::trunc);

    if(interface_file7)
    {
        // instructions
        interface_file7 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file7 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << vec_u_n[i].first << "   " << vec_u_n[i].second<< std::endl;

            i++;

        }

        interface_file7.close();
    }
    else
        std::cerr << "File 'vec_normal_' has not been opened" << std::endl;
    */
}

template<typename Mesh, typename VEC , typename T >
void
goal_quantities_time(const Mesh& msh, T time ,const VEC& interface_points , const std::vector<T>& val_u_nx , const std::vector<T>& val_u_ny , const std::vector<T>& val_u_n , const std::vector<std::pair<T,T>>& vec_u_n  )
{

    std::string filename_stokes0 = "val_u_nx_" + std::to_string(time) + ".3D";
    std::ofstream interface_file0(filename_stokes0, std::ios::out | std::ios::trunc);

    if(interface_file0)
    {
        // instructions
        interface_file0 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file0 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_nx[i] << "    0.0"<< std::endl;

            i++;

        }

        interface_file0.close();
    }
    else
        std::cerr << "File 'val_u_nx' has not been opened" << std::endl;

    std::string filename_stokes1 = "val_u_ny_" + std::to_string(time) + ".3D";
    std::ofstream interface_file1(filename_stokes1, std::ios::out | std::ios::trunc);

       if(interface_file1)
       {
           // instructions
           interface_file1 << "X   Y   Z   val" << std::endl;
           size_t i = 0;
           for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
           {
               //std::cout<<val_u_ny[i]<<std::endl;
               interface_file1 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
               << val_u_ny[i] << "    0.0"<< std::endl;
               i++;
           }

           interface_file1.close();
       }
       else
           std::cerr << "File 'val_u_ny' has not been opened" << std::endl;


    std::string filename_stokes2 = "val_u_n_" + std::to_string(time) + ".3D";
    std::ofstream interface_file2(filename_stokes2, std::ios::out | std::ios::trunc);

    if(interface_file2)
    {
        // instructions
        interface_file2 << "X   Y   Z   val" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_n[i]<<std::endl;
            interface_file2 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i] << "    0.0"<< std::endl;
            i++;
        }

        interface_file2.close();
    }
    else
        std::cerr << "File 'val_u_n' has not been opened" << std::endl;



    postprocess_output<double> postoutput_vec_u_n;
    std::string filename_stokes3 = "vec_u_n_" + std::to_string(time) + ".dat";
    auto test_vec_u_n = std::make_shared< gnuplot_output_object_vec<double> >(filename_stokes3);

    size_t i = 0;
    for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
    {
        test_vec_u_n->add_data(*interface_point,std::make_pair( val_u_n[i]*vec_u_n[i].first , val_u_n[i]*vec_u_n[i].second ) );
        i++;
    }

    postoutput_vec_u_n.add_object(test_vec_u_n);
    postoutput_vec_u_n.write();


    std::string filename_stokes4 = "vec_u_n_" + std::to_string(time) + ".3D";
    std::ofstream interface_file4(filename_stokes4, std::ios::out | std::ios::trunc);

    if(interface_file4)
    {
        // instructions
        interface_file4 << "X   Y   val0   val1" << std::endl;
        size_t i = 0;
        for(auto interface_point = interface_points.begin() ; interface_point < interface_points.end() ; interface_point++ )
        {
            //std::cout<<val_u_nx[i]<<std::endl;
            interface_file4 << (*interface_point).x() << "   " <<  (*interface_point).y() << "   "
            << val_u_n[i]*vec_u_n[i].first << "   " << val_u_n[i]*vec_u_n[i].second<< std::endl;

            i++;

        }

        interface_file4.close();
    }
    else
        std::cerr << "File 'vec_u_n' has not been opened" << std::endl;




}

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function , typename T >
void
output_mesh_info2_time(const Mesh& msh, const Function& level_set_function, T time,size_t time_step)
{
    using RealType = typename Mesh::coordinate_type;

    /************** OPEN SILO DATABASE **************/
    silo_database silo;
    std::string filename_silo = "cuthho_meshinfo_Stokes_" + std::to_string(time_step) + ".silo";
    silo.create(filename_silo);
    silo.add_mesh(msh, "mesh");

    /************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector<RealType> cut_cell_markers;
    for (auto& cl : msh.cells)
    {
        if ( location(msh, cl) == element_location::IN_POSITIVE_SIDE )
            cut_cell_markers.push_back(1.0);
        else if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            cut_cell_markers.push_back(-1.0);
        else if ( location(msh, cl) == element_location::ON_INTERFACE )
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
    std::vector<RealType> highlight_markers;
    for (auto& cl : msh.cells)
    {
        if ( cl.user_data.highlight )
            highlight_markers.push_back(1.0);
        else
            highlight_markers.push_back(0.0);

    }
    silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector<RealType> level_set_vals;
    // for (auto& pt : msh.points)
    //    level_set_vals.push_back( level_set_function(pt) );
    for (auto& n : msh.nodes)
        level_set_vals.push_back( level_set_function(n) );

    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

    /************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector<RealType> node_pos;
    for (auto& n : msh.nodes)
        node_pos.push_back( location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0 );
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

    std::vector<RealType> cell_set;
    for (auto& cl : msh.cells)
    {
        RealType r;

        switch ( cl.user_data.agglo_set )
        {
            case cell_agglo_set::UNDEF:
                r = 0.0;
                break;

            case cell_agglo_set::T_OK:
                r = 1.0;
                break;

            case cell_agglo_set::T_KO_NEG:
                r = 2.0;
                break;

            case cell_agglo_set::T_KO_POS:
                r = 3.0;
                break;

        }

        cell_set.push_back( r );
    }
    silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

    silo.close();

    /*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
    std::vector<RealType> int_pts_x;
    std::vector<RealType> int_pts_y;

    for (auto& fc : msh.faces)
    {
        if( fc.user_data.location != element_location::ON_INTERFACE ) continue;

        RealType x = fc.user_data.intersection_point.x();
        RealType y = fc.user_data.intersection_point.y();

        int_pts_x.push_back(x);
        int_pts_y.push_back(y);
    }

    std::ofstream points_file("int_points.3D", std::ios::out | std::ios::trunc);

    if(points_file)
    {
        // instructions
        points_file << "X   Y   Z   val" << std::endl;

        for( size_t i = 0; i<int_pts_x.size(); i++)
        {
            points_file << int_pts_x[i] << "   " <<  int_pts_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        points_file.close();
    }

    else
        std::cerr << "Points_file has not been opened" << std::endl;


    /*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector<RealType> int_x;
    std::vector<RealType> int_y;

    for (auto& cl : msh.cells)
    {
        if( cl.user_data.location != element_location::ON_INTERFACE ) continue;

        for(size_t i = 0; i < cl.user_data.interface.size(); i++)
        {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }

    std::string filename_interface_Stokes = "interface_Stokes_" + std::to_string(time_step) + ".3D";

    std::ofstream interface_file(filename_interface_Stokes, std::ios::out | std::ios::trunc);

    if(interface_file)
    {
        // instructions
        interface_file << "X   Y   Z   val" << std::endl;

        for( size_t i = 0; i<int_x.size(); i++)
        {
            interface_file << int_x[i] << "   " <<  int_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        interface_file.close();
    }

    else
        std::cerr << "Interface_file has not been opened" << std::endl;
}

/// Useful to plot level set post FE transport problem
/// in cuthho_export.hpp
template<typename Mesh, typename Function>
void
output_mesh_info2(const Mesh& msh, const Function& level_set_function)
{
    using RealType = typename Mesh::coordinate_type;

    /************** OPEN SILO DATABASE **************/
    silo_database silo;
    silo.create("cuthho_meshinfo_Stokes.silo");
    silo.add_mesh(msh, "mesh");

    /************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector<RealType> cut_cell_markers;
    for (auto& cl : msh.cells)
    {
        if ( location(msh, cl) == element_location::IN_POSITIVE_SIDE )
            cut_cell_markers.push_back(1.0);
        else if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            cut_cell_markers.push_back(-1.0);
        else if ( location(msh, cl) == element_location::ON_INTERFACE )
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR CELL HIGHLIGHT **************/
    std::vector<RealType> highlight_markers;
    for (auto& cl : msh.cells)
    {
        if ( cl.user_data.highlight )
            highlight_markers.push_back(1.0);
        else
            highlight_markers.push_back(0.0);

    }
    silo.add_variable("mesh", "highlighted_cells", highlight_markers.data(), highlight_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector<RealType> level_set_vals;
    // for (auto& pt : msh.points)
    //    level_set_vals.push_back( level_set_function(pt) );
    for (auto& n : msh.nodes)
        level_set_vals.push_back( level_set_function(n) );

    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

    /************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector<RealType> node_pos;
    for (auto& n : msh.nodes)
        node_pos.push_back( location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0 );
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);

    std::vector<RealType> cell_set;
    for (auto& cl : msh.cells)
    {
        RealType r;

        switch ( cl.user_data.agglo_set )
        {
            case cell_agglo_set::UNDEF:
                r = 0.0;
                break;

            case cell_agglo_set::T_OK:
                r = 1.0;
                break;

            case cell_agglo_set::T_KO_NEG:
                r = 2.0;
                break;

            case cell_agglo_set::T_KO_POS:
                r = 3.0;
                break;

        }

        cell_set.push_back( r );
    }
    silo.add_variable("mesh", "agglo_set", cell_set.data(), cell_set.size(), zonal_variable_t);

    silo.close();

    /*************  MAKE AN OUTPUT FOR THE INTERSECTION POINTS *************/
    std::vector<RealType> int_pts_x;
    std::vector<RealType> int_pts_y;

    for (auto& fc : msh.faces)
    {
        if( fc.user_data.location != element_location::ON_INTERFACE ) continue;

        RealType x = fc.user_data.intersection_point.x();
        RealType y = fc.user_data.intersection_point.y();

        int_pts_x.push_back(x);
        int_pts_y.push_back(y);
    }

    std::ofstream points_file("int_points.3D", std::ios::out | std::ios::trunc);

    if(points_file)
    {
        // instructions
        points_file << "X   Y   Z   val" << std::endl;

        for( size_t i = 0; i<int_pts_x.size(); i++)
        {
            points_file << int_pts_x[i] << "   " <<  int_pts_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        points_file.close();
    }

    else
        std::cerr << "Points_file has not been opened" << std::endl;


    /*************  MAKE AN OUTPUT FOR THE INTERFACE *************/
    std::vector<RealType> int_x;
    std::vector<RealType> int_y;

    for (auto& cl : msh.cells)
    {
        if( cl.user_data.location != element_location::ON_INTERFACE ) continue;

        for(size_t i = 0; i < cl.user_data.interface.size(); i++)
        {
            RealType x = cl.user_data.interface.at(i).x();
            RealType y = cl.user_data.interface.at(i).y();

            int_x.push_back(x);
            int_y.push_back(y);
        }
    }
    std::ofstream interface_file("interface_Stokes.3D", std::ios::out | std::ios::trunc);

    if(interface_file)
    {
        // instructions
        interface_file << "X   Y   Z   val" << std::endl;

        for( size_t i = 0; i<int_x.size(); i++)
        {
            interface_file << int_x[i] << "   " <<  int_y[i]
                        << "   0.0     0.0" << std::endl;
        }

        interface_file.close();
    }

    else
        std::cerr << "Interface_file has not been opened" << std::endl;
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh>
point<T, 2>
find_zero_crossing_on_face(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,
                   const T& threshold, const Mesh & msh, const typename Mesh::face_type& fc)
{
    /* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

    // I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa+pb)/2.0;
    auto pm_prev = pm;

    T x_diff_sq, y_diff_sq;

    /* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50;

    do {
        auto la = level_set_function(pa,msh,fc);
        auto lb = level_set_function(pb,msh,fc);
        auto lm = level_set_function(pm,msh,fc);

        if ( (lb >= 0 && lm >= 0) || (lb < 0 && lm < 0) )
        {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa+pb)/2.0;
        }
        else
        {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa+pb)/2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );

    return pm;

    /* Affine zero crossing was like that: */
    //auto t = l0/(l0-l1);
    //auto ip = (pts[1] - pts[0]) * t + pts[0];
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh>
point<T, 2>
find_zero_crossing_on_face3(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,
                   const T& threshold, const Mesh & msh, const typename Mesh::face_type& fc)
{
    /* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

    // I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa+pb)/2.0;
    auto pm_prev = pm;
    T iso_val_interface = level_set_function.iso_val_interface ;
    T x_diff_sq, y_diff_sq;

    /* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50;

    do {
        //auto la = level_set_function(pa,msh,fc);
        auto lb = level_set_function(pb,msh,fc);
        auto lm = level_set_function(pm,msh,fc);

        if ( (lb >= iso_val_interface && lm >= iso_val_interface) || (lb < iso_val_interface && lm < iso_val_interface) )
        {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa+pb)/2.0;
        }
        else
        {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa+pb)/2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );

    return pm;

    /* Affine zero crossing was like that: */
    //auto t = l0/(l0-l1);
    //auto ip = (pts[1] - pts[0]) * t + pts[0];
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh >
point<T, 2>
find_zero_crossing_in_cell(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,
                   const T& threshold, const Mesh & msh, const typename Mesh::cell_type& cl)
{
    /* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

    // I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa+pb)/2.0;
    auto pm_prev = pm;

    T x_diff_sq, y_diff_sq;

    /* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50; // ERA 50, METTO 100

    do {
        auto la = level_set_function(pa,msh,cl);
        auto lb = level_set_function(pb,msh,cl);
        auto lm = level_set_function(pm,msh,cl);

        if ( (lb >= 0 && lm >= 0) || (lb < 0 && lm < 0) )
        {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa+pb)/2.0;
        }
        else
        {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa+pb)/2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );

    return pm;

    /* Affine zero crossing was like that: */
    //auto t = l0/(l0-l1);
    //auto ip = (pts[1] - pts[0]) * t + pts[0];
}

/// New version of find_zero_crossing for discret level set functions
/// in cuthho_geom.hpp
template<typename T, typename Function, typename Mesh >
point<T, 2>
find_zero_crossing_in_cell3(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,
                   const T& threshold, const Mesh & msh, const typename Mesh::cell_type& cl)
{
    /* !!! We assume that the level set function *has* a zero crossing
     * between p0 and p1 !!! */

    // I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????
    auto pa = p0;
    auto pb = p1;
    auto pm = (pa+pb)/2.0;
    auto pm_prev = pm;
    T iso_val_interface = level_set_function.iso_val_interface ;
    T x_diff_sq, y_diff_sq;

    /* A threshold of 1/10000 the diameter of the element is considered
     * acceptable. Since with 24 iterations we reduce the error by 16384
     * and the worst case is that the two points are at the opposite sides
     * of the element, we put 30 as limit. */
    size_t max_iter = 50; // ERA 50, METTO 100

    do {
        //auto la = level_set_function(pa,msh,cl);
        auto lb = level_set_function(pb,msh,cl);
        auto lm = level_set_function(pm,msh,cl);

        if ( (lb >= iso_val_interface && lm >= iso_val_interface) || (lb < iso_val_interface && lm < iso_val_interface) )
        {   /* intersection is between pa and pm */
            pm_prev = pm;
            pb = pm;
            pm = (pa+pb)/2.0;
        }
        else
        {   /* intersection is between pm and pb */
            pm_prev = pm;
            pa = pm;
            pm = (pa+pb)/2.0;
        }

        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());
        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());

    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );

    return pm;

    /* Affine zero crossing was like that: */
    //auto t = l0/(l0-l1);
    //auto ip = (pts[1] - pts[0]) * t + pts[0];
}



/// New version of detect_node_position for discret level functions
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_node_position2(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    for (auto& n : msh.nodes)
    {
        //auto pt = points(msh, n); //deleted by Stefano
        //if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);
        if( std::abs(value_node) < 1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }



        if ( value_node < 0 ) // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
        else
            n.user_data.location = element_location::IN_POSITIVE_SIDE;



    }
}


/// New version of detect_node_position for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_node_position3(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{

    timecounter tc;
    tc.tic();
    T iso_val_interface = level_set_function.iso_val_interface ;
    //std::cout<<"In 'detect_node' -> iso_val_interface = "<<iso_val_interface<<std::endl;

    for (auto& n : msh.nodes)
    {
        //auto pt = points(msh, n); //deleted by Stefano
        //if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position3 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }



        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }
        //std::cout<<"Value_node = "<< value_node<<std::endl;

    }

    tc.toc();
    //std::cout << bold << yellow << "detect_node_position3, time resolution: " << tc << " seconds" << reset << std::endl;
}

/// New version of detect_node_position for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
/*
template<typename T, size_t ET, typename Function>
void
detect_node_position3_parallel(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    timecounter tc ;
    tc.tic();
    T iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"In 'detect_node' -> iso_val_interface = "<<iso_val_interface<<std::endl;
#ifdef HAVE_INTEL_TBB
    size_t n_nodes = msh.nodes.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_nodes), size_t(1),
    [&msh,&level_set_function,&iso_val_interface] (size_t & cell_ind){
        auto& n = msh.nodes[cell_ind];
        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }



        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
                //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
                //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }

    }
    );

    tc.toc();
    //std::cout << "detect_node_position3_parallel, time resolution: " << tc << " seconds" << std::endl;
#else

    for (auto& n : msh.nodes)
    {
        //auto pt = points(msh, n); //deleted by Stefano
        //if ( level_set_function(pt) < 0 ) //deleted by Stefano

        T value_node = level_set_function(n);

        if( std::abs(value_node - iso_val_interface) <  1e-17 ){
            std::cout<<"In detect_node_position2 -> ATTENTION, INTERFACE ON A NODE!"<<std::endl;
            auto pt = points(msh, n);
            value_node = level_set_function(pt) ;
        }


        //std::cout<<"value_node SEQUENTIAL = "<<level_set_function(n)<<std::endl;
        if ( value_node < iso_val_interface ){ // add by Stefano
            n.user_data.location = element_location::IN_NEGATIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_NEGATIVE_SIDE"<<std::endl;
        }
        else{
            n.user_data.location = element_location::IN_POSITIVE_SIDE;
            //std::cout<<"n.user_data.location = IN_POSITIVE_SIDE"<<std::endl;
        }
        //std::cout<<"Value_node = "<< value_node<<std::endl;

    }


#endif

}
*/
/// New version of detect_cut_faces for discret level functions
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_faces2(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    for (auto& fc : msh.faces)
    {
        auto pts = points(msh, fc);
        /*
        if( (pts[0].x() == 0.375) && (pts[0].y() == 0.5) )
        {
            std::cout<<"CASE pt0!!"<<std::endl;
            std::cout<<"AND  pts[1] = "<<pts[1]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        if( (pts[1].x() == 0.375) && (pts[1].y() == 0.5) )
        {
            std::cout<<"CASE pt1!!"<<std::endl;
            std::cout<<"AND  pts[0] = "<<pts[0]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        */
        //auto l0 = level_set_function(pts[0]);      //deleted by Stefano
        //auto l1 = level_set_function(pts[1]);       //deleted by Stefano

        auto l0 = level_set_function(pts[0],msh,fc);      // add by Stefano
        auto l1 = level_set_function(pts[1],msh,fc);       // add by Stefano

        // In the case doubt, I don't care the value, just the sign and I assign the same sign of the other. JUST ONE OF THE TWO SHOULD BE SO SMALL
        if( (std::abs(l0) < 1e-17) && (std::abs(l1) < 1e-17) )
            std::cout<<"STOP --> CASE DOUBT: l0 = "<<l0<< " and l1 = "<<l1<<std::endl;

        else if( std::abs(l0) < 1e-17 ){
            std::cout<<"The node "<<pts[0]<<" is very close to the interface."<<std::endl;
            l0 = level_set_function(pts[0]) ;
            std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        else if( std::abs(l1) < 1e-17 ){
            std::cout<<"The node "<<pts[1]<<" is very close to the interface."<<std::endl;
            l1 = level_set_function(pts[1]) ;
            std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        /*
        if( ((pts[1].x() == 0.375) && (pts[1].y() == 0.5) ) ||(pts[0].x() == 0.375) && (pts[0].y() == 0.5))
        {
        std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        */
        if (l0 >= 0 && l1 >= 0)
        {
            fc.user_data.location = element_location::IN_POSITIVE_SIDE;
            continue;
        }

        if (l0 < 0 && l1 < 0)
        {
            fc.user_data.location = element_location::IN_NEGATIVE_SIDE;
            continue;
        }



        auto threshold = diameter(msh, fc) / 1e20;
        //auto pm = find_zero_crossing(pts[0], pts[1], level_set_function, threshold);
        auto pm = find_zero_crossing_on_face(pts[0], pts[1], level_set_function, threshold,msh,fc);

        /* If node 0 is in the negative region, mark it as node inside, otherwise mark node 1 */
        fc.user_data.node_inside = ( l0 < 0 ) ? 0 : 1;
        fc.user_data.location = element_location::ON_INTERFACE;
        fc.user_data.intersection_point = pm;
    }
}

/// New version of detect_cut_faces for discret level functions -> USING interface = 1/2
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_faces3(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    T iso_val_interface = level_set_function.iso_val_interface ;
    //std::cout<<"In 'detect_cut_face3'--> iso_val_interface = "<<iso_val_interface<<std::endl;
    for (auto& fc : msh.faces)
    {
        auto pts = points(msh, fc);
        /*
        if( (pts[0].x() == 0.375) && (pts[0].y() == 0.5) )
        {
            std::cout<<"CASE pt0!!"<<std::endl;
            std::cout<<"AND  pts[1] = "<<pts[1]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        if( (pts[1].x() == 0.375) && (pts[1].y() == 0.5) )
        {
            std::cout<<"CASE pt1!!"<<std::endl;
            std::cout<<"AND  pts[0] = "<<pts[0]<<std::endl;
            std::cout<<"level_set_function(pts[0]) = "<<level_set_function(pts[0])<< " , level_set_function(pts[1]) = "<<level_set_function(pts[1])<<std::endl;
             std::cout<<"level_set_function(pts[0],msh,fc) = "<<level_set_function(pts[0],msh,fc)<< " , level_set_function(pts[1],msh,fc) = "<<level_set_function(pts[1],msh,fc)<<'\n'<<std::endl;


        }
        */
        //auto l0 = level_set_function(pts[0]);      //deleted by Stefano
        //auto l1 = level_set_function(pts[1]);       //deleted by Stefano

        auto l0 = level_set_function(pts[0],msh,fc);      // add by Stefano
        auto l1 = level_set_function(pts[1],msh,fc);       // add by Stefano

        // In the case doubt, I don't care the value, just the sign and I assign the same sign of the other. JUST ONE OF THE TWO SHOULD BE SO SMALL
        if( (std::abs(l0-iso_val_interface) < 1e-17) && (std::abs(l1-iso_val_interface) < 1e-17) )
            std::cout<<"STOP --> CASE DOUBT: l0 = "<<l0<< " and l1 = "<<l1<<std::endl;

        else if( std::abs(l0-iso_val_interface) < 1e-17 ){
            std::cout<<"The node "<<pts[0]<<" is very close to the interface."<<std::endl;
            l0 = level_set_function(pts[0]) ;
            std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        else if( std::abs(l1-iso_val_interface) < 1e-17 ){
            std::cout<<"The node "<<pts[1]<<" is very close to the interface."<<std::endl;
            l1 = level_set_function(pts[1]) ;
            std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        /*
        if( ((pts[1].x() == 0.375) && (pts[1].y() == 0.5) ) ||(pts[0].x() == 0.375) && (pts[0].y() == 0.5))
        {
        std::cout<<"l0 = "<<l0<< " ,l1 = "<<l1<<'\n'<<std::endl;
        }
        */
        if (l0 >= iso_val_interface && l1 >= iso_val_interface)
        {
            fc.user_data.location = element_location::IN_POSITIVE_SIDE;
            continue;
        }

        if (l0 < iso_val_interface && l1 < iso_val_interface)
        {
            fc.user_data.location = element_location::IN_NEGATIVE_SIDE;
            continue;
        }



        auto threshold = diameter(msh, fc) / 1e20;
        //auto pm = find_zero_crossing(pts[0], pts[1], level_set_function, threshold);
        auto pm = find_zero_crossing_on_face3(pts[0], pts[1], level_set_function, threshold,msh,fc);
        //std::cout<<"pm = "<<pm<< " and level_set_function = "<<level_set_function(pm,msh,fc)<<std::endl;
        /* If node 0 is in the negative region, mark it as node inside, otherwise mark node 1 */
        fc.user_data.node_inside = ( l0 < iso_val_interface ) ? 0 : 1;
        fc.user_data.location = element_location::ON_INTERFACE;
        fc.user_data.intersection_point = pm;
    }
}

/// New version of detect_cut_cells for discret level functions
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_cells2(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    std::cout<<"I AM IN DETECT CUT CELL2!!!!"<<std::endl;
    //typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    //typedef typename cuthho_mesh<T, ET>::cell_type cell_type;

    size_t cell_i = 0;
    for (auto& cl : msh.cells)
    {
        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }

        /* If a face is cut, the cells that own the face are cut. Is this
         * unconditionally true? It should...fortunately this isn't avionics
         * software */

        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > 0;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;




            /*
            auto pts = points(msh, cl);
            auto pt = pts.begin();
            size_t counter = 0;
            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )
            {
                counter++;
                pt++;

            }

            if ( counter == pts.size() )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;
            */

        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!
            /*
            if( !pt_in_cell(msh, pn, cl) )
            {
                std::cout<<"I chose another pn to ordering interface_points in 'detect_cut_cells2'."<<std::endl;
                T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
                T q = pm.y() - m_half * pm.x() ;
                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
                auto lm_bdry = level_set_function( pt_bdry , msh , cl );
            }
            */
            if(offset(msh,cl)== 137 || offset(msh,cl)== 138 || offset(msh,cl)== 134||offset(msh,cl)== 103){
                std::cout<<yellow<<bold<<"offset(msh,cl) = "<<offset(msh,cl)<<reset<<std::endl;
                auto pn_bis = (p0+p1)/2.0 + point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis = "<<pn_bis<< " , level_set_function(pn_bis,msh,cl) ="<<level_set_function(pn_bis,msh,cl) <<std::endl;
                auto pn_bis0 = (p0+p1)/2.0 + 0.5* point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis0 = "<<pn_bis0<< " , level_set_function(pn_bis0,msh,cl) ="<<level_set_function(pn_bis0,msh,cl) <<std::endl;
                auto pn_bis1 = p0 + 0.5 * point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis1 = "<<pn_bis1<< " , level_set_function(pn_bis1,msh,cl) ="<<level_set_function(pn_bis1,msh,cl)<<'\n' <<std::endl;

                std::cout<<"pn = "<<pn<< " , p0 = "<<p0<< " , p1 = "<<p1<<std::endl;
                std::cout<<"level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(p0,msh,cl) = "<<level_set_function(p0,msh,cl)<< " , level_set_function(pn,msh,cl) = "<<level_set_function(p1,msh,cl)<<std::endl;
                std::cout<<"p0 - point<T,2>(-pt.y(), pt.x()) = "<<p0 - point<T,2>(-pt.y(), pt.x())<< " , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = "<<level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl)<<std::endl;
            }


            if( !(signbit(level_set_function(pn,msh,cl)) == signbit(level_set_function(pn_prova,msh,cl))) ){
                pn = pn_prova ;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
            }

            if ( level_set_function(pn,msh,cl) >= 0 )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                  std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_i<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }
}

/// New version of detect_cut_cells for discret level functions -> USING INTERFACE = 1/2
/// in cuthho_geom.hpp
template<typename T, size_t ET, typename Function>
void
detect_cut_cells3(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    //std::cout<<"I AM IN DETECT CUT CELL3!!!!"<<std::endl;
    timecounter tc;
    tc.tic();
    //typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    //typedef typename cuthho_mesh<T, ET>::cell_type cell_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
    //std::cout<<"iso_val_interface = "<<iso_val_interface<<std::endl;
    size_t cell_i = 0;
    for (auto& cl : msh.cells)
    {
        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }

        /* If a face is cut, the cells that own the face are cut. Is this
         * unconditionally true? It should...fortunately this isn't avionics
         * software */

        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt,msh,cl) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;




            /*
            auto pts = points(msh, cl);
            auto pt = pts.begin();
            size_t counter = 0;
            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )
            {
                counter++;
                pt++;

            }

            if ( counter == pts.size() )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;
            */

        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!
            /*
            if( !pt_in_cell(msh, pn, cl) )
            {
                std::cout<<"I chose another pn to ordering interface_points in 'detect_cut_cells2'."<<std::endl;
                T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
                T q = pm.y() - m_half * pm.x() ;
                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
                auto lm_bdry = level_set_function( pt_bdry , msh , cl );
            }
            */
            /*
            if(offset(msh,cl)== 137 || offset(msh,cl)== 138 || offset(msh,cl)== 134||offset(msh,cl)== 103){
                std::cout<<yellow<<bold<<"offset(msh,cl) = "<<offset(msh,cl)<<reset<<std::endl;
                auto pn_bis = (p0+p1)/2.0 + point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis = "<<pn_bis<< " , level_set_function(pn_bis,msh,cl) ="<<level_set_function(pn_bis,msh,cl) <<std::endl;
                auto pn_bis0 = (p0+p1)/2.0 + 0.5* point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis0 = "<<pn_bis0<< " , level_set_function(pn_bis0,msh,cl) ="<<level_set_function(pn_bis0,msh,cl) <<std::endl;
                auto pn_bis1 = p0 + 0.5 * point<T,2>(-pt.y(), pt.x());
                std::cout<<"pn_bis1 = "<<pn_bis1<< " , level_set_function(pn_bis1,msh,cl) ="<<level_set_function(pn_bis1,msh,cl)<<'\n' <<std::endl;

                std::cout<<"pn = "<<pn<< " , p0 = "<<p0<< " , p1 = "<<p1<<std::endl;
                std::cout<<"level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(p0,msh,cl) = "<<level_set_function(p0,msh,cl)<< " , level_set_function(pn,msh,cl) = "<<level_set_function(p1,msh,cl)<<std::endl;
                std::cout<<"p0 - point<T,2>(-pt.y(), pt.x()) = "<<p0 - point<T,2>(-pt.y(), pt.x())<< " , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = "<<level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl)<<std::endl;
            }
            */

            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                  std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_i<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }
    tc.toc();
    //std::cout << bold << yellow << "detect_cut_cells3, time resolution: " << tc << " seconds" << reset << std::endl;
}

/*
template<typename T, size_t ET, typename Function>
void
detect_cut_cells3_parallelized(cuthho_mesh<T, ET>& msh, const Function& level_set_function)
{
    std::cout<<"I AM IN DETECT CUT CELL3 PARALLELELIZED !!!!"<<std::endl;
    timecounter tc;
    tc.tic();
    //typedef typename cuthho_mesh<T, ET>::face_type  face_type;
    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    //typedef typename cuthho_mesh<T, ET>::cell_type cell_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"iso_val_interface = "<<iso_val_interface<<std::endl;


#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&] (size_t & cell_ind){
        auto& cl = msh.cells[cell_ind];

        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }




        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;






        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!


            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                    std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_ind<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }


    });
    tc.toc();
    std::cout << bold << yellow << "detect_cut_cells3_parallelized, time resolution: " << tc << " seconds" << reset << std::endl;
#else

    size_t cell_i = 0;
    for (auto& cl : msh.cells)
    {
        auto fcs = faces(msh, cl);
        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;

        size_t k = 0;
        for (size_t i = 0; i < fcs.size(); i++)
        {
            if ( is_cut(msh, fcs[i]) )
                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);
        }



        if (k == 0)
        {

            auto is_positive = [&](const point_type& pt) -> bool {
            return level_set_function(pt) > iso_val_interface;
            };


            auto pts = points(msh, cl);

            if ( std::all_of(pts.begin(), pts.end(), is_positive) )
                cl.user_data.location = element_location::IN_POSITIVE_SIDE;
            else
                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;





        }
        //MODIFICARE QUAAAA
        if (k == 2)
        {
            cl.user_data.location = element_location::ON_INTERFACE;
            auto p0 = cut_faces[0].second;
            auto p1 = cut_faces[1].second;
            auto pt = p1 - p0;
            auto pn = p0 + point<T,2>(-pt.y(), pt.x());
            auto pn_prova = (p0+p1)/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());
            //if(offset(msh,cl)== 119)
            //    std::cout<<"p0 = "<<p0<< " , p1 ="<<p1<<std::endl;
            // PRIMA ERA DA p0 ->   MODIFCATO, ora è pt  medio!

            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){
                std::cout<<"p0 = "<<p0<< " , p1 = "<<p1<< std::endl;
                std::cout<<"pn = "<<pn<< " , pn_prova = "<<pn_prova<< " , level_set_function(pn,msh,cl) = "<<level_set_function(pn,msh,cl)<< " , level_set_function(pn_prova,msh,cl) = "<<level_set_function(pn_prova,msh,cl) <<std::endl;
                pn = pn_prova ;
            }

            if ( level_set_function(pn,msh,cl) >= iso_val_interface )
            {
                cl.user_data.p0 = p1;
                cl.user_data.p1 = p0;
            }
            else
            {
                cl.user_data.p0 = p0;
                cl.user_data.p1 = p1;
            }

            cl.user_data.interface.push_back(cl.user_data.p0);
            cl.user_data.interface.push_back(cl.user_data.p1);
        }

        if ( k != 0 && k != 2 ){
            auto pts = points(msh,cl);
            std::cout<<"Point[0] = "<<pts[0]<<" , point[1] = "<<pts[1]<<" , point[2] = "<<pts[2]<<" , point[3] = "<<pts[3]<<std::endl;
            std::cout<<"level_set_function(p0) = "<<level_set_function(pts[0],msh,cl) << " , level_set_function(p1) = "<<level_set_function(pts[1],msh,cl)<< " , level_set_function(p2) = "<<level_set_function(pts[2],msh,cl)<< " , level_set_function(p3) = "<<level_set_function(pts[3],msh,cl)<<std::endl;
            for (size_t i = 0; i < fcs.size(); i++)
            {
                if ( is_cut(msh, fcs[i]) )
                  std::cout<<"fcs[i].user_data.intersection_point = "<<fcs[i].user_data.intersection_point<<std::endl;
            }

            std::cout<<"ERROR: in cut cell "<<cell_i<<" there are k = "<<k<<" cuts!!!!"<<std::endl;
            throw std::logic_error(" --> Invalid number of cuts in cell");

        }

        cell_i++;
    }

#endif
}
*/
/// New version of refine_interface for discret level functions

template<typename T, size_t ET, typename Function>
void
refine_interface2(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,
                 const Function& level_set_function, size_t min, size_t max)
{
    if ( (max-min) < 2 )
        return;

    typedef typename cuthho_mesh<T, ET>::point_type     point_type;

    size_t mid = (max+min)/2;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0+p1)/2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;

    auto lm = level_set_function(pm,msh,cl);
    auto ls1 = level_set_function(ps1,msh,cl);
    auto ls2 = level_set_function(ps2,msh,cl);

    point_type ip;
   // std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if ( !((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold,msh,cl);
    }
    else if ( !((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold,msh,cl);
    }
    else
        throw std::logic_error("interface not found in search range");

    cl.user_data.interface.at(mid) = ip;

    refine_interface2(msh, cl, level_set_function, min, mid);
    refine_interface2(msh, cl, level_set_function, mid, max);
}

template<typename T, size_t ET, typename Function>
void
refine_interface2(cuthho_mesh<T, ET>& msh, const Function& level_set_function, size_t levels)
{
    if (levels == 0)
        return;

    size_t interface_points = iexp_pow(2, levels);

    for (auto& cl : msh.cells)
    {
        if ( !is_cut(msh, cl) )
            continue;


        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<"<--------------------"<<reset<<std::endl;
        cl.user_data.interface.resize(interface_points+1);
        cl.user_data.interface.at(0)                = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        refine_interface2(msh, cl, level_set_function, 0, interface_points);

        std::cout<<"LIMIT CELL "<<offset(msh,cl)<<" are:"<<std::endl;
         std::cout<<"pt[0] = "<<points(msh,cl)[0]<<" , pt[1] = "<<points(msh,cl)[1]<<" , pt[2] = "<<points(msh,cl)[2]<<" , pt[3] = "<<points(msh,cl)[3]<<std::endl;

         for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
             std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;
         std::cout<<"--------------------> CELL = "<<offset(msh,cl)<<"<--------------------"<<std::endl;
    }
}



template<typename T, size_t ET ,typename Function >
typename cuthho_mesh<T, ET>::point_type
search_boundary( cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl, typename cuthho_mesh<T, ET>::point_type& p_init ,T m , T q , T lm , const Function& level_set )
{
    typedef typename cuthho_mesh<T, ET>::point_type     point_type;
    auto pts = points(msh,cl);

    point_type pt_tmp0 = point_type( pts[0].x() , m* pts[0].x() + q ) ;
    point_type pt_tmp1 = point_type( pts[1].x() , m* pts[1].x() + q ) ;
    point_type pt_tmp2 = point_type( (pts[1].y()-q)/m , pts[1].y() ) ;
    point_type pt_tmp3 = point_type( (pts[2].y()-q)/m , pts[2].y() ) ;
    /*
    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )
    {
        std::cout<<yellow<<bold<<"search_boundary"<<reset<<std::endl;
        std::cout<<"pt_tmp0 = "<<pt_tmp0<<std::endl;
        std::cout<<"pt_tmp1 = "<<pt_tmp1<<std::endl;
        std::cout<<"pt_tmp2 = "<<pt_tmp2<<std::endl;
        std::cout<<"pt_tmp3 = "<<pt_tmp3<<std::endl;
    }
    */
    auto ls0 = level_set(pt_tmp0,msh,cl);
    auto ls1 = level_set(pt_tmp1,msh,cl);
    auto ls2 = level_set(pt_tmp2,msh,cl);
    auto ls3 = level_set(pt_tmp3,msh,cl);

    if ( pt_in_cell(msh , pt_tmp0 , cl) && ( !((lm >= 0 && ls0 >= 0) || (lm < 0 && ls0 < 0)) ) )
        return pt_tmp0 ;
    if ( pt_in_cell(msh , pt_tmp1 , cl) && ( !((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)) ) )
    return pt_tmp1 ;
    if ( pt_in_cell(msh , pt_tmp2 , cl) && ( !((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)) ) )
    return pt_tmp2 ;
    if ( pt_in_cell(msh , pt_tmp3 , cl) && ( !((lm >= 0 && ls3 >= 0) || (lm < 0 && ls3 < 0)) ) )
    return pt_tmp3 ;
    else{
        std::cout<<"In cell = "<<offset(msh,cl)<<" points(msh,cl)[0] = "<<points(msh,cl)[0]<<" points(msh,cl)[1] = "<<points(msh,cl)[1]<<" points(msh,cl)[2] = "<<points(msh,cl)[2]<<" points(msh,cl)[3] = "<<points(msh,cl)[3] <<std::endl;
        std::cout<<"m = "<<m<<" --> q = "<<q<<std::endl;
        std::cout<<"p_init = "<<p_init<<" --> pt_tmp0 = "<<pt_tmp0<<" , pt_tmp1 = "<<pt_tmp1<<" , pt_tmp2 = "<<pt_tmp2<<" , pt_tmp3 = "<<pt_tmp3<<std::endl;
        std::cout<<"ls0 = "<<ls0<<" , ls1 = "<<ls1<<" , ls2 = "<<ls2<<" , ls3 = "<<ls3<<" AND lm = "<<lm<<std::endl;
        std::cout<<"pt_in_cell( pt_tmp0 ) = "<<pt_in_cell(msh , pt_tmp0 , cl)<<" , pt_in_cell( pt_tmp1 ) = "<<pt_in_cell(msh , pt_tmp1 , cl)<<" , pt_in_cell( pt_tmp2 ) = "<<pt_in_cell(msh , pt_tmp2 , cl)<<" , pt_in_cel( pt_tmp3 ) = "<<pt_in_cell(msh , pt_tmp3 , cl)<<std::endl;
        T pp = pts[0].x();
        T dist = std::abs( pp - p_init.x() )/10.0;
        std::cout<<"DIST = "<<dist<< " and pp = "<<pp<< " and p_init.x() = "<<p_init.x() <<std::endl;
        point_type p0 = point_type( pp + dist , m* (pp-dist) + q ) ;
        point_type p1 = point_type( pp + (dist*2) , m* (pp+(dist*2)) + q ) ;
        point_type p2 = point_type( pp + (dist*3) , m* (pp+(dist*3)) + q ) ;
        point_type p3 = point_type( pp + (dist*4) , m* (pp+(dist*4)) + q ) ;
        point_type p4 = point_type( pp + (dist*5) , m* (pp+(dist*5)) + q ) ;
        point_type p5 = point_type( pp + (dist*6) , m* (pp+(dist*6)) + q ) ;
        point_type p6 = point_type( pp + (dist*7) , m* (pp+(dist*7)) + q ) ;
        point_type p7 = point_type( pp + (dist*8) , m* (pp+(dist*8)) + q ) ;
        point_type p8 = point_type( pp + (dist*9) , m* (pp+(dist*9)) + q ) ;
        std::cout<<"p0 = "<<p0<<" , level_set = "<<level_set(p0,msh,cl)<<" , p1 = "<<p1<<" , level_set = "<<level_set(p1,msh,cl)<<" , p2 = "<<p2<<" , level_set = "<<level_set(p2,msh,cl)<<" , p3 = "<<p3<<" , level_set = "<<level_set(p3,msh,cl)<<" ,p4 = "<<p4<<" , level_set = "<<level_set(p4,msh,cl)<<" ,p5 = "<<p5<<" , level_set = "<<level_set(p5,msh,cl)<<" , p6 = "<<p6<<" , level_set = "<<level_set(p6,msh,cl)<<", p7 = "<<p7<<" , level_set = "<<level_set(p7,msh,cl)<<" , p8 = "<<p8<<" , level_set = "<<level_set(p8,msh,cl)<<std::endl;

        //throw std::logic_error("search_boundary not find -> Stefano");
        //return p_init ;

        point_type ret ;
        T val_min = 1e10;
        if( pt_in_cell(msh , pt_tmp0 , cl) && std::abs(ls0) < val_min )
        {
            val_min = std::abs(ls0) ;
            ret = pt_tmp0 ;

        }
        if( pt_in_cell(msh , pt_tmp1 , cl) && std::abs(ls1) < val_min )
        {
            val_min = std::abs(ls1) ;
            ret = pt_tmp1 ;

        }
        if( pt_in_cell(msh , pt_tmp2 , cl) && std::abs(ls2) < val_min )
        {
            val_min = std::abs(ls2) ;
            ret = pt_tmp2 ;

        }
        if( pt_in_cell(msh , pt_tmp3 , cl) && std::abs(ls3) < val_min )
        {
            val_min = std::abs(ls3) ;
            ret = pt_tmp3 ;

        }
        return ret;

    }



}





template<typename T, size_t ET >
typename cuthho_mesh<T, ET>::point_type
search_boundary( cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl, typename cuthho_mesh<T, ET>::point_type& p_init ,T m , T q )
{
    typedef typename cuthho_mesh<T, ET>::point_type     point_type;
    auto pts =points(msh,cl);

    point_type pt_tmp0 = point_type( pts[0].x() , m* pts[0].x() + q ) ;
    point_type pt_tmp1 = point_type( pts[1].x() , m* pts[1].x() + q ) ;
    point_type pt_tmp2 = point_type( (pts[1].y()-q)/m , pts[1].y() ) ;
    point_type pt_tmp3 = point_type( (pts[2].y()-q)/m , pts[2].y() ) ;


    if( pt_in_cell(msh , pt_tmp0 , cl) && !(p_init == pt_tmp0) )
        return pt_tmp0 ;
    if( pt_in_cell(msh , pt_tmp1 , cl) && !(p_init == pt_tmp1) )
        return pt_tmp1 ;
    if( pt_in_cell(msh , pt_tmp2 , cl) && !(p_init == pt_tmp2) )
        return pt_tmp2 ;
    if( pt_in_cell(msh , pt_tmp3 , cl) && !(p_init == pt_tmp3) )
        return pt_tmp3 ;


}



template<typename T, size_t ET, typename Function>
void
refine_interface_pro(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,
                 const Function& level_set_function, size_t min, size_t max)
{
    if ( (max-min) < 2 )
        return;

    typedef typename cuthho_mesh<T, ET>::point_type     point_type;

    size_t mid = (max+min)/2;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0+p1)/2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm,msh,cl);
    auto ls1 = level_set_function(ps1,msh,cl);
    auto ls2 = level_set_function(ps2,msh,cl);

    // CASE  MAX PT on the boudary
    T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
    T q = pm.y() - m_half * pm.x() ;
    if( offset(msh,cl) == 119 )
    {
        std::cout<<yellow<<bold<<"CELL 119"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"ps1.y() = "<<ps1.y() << " , pm.y() = "<<pm.y()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
    }
    /*
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
    auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;
    auto lm_bdry = level_set_function( pt_bdry , msh , cl );
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
    //std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
    //std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
    //std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
   // std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if ( pt_in_cell(msh, ps1, cl) && ( !((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 1"<<std::endl;
    }
    else if ( pt_in_cell(msh, ps2, cl) && ( !((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 2"<<std::endl;
    }
    else if ( pt_in_cell(msh, pt_bdry, cl) && ( !((lm >= 0 && lm_bdry >= 0) || (lm < 0 && lm_bdry < 0)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell(pm, pt_bdry , level_set_function, threshold,msh,cl);
        //std::cout<<"BDRY NEW"<<std::endl;
    }
    else
    {
        //throw std::logic_error("interface not found in search range");
        //std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
        //ip = pm;
        std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND."<<reset<<std::endl;
        point_type ret ;
        T val_min = 1e10;
        if( pt_in_cell(msh , ps1 , cl) && std::abs(ls1) < val_min )
        {
            val_min = std::abs(ls1) ;
            ret = ps1 ;
            std::cout<<"ps1 = "<<ps1 << " , ls1 = "<< ls1 <<std::endl;

        }
        if( pt_in_cell(msh , ps2 , cl) && std::abs(ls2) < val_min )
        {
            val_min = std::abs(ls2) ;
            ret = ps2 ;
            std::cout<<"ps2 = "<<ps2 << " , ls2 = "<< ls2 <<std::endl;
        }
        if( pt_in_cell(msh , pt_bdry , cl) && std::abs(lm_bdry) < val_min )
        {
            val_min = std::abs(lm_bdry) ;
            ret = pt_bdry ;
            std::cout<<"ppt_bdrys1 = "<<pt_bdry << " , lm_bdry = "<<lm_bdry<<std::endl;
        }
        if( pt_in_cell(msh , pm , cl) && std::abs(lm) < val_min )
        {
            val_min = std::abs(lm) ;
            ret = pm ;
            std::cout<<"pm = "<<ps1 << " , lm = "<<ls1<<std::endl;
        }
        std::cout<<"ret = "<<ret << std::endl;
        ip = ret;

    }
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
    cl.user_data.interface.at(mid) = ip;

    refine_interface_pro(msh, cl, level_set_function, min, mid);
    refine_interface_pro(msh, cl, level_set_function, mid, max);
}

template<typename T, size_t ET, typename Function>
void
refine_interface_pro(cuthho_mesh<T, ET>& msh, const Function& level_set_function, size_t levels)
{
    if (levels == 0)
        return;



    size_t interface_points = iexp_pow(2, levels);

    for (auto& cl : msh.cells)
    {
        if ( !is_cut(msh, cl) )
            continue;

        /*
        if( offset(msh,cl) == 118 )
        {
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                std::cout<<"NEGATIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            else{
                std::cout<<"POSITIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }
        std::cout<<"INTERFACE_0 = "<<cl.user_data.p0 << " , INTERFACE_1 = "<<cl.user_data.p1 << std::endl;
        }
        */
        cl.user_data.interface.resize(interface_points+1);
        cl.user_data.interface.at(0)                = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        refine_interface_pro(msh, cl, level_set_function, 0, interface_points);
        /*
        if( offset(msh,cl) == 118 )
        {
        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;

        std::cout<<"--------------------> FINE CELL <--------------------"<<std::endl;
        }
        */
    }
}

template<typename T, size_t ET ,typename Function >
typename cuthho_mesh<T, ET>::point_type
search_boundary3( cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl, typename cuthho_mesh<T, ET>::point_type& p_init ,T m , T q , T lm , const Function& level_set , T iso_val_interface )
{
    typedef typename cuthho_mesh<T, ET>::point_type     point_type;
    auto pts = points(msh,cl);

    point_type pt_tmp0 = point_type( pts[0].x() , m* pts[0].x() + q ) ;
    point_type pt_tmp1 = point_type( pts[1].x() , m* pts[1].x() + q ) ;
    point_type pt_tmp2 = point_type( (pts[1].y()-q)/m , pts[1].y() ) ;
    point_type pt_tmp3 = point_type( (pts[2].y()-q)/m , pts[2].y() ) ;
    /*
    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )
    {
        std::cout<<yellow<<bold<<"search_boundary"<<reset<<std::endl;
        std::cout<<"pt_tmp0 = "<<pt_tmp0<<std::endl;
        std::cout<<"pt_tmp1 = "<<pt_tmp1<<std::endl;
        std::cout<<"pt_tmp2 = "<<pt_tmp2<<std::endl;
        std::cout<<"pt_tmp3 = "<<pt_tmp3<<std::endl;
    }
    */
    auto ls0 = level_set(pt_tmp0,msh,cl);
    auto ls1 = level_set(pt_tmp1,msh,cl);
    auto ls2 = level_set(pt_tmp2,msh,cl);
    auto ls3 = level_set(pt_tmp3,msh,cl);

    if ( pt_in_cell(msh , pt_tmp0 , cl) && ( !((lm >= iso_val_interface && ls0 >= iso_val_interface) || (lm < iso_val_interface && ls0 < iso_val_interface)) ) )
        return pt_tmp0 ;
    if ( pt_in_cell(msh , pt_tmp1 , cl) && ( !((lm >= iso_val_interface && ls1 >= iso_val_interface) || (lm < iso_val_interface && ls1 < iso_val_interface)) ) )
    return pt_tmp1 ;
    if ( pt_in_cell(msh , pt_tmp2 , cl) && ( !((lm >= iso_val_interface && ls2 >= iso_val_interface) || (lm < iso_val_interface && ls2 < iso_val_interface)) ) )
    return pt_tmp2 ;
    if ( pt_in_cell(msh , pt_tmp3 , cl) && ( !((lm >= iso_val_interface && ls3 >= iso_val_interface) || (lm < iso_val_interface && ls3 < iso_val_interface)) ) )
    return pt_tmp3 ;
    else{
        std::cout<<"In cell = "<<offset(msh,cl)<<" points(msh,cl)[0] = "<<points(msh,cl)[0]<<" points(msh,cl)[1] = "<<points(msh,cl)[1]<<" points(msh,cl)[2] = "<<points(msh,cl)[2]<<" points(msh,cl)[3] = "<<points(msh,cl)[3] <<std::endl;
        std::cout<<"m = "<<m<<" --> q = "<<q<<std::endl;
        std::cout<<"p_init = "<<p_init<<" --> pt_tmp0 = "<<pt_tmp0<<" , pt_tmp1 = "<<pt_tmp1<<" , pt_tmp2 = "<<pt_tmp2<<" , pt_tmp3 = "<<pt_tmp3<<std::endl;
        std::cout<<"ls0 = "<<ls0<<" , ls1 = "<<ls1<<" , ls2 = "<<ls2<<" , ls3 = "<<ls3<<" AND lm = "<<lm<<std::endl;
        std::cout<<"pt_in_cell( pt_tmp0 ) = "<<pt_in_cell(msh , pt_tmp0 , cl)<<" , pt_in_cell( pt_tmp1 ) = "<<pt_in_cell(msh , pt_tmp1 , cl)<<" , pt_in_cell( pt_tmp2 ) = "<<pt_in_cell(msh , pt_tmp2 , cl)<<" , pt_in_cel( pt_tmp3 ) = "<<pt_in_cell(msh , pt_tmp3 , cl)<<std::endl;
        T pp = pts[0].x();
        T dist = std::abs( pp - p_init.x() )/10.0;
        std::cout<<"DIST = "<<dist<< " and pp = "<<pp<< " and p_init.x() = "<<p_init.x() <<std::endl;
        point_type p0 = point_type( pp + dist , m* (pp-dist) + q ) ;
        point_type p1 = point_type( pp + (dist*2) , m* (pp+(dist*2)) + q ) ;
        point_type p2 = point_type( pp + (dist*3) , m* (pp+(dist*3)) + q ) ;
        point_type p3 = point_type( pp + (dist*4) , m* (pp+(dist*4)) + q ) ;
        point_type p4 = point_type( pp + (dist*5) , m* (pp+(dist*5)) + q ) ;
        point_type p5 = point_type( pp + (dist*6) , m* (pp+(dist*6)) + q ) ;
        point_type p6 = point_type( pp + (dist*7) , m* (pp+(dist*7)) + q ) ;
        point_type p7 = point_type( pp + (dist*8) , m* (pp+(dist*8)) + q ) ;
        point_type p8 = point_type( pp + (dist*9) , m* (pp+(dist*9)) + q ) ;
        std::cout<<"p0 = "<<p0<<" , level_set = "<<level_set(p0,msh,cl)<<" , p1 = "<<p1<<" , level_set = "<<level_set(p1,msh,cl)<<" , p2 = "<<p2<<" , level_set = "<<level_set(p2,msh,cl)<<" , p3 = "<<p3<<" , level_set = "<<level_set(p3,msh,cl)<<" ,p4 = "<<p4<<" , level_set = "<<level_set(p4,msh,cl)<<" ,p5 = "<<p5<<" , level_set = "<<level_set(p5,msh,cl)<<" , p6 = "<<p6<<" , level_set = "<<level_set(p6,msh,cl)<<", p7 = "<<p7<<" , level_set = "<<level_set(p7,msh,cl)<<" , p8 = "<<p8<<" , level_set = "<<level_set(p8,msh,cl)<<std::endl;

        //throw std::logic_error("search_boundary not find -> Stefano");
        //return p_init ;

        point_type ret ;
        T val_min = 1e10;
        if( pt_in_cell(msh , pt_tmp0 , cl) && std::abs(ls0-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls0) ;
            ret = pt_tmp0 ;

        }
        if( pt_in_cell(msh , pt_tmp1 , cl) && std::abs(ls1-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls1) ;
            ret = pt_tmp1 ;

        }
        if( pt_in_cell(msh , pt_tmp2 , cl) && std::abs(ls2-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls2) ;
            ret = pt_tmp2 ;

        }
        if( pt_in_cell(msh , pt_tmp3 , cl) && std::abs(ls3-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls3) ;
            ret = pt_tmp3 ;

        }
        return ret;

    }



}


// USING INTERFACE = 1/2
template<typename T, size_t ET, typename Function>
void
refine_interface_pro3(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,
                 const Function& level_set_function, size_t min, size_t max)
{
    if ( (max-min) < 2 )
        return;

    typedef typename cuthho_mesh<T, ET>::point_type     point_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
    size_t mid = (max+min)/2;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0+p1)/2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm,msh,cl);
    auto ls1 = level_set_function(ps1,msh,cl);
    auto ls2 = level_set_function(ps2,msh,cl);

    // CASE  MAX PT on the boudary
    T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
    T q = pm.y() - m_half * pm.x() ;
    /*
    if( offset(msh,cl) == 119 )
    {
        std::cout<<yellow<<bold<<"CELL 119"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"ps1.y() = "<<ps1.y() << " , pm.y() = "<<pm.y()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
        std::cout<<"ps1.x() = "<<ps1.x() << " , pm.x() = "<<pm.x()<<std::endl;
    }
    
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
    auto pt_bdry = search_boundary3( msh , cl , pm , m_half , q , lm , level_set_function , iso_val_interface) ;
    auto lm_bdry = level_set_function( pt_bdry , msh , cl );
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
    //std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
    //std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
    //std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
   // std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if ( pt_in_cell(msh, ps1, cl) && ( !((lm >= iso_val_interface && ls1 >= iso_val_interface) || (lm < iso_val_interface && ls1 < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 1"<<std::endl;
    }
    else if ( pt_in_cell(msh, ps2, cl) && ( !((lm >= iso_val_interface && ls2 >= iso_val_interface) || (lm < iso_val_interface && ls2 < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 2"<<std::endl;
    }
    else if ( pt_in_cell(msh, pt_bdry, cl) && ( !((lm >= iso_val_interface && lm_bdry >= iso_val_interface) || (lm < iso_val_interface && lm_bdry < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, pt_bdry , level_set_function, threshold,msh,cl);
        //std::cout<<"BDRY NEW"<<std::endl;
    }
    else
    {
        //throw std::logic_error("interface not found in search range");
        //std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
        //ip = pm;
        std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND."<<reset<<std::endl;
        point_type ret ;
        T val_min = 1e10;
        if( pt_in_cell(msh , ps1 , cl) && std::abs(ls1-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls1) ;
            ret = ps1 ;
            std::cout<<"ps1 = "<<ps1 << " , ls1 = "<< ls1 <<std::endl;

        }
        if( pt_in_cell(msh , ps2 , cl) && std::abs(ls2-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls2) ;
            ret = ps2 ;
            std::cout<<"ps2 = "<<ps2 << " , ls2 = "<< ls2 <<std::endl;
        }
        if( pt_in_cell(msh , pt_bdry , cl) && std::abs(lm_bdry-iso_val_interface) < val_min )
        {
            val_min = std::abs(lm_bdry) ;
            ret = pt_bdry ;
            std::cout<<"ppt_bdrys1 = "<<pt_bdry << " , lm_bdry = "<<lm_bdry<<std::endl;
        }
        if( pt_in_cell(msh , pm , cl) && std::abs(lm-iso_val_interface) < val_min )
        {
            val_min = std::abs(lm) ;
            ret = pm ;
            std::cout<<"pm = "<<ps1 << " , lm = "<<ls1<<std::endl;
        }
        std::cout<<"ret = "<<ret << std::endl;
        ip = ret;

    }
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
    cl.user_data.interface.at(mid) = ip;

    refine_interface_pro3(msh, cl, level_set_function, min, mid);
    refine_interface_pro3(msh, cl, level_set_function, mid, max);
}



template<typename T, size_t ET, typename Function>
void
refine_interface_pro3(cuthho_mesh<T, ET>& msh, const Function& level_set_function, size_t levels)
{
    if (levels == 0)
        return;



    size_t interface_points = iexp_pow(2, levels);

    for (auto& cl : msh.cells)
    {
        if ( !is_cut(msh, cl) )
            continue;

        /*
        if( offset(msh,cl) == 118 )
        {
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                std::cout<<"NEGATIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            else{
                std::cout<<"POSITIVE -> nd = "<<nd.ptid << " --> pt = "<<points(msh,cl)[counter] << std::endl;
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }
        std::cout<<"INTERFACE_0 = "<<cl.user_data.p0 << " , INTERFACE_1 = "<<cl.user_data.p1 << std::endl;
        }
        */
        cl.user_data.interface.resize(interface_points+1);
        cl.user_data.interface.at(0)                = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        refine_interface_pro3(msh, cl, level_set_function, 0, interface_points);
        /*
        if( offset(msh,cl) == 118 )
        {
        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;

        std::cout<<"--------------------> FINE CELL <--------------------"<<std::endl;
        }
        */
    }
}


template<typename T, size_t ET, typename Function, typename ITERATOR>
void
refine_interface_pro3_disp(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,
                 const Function& level_set_function, ITERATOR first_pt, ITERATOR second_pt, int & counter ,int counter_fin , int curve_degree, T& fraz )
{
    
    if ( (counter_fin-counter) == 1 )
        return;
   
    typedef typename cuthho_mesh<T, ET>::point_type     point_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
   
    auto p0 = *first_pt;
    auto p1 = *second_pt;
    
    auto pm = p0 + fraz*(p1-p0) ;
    
    //std::cout<<"first_pt = "<<*first_pt<<" ,  second_pt = "<< *second_pt<< " , pm = "<<pm<<" , fraz = "<<fraz<<std::endl;
    fraz += 1.0/curve_degree;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm,msh,cl);
    auto ls1 = level_set_function(ps1,msh,cl);
    auto ls2 = level_set_function(ps2,msh,cl);

    // CASE  MAX PT on the boudary
    T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
    T q = pm.y() - m_half * pm.x() ;
   
    
    auto pt_bdry = search_boundary3( msh , cl , pm , m_half , q , lm , level_set_function , iso_val_interface) ;
    auto lm_bdry = level_set_function( pt_bdry , msh , cl );
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
    //std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
    //std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
    //std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
   // std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if ( pt_in_cell(msh, ps1, cl) && ( !((lm >= iso_val_interface && ls1 >= iso_val_interface) || (lm < iso_val_interface && ls1 < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 1"<<std::endl;
    }
    else if ( pt_in_cell(msh, ps2, cl) && ( !((lm >= iso_val_interface && ls2 >= iso_val_interface) || (lm < iso_val_interface && ls2 < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 2"<<std::endl;
    }
    else if ( pt_in_cell(msh, pt_bdry, cl) && ( !((lm >= iso_val_interface && lm_bdry >= iso_val_interface) || (lm < iso_val_interface && lm_bdry < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, pt_bdry , level_set_function, threshold,msh,cl);
        //std::cout<<"BDRY NEW"<<std::endl;
    }
    else
    {
        //throw std::logic_error("interface not found in search range");
        //std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
        //ip = pm;
        std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND."<<reset<<std::endl;
        point_type ret ;
        T val_min = 1e10;
        if( pt_in_cell(msh , ps1 , cl) && std::abs(ls1-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls1) ;
            ret = ps1 ;
            std::cout<<"ps1 = "<<ps1 << " , ls1 = "<< ls1 <<std::endl;

        }
        if( pt_in_cell(msh , ps2 , cl) && std::abs(ls2-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls2) ;
            ret = ps2 ;
            std::cout<<"ps2 = "<<ps2 << " , ls2 = "<< ls2 <<std::endl;
        }
        if( pt_in_cell(msh , pt_bdry , cl) && std::abs(lm_bdry-iso_val_interface) < val_min )
        {
            val_min = std::abs(lm_bdry) ;
            ret = pt_bdry ;
            std::cout<<"ppt_bdrys1 = "<<pt_bdry << " , lm_bdry = "<<lm_bdry<<std::endl;
        }
        if( pt_in_cell(msh , pm , cl) && std::abs(lm-iso_val_interface) < val_min )
        {
            val_min = std::abs(lm) ;
            ret = pm ;
            std::cout<<"pm = "<<ps1 << " , lm = "<<ls1<<std::endl;
        }
        std::cout<<"ret = "<<ret << std::endl;
        ip = ret;

    }
    counter++;
    cl.user_data.interface.at(counter) = ip;
    
    refine_interface_pro3_disp(msh, cl, level_set_function,first_pt, second_pt, counter,counter_fin,curve_degree,fraz);
}

template<typename T, size_t ET, typename Function>
void
refine_interface_pro3_disp_subcell(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,const Function& level_set_function, std::vector<point<T,2>>& interface_tmp , size_t min, size_t max)
{
     if ( (max-min) < 2 )
        return;

    typedef typename cuthho_mesh<T, ET>::point_type     point_type;
    T iso_val_interface = level_set_function.iso_val_interface ;
    size_t mid = (max+min)/2;
    auto p0 = interface_tmp.at(min);
    auto p1 = interface_tmp.at(max);
    auto pm = (p0+p1)/2.0;
    auto pt = p1 - p0;
    auto pn = point_type(-pt.y(), pt.x());
    auto ps1 = pm + pn;
    auto ps2 = pm - pn;


    auto lm = level_set_function(pm,msh,cl);
    auto ls1 = level_set_function(ps1,msh,cl);
    auto ls2 = level_set_function(ps2,msh,cl);

    // CASE  MAX PT on the boudary
    T m_half = ( ps1.y() - pm.y() )/( ps1.x() - pm.x() );
    T q = pm.y() - m_half * pm.x() ;
   
    /*
    if( offset(msh,cl) == 118 )
    {
        T m_half_bis = ( ps2.y() - pm.y() )/( ps2.x() - pm.x() );
        T q_bis = pm.y() - m_half * pm.x() ;
        std::cout<<yellow<<bold<<"CELL 118"<<reset<<std::endl;
        std::cout<<"p0 = "<<p0 << " , p1 = "<<p1<<std::endl;
        std::cout<<"m_half = "<<m_half << " , m_half_bis = "<<m_half_bis<<std::endl;
        std::cout<<"q = "<<q << " , q_bis = "<<q_bis<<std::endl;

        std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
        std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
        std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;
    }
    */
    auto pt_bdry = search_boundary3( msh , cl , pm , m_half , q , lm , level_set_function , iso_val_interface) ;
    auto lm_bdry = level_set_function( pt_bdry , msh , cl );
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"pt_bdry = "<<pt_bdry << " , level_set_function(lm_bdry) = "<<lm_bdry<<std::endl;
    */
    //std::cout<<"pm = "<<pm << " , level_set_function(pm) = "<<lm<<std::endl;
    //std::cout<<"ps1 = "<<ps1 << " , level_set_function(ps1) = "<<ls1<<std::endl;
    //std::cout<<"ps2 = "<<ps2 << " , level_set_function(ps2) = "<<ls2<<std::endl;


    point_type ip;
   // std::cout<<"the node of interface are "<<p0<<" and "<<p1<<". I search pm= "<<pm<<" in which phi = "<<lm<<" and ps1 e ps2 "<<ps1<<" and "<<ps2<<"equal to "<<ls1<<" , "<<ls2<<std::endl;
    if ( pt_in_cell(msh, ps1, cl) && ( !((lm >= iso_val_interface && ls1 >= iso_val_interface) || (lm < iso_val_interface && ls1 < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 1"<<std::endl;
    }
    else if ( pt_in_cell(msh, ps2, cl) && ( !((lm >= iso_val_interface && ls2 >= iso_val_interface) || (lm < iso_val_interface && ls2 < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold,msh,cl);
        //std::cout<<"OLD 2"<<std::endl;
    }
    else if ( pt_in_cell(msh, pt_bdry, cl) && ( !((lm >= iso_val_interface && lm_bdry >= iso_val_interface) || (lm < iso_val_interface && lm_bdry < iso_val_interface)) ) )
    {
        auto threshold = diameter(msh, cl) / 1e20;
        //auto threshold = diameter(msh, cl) / 1e10;
        ip = find_zero_crossing_in_cell3(pm, pt_bdry , level_set_function, threshold,msh,cl);
        //std::cout<<"BDRY NEW"<<std::endl;
    }
    else
    {
        //throw std::logic_error("interface not found in search range");
        //std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing linear approximation. INTERFACE NOT FOUND."<<reset<<std::endl;
        //ip = pm;
        std::cout<<yellow<<bold<< "In cell "<<offset(msh,cl)<<" ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND."<<reset<<std::endl;
        point_type ret ;
        T val_min = 1e10;
        if( pt_in_cell(msh , ps1 , cl) && std::abs(ls1-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls1) ;
            ret = ps1 ;
            std::cout<<"ps1 = "<<ps1 << " , ls1 = "<< ls1 <<std::endl;

        }
        if( pt_in_cell(msh , ps2 , cl) && std::abs(ls2-iso_val_interface) < val_min )
        {
            val_min = std::abs(ls2) ;
            ret = ps2 ;
            std::cout<<"ps2 = "<<ps2 << " , ls2 = "<< ls2 <<std::endl;
        }
        if( pt_in_cell(msh , pt_bdry , cl) && std::abs(lm_bdry-iso_val_interface) < val_min )
        {
            val_min = std::abs(lm_bdry) ;
            ret = pt_bdry ;
            std::cout<<"ppt_bdrys1 = "<<pt_bdry << " , lm_bdry = "<<lm_bdry<<std::endl;
        }
        if( pt_in_cell(msh , pm , cl) && std::abs(lm-iso_val_interface) < val_min )
        {
            val_min = std::abs(lm) ;
            ret = pm ;
            std::cout<<"pm = "<<ps1 << " , lm = "<<ls1<<std::endl;
        }
        std::cout<<"ret = "<<ret << std::endl;
        ip = ret;

    }
    /*
    if( offset(msh,cl) == 118 )
        std::cout<<"POINT INTERFACE Ip = "<<ip <<  " in pos = "<<mid<<std::endl;
    */
    interface_tmp.at(mid) = ip;
    
    refine_interface_pro3_disp_subcell(msh, cl, level_set_function,interface_tmp, min, mid);
    refine_interface_pro3_disp_subcell(msh, cl, level_set_function,interface_tmp, mid, max);
}

template<typename T, size_t ET, typename Function>
void
refine_interface_pro3_curve_para(cuthho_mesh<T, ET>& msh, const Function& level_set_function, size_t levels, size_t degree_curve)
{
    
    size_t interface_points;
    
    if (levels == 0 && degree_curve == 1)
        return;

    //if (levels == 0 && degree_curve % 2 == 0 )
     //   interface_points = degree_curve+1 ;

    interface_points = iexp_pow(2, levels)*degree_curve;

    for (auto& cl : msh.cells)
    {
        if ( !is_cut(msh, cl) )
            continue;

        
        cl.user_data.interface.resize(interface_points+1);
        cl.user_data.interface.at(0)                = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;
        if(degree_curve % 2 == 0)
            refine_interface_pro3(msh, cl, level_set_function, 0, interface_points);
        else{
            //std::cout<<"--> Attention it works just for P3!!! "<<std::endl;
            size_t num_subcl = iexp_pow(2, levels);
            std::vector<point<T,2>> interface_tmp(num_subcl+1);
            interface_tmp.at(0)                = cl.user_data.p0;
            interface_tmp.at(num_subcl) = cl.user_data.p1;
            if( levels > 0)
            {
                refine_interface_pro3_disp_subcell(msh, cl, level_set_function,interface_tmp, 0, num_subcl);
            }
            int counter = 0;
            //std::cout<<"cl.user_data.p0 = "<<cl.user_data.p0<<" ,  cl.user_data.p1 = "<< cl.user_data.p1<<std::endl;
            //std::cout<<"interface_tmp[0] = "<<interface_tmp[0]<<" , interface_tmp[1] = "<< interface_tmp[1]<<" , interface_tmp[2] = "<< interface_tmp[2]<<std::endl;
            for(auto first_pt=interface_tmp.begin(); first_pt<interface_tmp.end()-1; first_pt++){
                auto second_pt = first_pt+1;
                int counter_fin = counter+degree_curve;
                T fraz = 1.0/degree_curve;
                //std::cout<<"first_pt = "<<*first_pt<<" ,  second_pt = "<< *second_pt<<std::endl;
                refine_interface_pro3_disp(msh, cl, level_set_function,first_pt,second_pt, counter,counter_fin,degree_curve,fraz);
                
                counter++;
                if(counter<interface_points )
                    cl.user_data.interface.at(counter) = *second_pt;
            }
        }
    }
}

template<typename T, size_t ET, typename Function >
void
refine_interface_angle(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,
                 const Function& level_set_function, size_t min, size_t max , typename cuthho_mesh<T, ET>::point_type& p_init , T h , bool pos , int multiplicity , T angle0 , T angle1 )
{
    if ( (max-min) < 2 )
        return;

    typedef typename cuthho_mesh<T, ET>::point_type     point_type;



    T angle_half = ( angle0 + angle1)/2.0;
    T m_half = tan(angle_half);

    std::cout<<bold<<yellow<<"CHECK ANGLE --------> "<< reset <<"angle0 = "<<angle0 * 180 / M_PI << " , angle1 = "<<angle1 * 180 / M_PI <<" and angle_half = "<<angle_half * 180 / M_PI <<std::endl;

    /*
    // In the case h is not long enough!
    T h_max = 0.0;
    if(multiplicity > 1  )
    {
        T cateto_min = 2*m_half/h ;
        h_max = std::max( h , sqrt( pow(cateto_min,2) + pow(h,2)/4.0 ) );
    }
    */

    // CASE h:
    T val = sqrt( pow(h,2)/( 1+pow(m_half,2) ) ) ;

    T x_new0 = p_init.x() + val ;
    T y_new0 = p_init.y() + ( x_new0 - p_init.x() )*m_half ;
    point_type pt_half0 = point_type(x_new0 , y_new0) ;

    auto lm0 = level_set_function( pt_half0 , msh , cl );

    T x_new1 = p_init.x() - val ;
    T y_new1 = p_init.y() + ( x_new1 - p_init.x() )*m_half ;
    point_type pt_half1 = point_type(x_new1,y_new1) ;

    auto lm1 = level_set_function(pt_half1,msh,cl);




    // CASE h_max = h*sqrt(2)
    T h_max = h*sqrt(2.0) ;
    T val_max = sqrt( pow(h_max,2)/( 1+pow(m_half,2) ) ) ;
    T x_new_max0 = p_init.x() + val_max ;
    T y_new_max0 = p_init.y() + ( x_new_max0 - p_init.x() )*m_half ;
    T x_new_max1 = p_init.x() - val_max ;
    T y_new_max1 = p_init.y() + ( x_new_max1 - p_init.x() )*m_half ;


    point_type pt_half_max0 = point_type(x_new_max0,y_new_max0) ;
    point_type pt_half_max1 = point_type(x_new_max1,y_new_max1) ;

    auto lm_max0 = level_set_function(pt_half_max0,msh,cl);
    auto lm_max1 = level_set_function(pt_half_max1,msh,cl);

    // CASE h_min = h/2
    T h_min = h/2.0 ;
    T val_min = sqrt( pow(h_min,2)/( 1+pow(m_half,2) ) ) ;
    T x_new_min0 = p_init.x() + val_min ;
    T y_new_min0 = p_init.y() + ( x_new_min0 - p_init.x() )*m_half ;
    T x_new_min1 = p_init.x() - val_min ;
    T y_new_min1 = p_init.y() + ( x_new_min1 - p_init.x() )*m_half ;


    point_type pt_half_min0 = point_type(x_new_min0,y_new_min0) ;
    point_type pt_half_min1 = point_type(x_new_min1,y_new_min1) ;

    auto lm_min0 = level_set_function(pt_half_min0,msh,cl);
    auto lm_min1 = level_set_function(pt_half_min1,msh,cl);



    // CASE PT on the boudary
    T q = p_init.y() - m_half * p_init.x() ;

    auto pt_bdry = search_boundary( msh , cl , p_init , m_half , q ) ;
    auto lm_bdry = level_set_function(pt_bdry,msh,cl);





    size_t mid = (max+min)/2;
    point_type ip;
    auto p0 = cl.user_data.interface.at(min);
    auto p1 = cl.user_data.interface.at(max);
    auto pm = (p0+p1)/2.0;
    //std::cout<<"p_init = "<<p_init<< " level_set(p_init) = "<<level_set_function(p_init,msh,cl)<<std::endl;


    if ( pt_in_cell(msh, pt_half0, cl) && !((lm0 >= 0 && pos == TRUE) || (lm0 < 0 && pos == FALSE ) ) )
    {

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half0, level_set_function, threshold,msh,cl);
        std::cout<<"NORMAL + --> pt_half0 = "<<pt_half0<< " and lm0 = "<<lm0<<" ------> ip = "<<ip<<std::endl;
    }
    else if ( pt_in_cell(msh, pt_half1, cl) && !((lm1 >= 0 && pos == TRUE) || (lm1 < 0 && pos == FALSE )) )
    {

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half1, level_set_function, threshold,msh,cl);
        std::cout<<"NORMAL - --> pt_half1 = "<<pt_half1<< " and lm1 = "<<lm1<<" ------> ip = "<<ip<<std::endl;

    }
    else if ( pt_in_cell(msh, pt_bdry, cl) && !((lm_bdry >= 0 && pos == TRUE) || (lm_bdry < 0 && pos == FALSE )) )
    {
        //std::cout<<"CHECK IF MIN POINT (WITH -) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_bdry, level_set_function, threshold,msh,cl);
        std::cout<<"BDRY - --> pt_bdry = "<<pt_bdry<< " and lm_bdry = "<<lm_bdry<<" --> ip = "<<ip<<std::endl;

    }

    else if ( pt_in_cell(msh, pt_half_max0, cl) && !((lm_max0 >= 0 && pos == TRUE) || (lm_max0 < 0 && pos == FALSE )) )
    {
        //std::cout<<"CHECK IF MAX POINT (WITH +) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_max0, level_set_function, threshold,msh,cl);
        std::cout<<"MAX + --> pt_max0 = "<<pt_half_max0<< " and lm_max0 = "<<lm_max0<<" --> ip = "<<ip<<std::endl;

    }
    else if ( pt_in_cell(msh, pt_half_max1, cl) && !((lm_max1 >= 0 && pos == TRUE) || (lm_max1 < 0 && pos == FALSE )) )
    {
        //std::cout<<"CHECK IF MAX POINT (WITH -) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_max1, level_set_function, threshold,msh,cl);
        std::cout<<"MAX - --> pt_max1 = "<<pt_half_max1<< " and lm_max1 = "<<lm_max1<<" --> ip = "<<ip<<std::endl;

    }
    else if ( pt_in_cell(msh, pt_half_min0, cl) && !((lm_min0 >= 0 && pos == TRUE) || (lm_min0 < 0 && pos == FALSE )) )
    {
        //std::cout<<"CHECK IF MIN POINT (WITH +) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_min0, level_set_function, threshold,msh,cl);
        std::cout<<"MIN + --> pt_min0 = "<<pt_half_min0<< " and lm_min0 = "<<lm_min0<<" --> ip = "<<ip<<std::endl;

    }
    else if ( pt_in_cell(msh, pt_half_min1, cl) && !((lm_min1 >= 0 && pos == TRUE) || (lm_min1 < 0 && pos == FALSE )) )
    {
        //std::cout<<"CHECK IF MIN POINT (WITH -) IS IN CELL"<<std::endl;

        auto threshold = diameter(msh, cl) / 1e20;
        ip = find_zero_crossing_in_cell(p_init, pt_half_min1, level_set_function, threshold,msh,cl);
        std::cout<<"MIN - --> pt_min1 = "<<pt_half_min1<< " and lm_min1 = "<<lm_min1<<" --> ip = "<<ip<<std::endl;

    }

    else
    {
        // IN THE CASE I DON'T FIND THE POINT I CONSIDER IT LINEAR

         std::cout<<"-----> ATTENTION: INTERFACE_REFINE3-> POINT DID NOT FIND, LINEAR APPROXIMATION EMPLOYED!"<<std::endl;
        std::cout<<"p_init = "<<p_init<< " level_set(p_init) = "<<level_set_function(p_init,msh,cl)<<std::endl;
        std::cout<<"CASE + : pt_half0 = "<<pt_half0<< " and lm0 = "<<lm0<<std::endl;
         std::cout<<"CASE - : pt_half1 = "<<pt_half1<< " and lm1 = "<<lm1<<std::endl;
        std::cout<<"CASE MAX+: pt_half_max0 = "<<pt_half_max0<< " and lm_max0 = "<<lm_max0<<std::endl;
        std::cout<<"CASE MAX-: pt_half_max1 = "<<pt_half_max1<< " and lm_max1 = "<<lm_max1<<std::endl;
        std::cout<<"CASE MIN +: pt_half_min0 = "<<pt_half_min0<< " and lm_min0 = "<<lm_min0<<std::endl;
        std::cout<<"CASE MIN -: pt_half_min1 = "<<pt_half_min1<< " and lm_min1 = "<<lm_min1<<std::endl;
        std::cout<<"CASE BDRY: pt_bdry = "<<pt_bdry<< " and lm_bdry = "<<lm_bdry<<std::endl;
        std::cout<<"--> ip = pm =  "<< pm <<std::endl;
        std::cout<<"ATTENTION: INTERFACE_REFINE3-> POINT DID NOT FIND, LINEAR APPROXIMATION EMPLOYED! <-------"<<std::endl;
        ip = pm ;
    }


    cl.user_data.interface.at(mid) = ip;

    refine_interface_angle( msh, cl, level_set_function, min , mid , p_init, h , pos, multiplicity , angle0 , angle_half );
    refine_interface_angle( msh, cl, level_set_function, mid , max , p_init , h , pos, multiplicity , angle_half , angle1 );
}






template<typename T, size_t ET, typename Function>
void
refine_interface_angle2(cuthho_mesh<T, ET>& msh, const Function& level_set_function, size_t levels)
{
    if (levels == 0)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    size_t interface_points = iexp_pow(2, levels);

    for (auto& cl : msh.cells)
    {
        if ( !is_cut(msh, cl) )
            continue;

        cl.user_data.interface.resize(interface_points+1);
        cl.user_data.interface.at(0)                = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;

        // ADDED BY STEFANO
        point_type pos0 = cl.user_data.p0;
        point_type pos1 = cl.user_data.p1;
        std::vector< point_type >  pos_point;
        std::vector< point_type >  neg_point;

        bool positive = TRUE;
        int multiplicity = 1;
        std::vector<size_t> position_neg , position_pos ;
        T angle0 , angle1 ;
        point_type pm ;

        size_t counter = 0;
        for (auto& pt : points(msh,cl) )
        {
            if ( level_set_function(pt , msh , cl ) < 0 ){
                neg_point.push_back(pt);
                position_neg.push_back( counter );
            }
            else{
                pos_point.push_back(pt);
                position_pos.push_back( counter );
            }
            counter++;
        }

        /// FIND  EXTREME  ANGLES
        if( neg_point.size() == 1 ){
            pm = neg_point[0] ;
            positive = FALSE ;
            if(position_neg[0] == 0){
                angle0 = 0.0*M_PI;
                angle1 = M_PI/2.0 ;
            }
            else if(position_neg[0] == 1){
                angle0 = M_PI/2.0 ;
                angle1 = M_PI ;
            }
            else if(position_neg[0] == 2){
                angle0 = M_PI ;
                angle1 = 3.0*M_PI/2.0 ;
            }
            else if(position_neg[0] == 3){
                angle0 = 3.0*M_PI/2.0 ;
                angle1 = 0.0*M_PI ;
            }
            else{
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        }
        else if( pos_point.size() == 1 ){
            pm = pos_point[0] ;
            if(position_pos[0] == 0){
                angle0 = 0.0*M_PI;
                angle1 = M_PI/2.0 ;
            }
            else if(position_pos[0] == 1){
                angle0 = M_PI/2.0 ;
                angle1 = M_PI ;
            }
            else if(position_pos[0] == 2){
                angle0 = M_PI ;
                angle1 = 3.0*M_PI/2.0 ;
            }
            else if(position_pos[0] == 3){
                angle0 = 3.0*M_PI/2.0 ;
                angle1 = 0.0*M_PI ;
            }
            else{
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }

        }
        else
        {
            // MULTIPLICITY 2 -> #pos_point = #neg_point = 2
            if(position_pos[0] == 0 && position_pos[1] == 1){
                pm = (pos_point[0] +pos_point[1] )/2.0;
                multiplicity = 2 ;
                angle0 = atan( (pos0.y() - pm.y()) / (pos0.x() - pm.x()) );
                angle1 = atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );
                if(angle0 < 0 )
                    angle0 += M_PI ;
                else
                    angle1 += M_PI ;
            }
            else if(position_pos[0] == 1 && position_pos[1] == 2){
                pm = (pos_point[0] +pos_point[1] )/2.0;
                multiplicity = 2 ;
                angle0 = M_PI + atan( (pos0.y()-pm.y()) / (pos0.x()-pm.x()) );
                angle1 = M_PI + atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );

            }
            else if(position_pos[0] == 2 && position_pos[1] == 3){

                pm = (pos_point[0] +pos_point[1] )/2.0;
                multiplicity = 2 ;
                angle0 = atan( (pos0.y() - pm.y()) / (pos0.x() - pm.x()) );
                angle1 = atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );
                if(angle0 > 0 )
                    angle0 += M_PI ;
                else
                    angle1 += M_PI ;

            }
            else if(position_pos[0] == 0 && position_pos[1] == 3){

                pm = (pos_point[0] +pos_point[1] )/2.0;
                multiplicity = 2 ;
                angle0 = atan( (pos0.y() - pm.y()) / (pos0.x() - pm.x()) );
                angle1 = atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );

            }
            else if(position_pos[0] == 0 && position_pos[1] == 2){
                positive = FALSE ;
                pm = points(msh,cl)[1];
                //multiplicity = 2 ;
                angle0 = M_PI/2.0 ;
                angle1 = M_PI ;

            }
            else if(position_pos[0] == 1 && position_pos[1] == 3){
                positive = FALSE ;
                pm = points(msh,cl)[0];
                //multiplicity = 2 ;
                angle0 = 0.0*M_PI ;
                angle1 = M_PI/2.0 ;

            }
            else{
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        }


        if(angle0 > angle1 )
        {
            T tmp = angle1 ;
            angle1 = angle0 ;
            angle0 = tmp ;
        }
        std::cout<<"angle0 = "<<angle0<< " and angle1 = "<<angle1<<std::endl;


        auto checK_sign = level_set_function(pm,msh,cl);


        if( !(signbit(checK_sign) && !positive) || !(!signbit(checK_sign) && positive) )
        {
            std::cout<<"LEVEL SET(Pm) = "<<checK_sign<< " and sign used is = "<<positive<<std::endl;
            throw std::logic_error("HO FATTO ERRORE IN POSITIVE SIGN CHECKING");
        }


        T h = std::min(level_set_function.params.hx() , level_set_function.params.hy() );


        refine_interface_angle( msh, cl, level_set_function, 0 , interface_points , pm , h , positive, multiplicity , angle0 , angle1 );
    }

}

template<typename T, size_t ET, typename Function>
void
refine_interface_angle(cuthho_mesh<T, ET>& msh, const Function& level_set_function, size_t levels)
{
    if (levels == 0)
        return;

    typedef typename cuthho_mesh<T, ET>::point_type point_type;
    //typedef typename cuthho_mesh<T, ET>::node_type node_type;
    size_t interface_points = iexp_pow(2, levels);

    for (auto& cl : msh.cells)
    {
        if ( !is_cut(msh, cl) )
            continue;

        cl.user_data.interface.resize(interface_points+1);
        cl.user_data.interface.at(0)                = cl.user_data.p0;
        cl.user_data.interface.at(interface_points) = cl.user_data.p1;
        std::cout<<yellow<<bold<<"--------------------> CELL = "<<offset(msh,cl)<<" <--------------------"<<reset<<std::endl;
        // ADDED BY STEFANO
        point_type pos0 = cl.user_data.p0;
        point_type pos1 = cl.user_data.p1;

        bool positive = TRUE;
        int multiplicity = 1;
        std::vector<size_t> position_neg , position_pos ;
        T angle0 , angle1 ;
        point_type pm ;

        size_t counter = 0;
        for (auto& nd :  nodes(msh,cl) )
        {

            if( nd.user_data.location == element_location::IN_NEGATIVE_SIDE ){
                position_neg.push_back( counter );
            }
            else{

                position_pos.push_back( counter );
            }
            counter++;
            //std::cout<<"nd = "<<nd.ptid<<std::endl;
        }

        /// FIND  EXTREME  ANGLES
        if( position_neg.size() == 1 )
        {

            pm = points(msh,cl)[position_neg[0]] ;
            std::cout<<"POINT"<<pm<<" , position_neg = "<<position_neg[0]<<std::endl;
            positive = FALSE ;
            if(position_neg[0] == 0){
                angle0 = 0.0*M_PI;
                angle1 = M_PI/2.0 ;
            }
            else if(position_neg[0] == 1){
                angle0 = M_PI/2.0 ;
                angle1 = M_PI ;
            }
            else if(position_neg[0] == 2){
                angle0 = M_PI ;
                angle1 = 3.0*M_PI/2.0 ;
            }
            else if(position_neg[0] == 3){
                angle0 = 3.0*M_PI/2.0 ;
                angle1 = 2.0*M_PI ;
            }
            else{
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        }
        else if( position_pos.size() == 1 )
        {
            std::cout<<yellow<<bold<<"CASO POSITIVO MA TOGLIEREI E METTEREI SOLO CASI NEGATIVI!!!"<<reset<<std::endl;
            pm = points(msh,cl)[position_pos[0] ] ;
            std::cout<<"POINT"<<pm<<" , position_pos = "<<position_pos[0]<<std::endl;
            if(position_pos[0] == 0){
                angle0 = 0.0*M_PI;
                angle1 = M_PI/2.0 ;
            }
            else if(position_pos[0] == 1){
                angle0 = M_PI/2.0 ;
                angle1 = M_PI ;
            }
            else if(position_pos[0] == 2){
                angle0 = M_PI ;
                angle1 = 3.0*M_PI/2.0 ;
            }
            else if(position_pos[0] == 3){
                angle0 = 3.0*M_PI/2.0 ;
                angle1 = 2.0*M_PI ;
            }
            else{
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }

        }
        else
        {
            //std::cout<<"sono qua 4 NEW"<<std::endl;
            //if(plus_close(p0,))
            // MULTIPLICITY 2 -> #pos_point = #neg_point = 2
            if(position_neg[0] == 0 && position_neg[1] == 1){
                positive = FALSE ;
                pm = (points(msh,cl)[position_neg[0] ] + points(msh,cl)[position_neg[1] ] )/2.0 ;
                std::cout<<"POINT "<<pm<<" , position_neg[0][1] --> "<<position_neg[0]<<" , "<<position_neg[1]<<std::endl;
                multiplicity = 2 ;
                angle0 = atan( (pos0.y() - pm.y()) / (pos0.x() - pm.x()) );
                angle1 = atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );
                if(angle0 < 0 )
                    angle0 += M_PI ;
                else
                    angle1 += M_PI ;
            }
            else if(position_neg[0] == 1 && position_neg[1] == 2){
                positive = FALSE ;
                pm = (points(msh,cl)[position_neg[0] ] + points(msh,cl)[position_neg[1] ] )/2.0 ;
                std::cout<<"POINT "<<pm<<" , position_neg[0][1] --> "<<position_neg[0]<<" , "<<position_neg[1]<<std::endl;
                multiplicity = 2 ;
                angle0 = M_PI + atan( (pos0.y()-pm.y()) / (pos0.x()-pm.x()) );
                angle1 = M_PI + atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );

            }
            else if(position_neg[0] == 2 && position_neg[1] == 3){
                positive = FALSE ;
                pm = (points(msh,cl)[position_neg[0] ] + points(msh,cl)[position_neg[1] ] )/2.0 ;
                std::cout<<"POINT "<<pm<<" , position_neg[0][1] --> "<<position_neg[0]<<" , "<<position_neg[1]<<std::endl;
                multiplicity = 2 ;
                angle0 = atan( (pos0.y() - pm.y()) / (pos0.x() - pm.x()) );
                angle1 = atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );
                if(angle0 > 0 )
                    angle0 += M_PI ;
                else
                    angle1 += M_PI ;

                if(angle0 < 0 )
                    angle0 = 2.0*M_PI + angle0 ;
                else
                    angle1 = 2.0*M_PI + angle1 ;

            }
            else if(position_neg[0] == 0 && position_neg[1] == 3){
                positive = FALSE ;
                pm = (points(msh,cl)[position_neg[0] ] + points(msh,cl)[position_neg[1] ] )/2.0 ;
                std::cout<<"POINT "<<pm<<" , position_neg[0][1] --> "<<position_neg[0]<<" , "<<position_neg[1]<<std::endl;
                multiplicity = 2 ;
                angle0 = atan( (pos0.y() - pm.y()) / (pos0.x() - pm.x()) );
                angle1 = atan( (pos1.y()-pm.y()) / (pos1.x()-pm.x()) );

            }
            else if(position_neg[0] == 0 && position_neg[1] == 2){
                //positive = FALSE ;
                pm = points(msh,cl)[1];
                std::cout<<"POINT "<<pm<<" , position_neg[0][1] --> "<<position_neg[0]<<" , "<<position_neg[1]<<std::endl;
                //multiplicity = 2 ;
                angle0 = M_PI/2.0 ;
                angle1 = M_PI ;

            }
            else if(position_neg[0] == 1 && position_neg[1] == 3){
                //positive = FALSE ;
                pm = points(msh,cl)[0];
                std::cout<<"POINT "<<pm<<" , position_neg[0][1] --> "<<position_neg[0]<<" , "<<position_neg[1]<<std::endl;
                //multiplicity = 2 ;
                angle0 = 0.0*M_PI ;
                angle1 = M_PI/2.0 ;

            }
            else{
                throw std::logic_error("POSITION ANGLE REFINE INTERFACE WRONG");
            }
        }


        if(angle0 > angle1 )
        {
            T tmp = angle1 ;
            angle1 = angle0 ;
            angle0 = tmp ;
        }
        //std::cout<<"CHECK ANGLE --------> angle0 = "<<angle0<< " and angle1 = "<<angle1<<std::endl;


        auto checK_sign = level_set_function(pm,msh,cl);

        if( (positive==FALSE && signbit(checK_sign) == 0 ) || (positive==TRUE && signbit(checK_sign) == 1 ) )
        {
            std::cout<<"LEVEL SET(Pm) = "<<checK_sign<< " and sign used is = "<<positive<<" and signbit is "<<signbit(checK_sign)<<std::endl;
            throw std::logic_error("HO FATTO ERRORE IN POSITIVE SIGN CHECKING");
        }


        T h = std::min(level_set_function.params.hx() , level_set_function.params.hy() );




        refine_interface_angle( msh, cl, level_set_function, 0 , interface_points , pm , h , positive, multiplicity , angle0 , angle1 );


        std::cout<<"LIMIT CELL "<<offset(msh,cl)<<" are:"<<std::endl;
        std::cout<<"pt[0] = "<<points(msh,cl)[0]<<" , pt[1] = "<<points(msh,cl)[1]<<" , pt[2] = "<<points(msh,cl)[2]<<" , pt[3] = "<<points(msh,cl)[3]<<std::endl;

        for(size_t i_int = 0 ; i_int < interface_points + 1 ; i_int++ )
            std::cout<<"refined points are p = "<<cl.user_data.interface.at(i_int)<<std::endl;
        std::cout<<"--------------------> CELL = "<<offset(msh,cl)<<"<--------------------"<<std::endl;
    }

}



/*****************************************************************************
 *   Test stuff ADDED by StePicca
 *****************************************************************************/

//template<typename T, typename Mesh>
//std::vector<size_t>
//subcell_finder<T,Mesh>(const Mesh& , const point<T,2>& , const typename Mesh::cell_type& , const mesh_init_params<T>&);

template<typename T, typename Mesh>
bool
pt_in_cell(const Mesh& msh, const point<T,2>& , const typename Mesh::cell_type& );

template<typename T,typename Mesh>
std::vector< point<T,2> >
equidistriduted_nodes(const Mesh& , const typename Mesh::cell_type& , size_t );

template<typename T,typename Mesh>
std::vector< point<T,2> >
equidistriduted_nodes_subcell(const Mesh& ,
          const typename Mesh::cell_type& ,
                              size_t , const std::vector<size_t>& ) ;


template<typename T>
std::vector<point<T,1> >
reference_nodes(size_t );

template< typename FonctionD , typename Mesh , typename FonctionA >
void
testing_level_set(const Mesh msh , const FonctionD& ,  const FonctionA& );

template< typename FonctionD , typename Mesh >
void
test_new_method(const Mesh , const FonctionD&  , const typename Mesh::cell_type & );


// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh , typename FonctionA >
void
gradient_checking1(const Mesh msh , const FonctionD& level_set_disc , const FonctionA& level_set_anal , const typename Mesh::cell_type & cl)
{
    //typedef typename Mesh::point_type       point_type;

    double derD1x , derD1y , derAx , derAy , derD2x , derD2y ;
    Eigen::Matrix<double,2,1> derD1 ,derD2 , derA;
    point<double,2> node;


    auto pts = points(msh,cl);
    for(auto & node:pts)
    {
        derD1 = level_set_disc.gradient(node);
        derD2 = level_set_disc.gradient(node,msh,cl);
        derA = level_set_anal.gradient(node);

            derD1x = derD1(0);
            derD1y = derD1(1);
            derD2x = derD2(0);
            derD2y = derD2(1);
            derAx = derA(0);
            derAy = derA(1);


        /*
            if((derD1x-derD2x)>1e-2)
            {
            std::cout<<"Differnce between two x-evaluation system "<<(derD1x-derD2x)<<std::endl;
            }
        */

        if((derAx-derD2x)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW X-evaluation system "<<(derAx-derD2x)<<std::endl;
        }

        if((derAx-derD1x)>1e-2)
        {
            std::cout<<"Differnce between analytic and OLD X-evaluation system "<<(derAx-derD1x)<<std::endl;
        }


        /*
        if((derD1y-derD2y)>1e-2)
        {
            std::cout<<"Differnce between two y-evaluation system "<<(derD1y-derD2y)<<std::endl;
        }
         */


        if((derAy-derD2y)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW Y-evaluation system "<<(derAy-derD2y)<<std::endl;
        }

        if((derAy-derD1y)>1e-2)
        {
            std::cout<<"Differnce between analytic and OLD Y-evaluation system "<<(derAy-derD1y)<<std::endl;
        }


    }



}

// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh , typename FonctionA >
void
gradient_checking(const Mesh msh , const FonctionD& level_set_disc , const FonctionA& level_set_anal , const typename Mesh::cell_type & cl)
{
    //typedef typename Mesh::point_type       point_type;

    double derD1x , derD1y , derAx , derAy ; // , derD2x , derD2y ;
    Eigen::Matrix<double,2,1> derD1 ,derD2 , derA;
    point<double,2> node;

    auto pts = points(msh,cl);
    for(auto & node:pts)
    {
        derD1 = level_set_disc.gradient(node);
       // derD2 = level_set_disc.gradient(node,msh,cl);
        derA = level_set_anal.gradient(node);

            derD1x = derD1(0);
            derD1y = derD1(1);
         //   derD2x = derD2(0);
         //   derD2y = derD2(1);
            derAx = derA(0);
            derAy = derA(1);


        /*
            if((derD1x-derD2x)>1e-2)
            {
            std::cout<<"Differnce between two x-evaluation system "<<(derD1x-derD2x)<<std::endl;
            }
        */
        /*
        if((derAx-derD2x)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW X-evaluation system "<<(derAx-derD2x)<<std::endl;
        }
        */
        if((derAx-derD1x)>1e-2)
        {
            std::cout<<"Differnce between analytic and OLD X-evaluation system "<<(derAx-derD1x)<<std::endl;
        }


        /*
        if((derD1y-derD2y)>1e-2)
        {
            std::cout<<"Differnce between two y-evaluation system "<<(derD1y-derD2y)<<std::endl;
        }
         */

        /*
        if((derAy-derD2y)>1e-2)
        {
            std::cout<<"Differnce between analytic and NEW Y-evaluation system "<<(derAy-derD2y)<<std::endl;
        }
        */
        if((derAy-derD1y)>1e-2)
        {
            std::cout<<"Differnce between analytic and OLD Y-evaluation system "<<(derAy-derD1y)<<std::endl;
        }


    }



}




template< typename FonctionD , typename Mesh , typename FonctionA >
void
testing_velocity(const Mesh msh , const FonctionD& vel_disc , const FonctionA& vel_anal)
{
    //typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;

    Eigen::Matrix<double,2,1> valueA;
    point<double,2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_discx  = std::make_shared< gnuplot_output_object<double> >("vel_discX.dat");
    auto test_analx = std::make_shared< gnuplot_output_object<double> >("vel_analX.dat");
    auto test_discy  = std::make_shared< gnuplot_output_object<double> >("vel_discY.dat");
    auto test_analy = std::make_shared< gnuplot_output_object<double> >("vel_analY.dat");

    for(auto& cl:msh.cells)
    {
        auto pts = points(msh,cl);
        for(auto&pt : pts)
        {
            auto valueD = vel_disc(pt,msh,cl);
            valueA = vel_anal(pt);

            test_discx->add_data(pt,valueD.first);
            test_discy->add_data(pt,valueD.second);
            test_analx->add_data(pt,valueA(0));
            test_analy->add_data(pt,valueA(1));


        }
    }

    postoutput1.add_object(test_discx);
    postoutput1.add_object(test_analx);
    postoutput1.add_object(test_discy);
    postoutput1.add_object(test_analy);


    postoutput1.write();

}





template< typename T >
void
plotting_in_time_complete(const std::vector<T>& time_vec , const std::vector<T>& area_time ,const std::vector<T>& l1_err_u_n_time ,const std::vector<T>& linf_err_u_n_time ,const std::vector<T>& max_val_u_n_time ,const std::vector<T>& l1_err_curvature_time ,const std::vector<T>& linf_err_curvature_time , T dt , const std::vector<std::pair<T,T>>& min_max_vec , const std::vector<T>& flux_interface_time , const std::vector<std::pair<T,T>>& rise_velocity_time , const std::vector<std::pair<T,T>>& centre_mass_err_time , const std::vector<T>& perimeter_time , const std::vector<T>& circularity_time , T circularity_ref , T perimetre_ref , T area_ref , T radius )
{

    postprocess_output<T> postoutput;

    auto testref0  = std::make_shared< gnuplot_output_object_time<T> >("area_ref_time.dat");
    auto testref1  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_ref_time.dat");
    auto testref2  = std::make_shared< gnuplot_output_object_time<T> >("circularity_ref_time.dat");

    T area_analytic = M_PI*radius*radius ;
    T perimeter_analytic = 2.0*M_PI*radius ;
    auto testanal0  = std::make_shared< gnuplot_output_object_time<T> >("area_anal_time.dat");
    auto testanal1  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_anal_time.dat");


    auto test0  = std::make_shared< gnuplot_output_object_time<T> >("area_time.dat");
    auto test1  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_u_n_time.dat");
    auto test2  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_u_n_time.dat");
    auto test3  = std::make_shared< gnuplot_output_object_time<T> >("max_val_u_n_time.dat");
    auto test4  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_curvature_time.dat");
    auto test5  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_curvature_time.dat");

    auto test0b  = std::make_shared< gnuplot_output_object_time<T> >("area_time_normalised.dat");

    auto test1b  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_u_n_time_normalised.dat");
    auto test2b  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_u_n_time_normalised.dat");
    auto test3b  = std::make_shared< gnuplot_output_object_time<T> >("max_val_u_n_time_normalised.dat");
    auto test4b  = std::make_shared< gnuplot_output_object_time<T> >("l1_err_curvature_time_normalised.dat");
    auto test5b  = std::make_shared< gnuplot_output_object_time<T> >("linf_err_curvature_time_normalised.dat");
    //auto test4c  = std::make_shared< gnuplot_output_object_time<T> >("l1_l1_err_curvature_err_time.dat");

    auto test_dt  = std::make_shared< gnuplot_output_object_time<T> >("dt_M.dat");

    auto test0c  = std::make_shared< gnuplot_output_object_time<T> >("area_time_err.dat");

    auto testm0  = std::make_shared< gnuplot_output_object_time<T> >("min_time.dat");
    auto testm1  = std::make_shared< gnuplot_output_object_time<T> >("min_normalised_time.dat");
    auto testM0  = std::make_shared< gnuplot_output_object_time<T> >("max_time.dat");
    auto testM1  = std::make_shared< gnuplot_output_object_time<T> >("max_normalised_time.dat");
    auto testflux  = std::make_shared< gnuplot_output_object_time<T> >("flux_interface_time.dat");
    auto testvelx  = std::make_shared< gnuplot_output_object_time<T> >("rise_velocity_err_x_time.dat");
    auto testvely  = std::make_shared< gnuplot_output_object_time<T> >("rise_velocity_err_y_time.dat");
    auto testvel  = std::make_shared< gnuplot_output_object_time<T> >("rise_velocity_err_time.dat");
    auto testcomx  = std::make_shared< gnuplot_output_object_time<T> >("centre_mass_err_x_time.dat");
    auto testcomy  = std::make_shared< gnuplot_output_object_time<T> >("centre_mass_err_y_time.dat");
    auto testcom  = std::make_shared< gnuplot_output_object_time<T> >("centre_mass_err_time.dat");


    auto testper0  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_time.dat");
    auto testper1  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_normalised_time.dat");
    auto testper2  = std::make_shared< gnuplot_output_object_time<T> >("perimeter_err_time.dat");

    auto testcirc  = std::make_shared< gnuplot_output_object_time<T> >("circularity_time.dat");
    auto testcirc1  = std::make_shared< gnuplot_output_object_time<T> >("circularity_error_time.dat");

    size_t tot = l1_err_u_n_time.size() ;

    testm0->add_data(time_vec[0] ,min_max_vec[0].first );
    testm1->add_data(time_vec[0] ,1.0 );
    testM0->add_data(time_vec[0] ,min_max_vec[0].second );
    testM1->add_data(time_vec[0] ,1.0 );

    testcomx->add_data(time_vec[0] , 0.0 );
    testcomy->add_data(time_vec[0] , 0.0 );
    testcom->add_data(time_vec[0] , 0.0 );


    testper0->add_data(time_vec[0] ,perimeter_time[0] );
    testper1->add_data(time_vec[0] , 1.0 );
    testper2->add_data(time_vec[0] , std::abs(perimeter_time[0] - perimetre_ref)/perimetre_ref );

    testcirc->add_data(time_vec[0] , circularity_time[0] );
    testcirc1->add_data(time_vec[0] , std::abs(circularity_time[0] - circularity_ref)/circularity_ref );

    test0c->add_data(time_vec[0] , 0.0 );
    //test4c->add_data(time_vec[0] , 0.0 );


    test0->add_data(time_vec[0] ,area_time[0] );
    test4->add_data(time_vec[0] ,l1_err_curvature_time[0] );
    test5->add_data(time_vec[0] ,linf_err_curvature_time[0] );

    test0b->add_data(time_vec[0] ,area_time[0]/area_time[0] );
    test4b->add_data(time_vec[0] ,l1_err_curvature_time[0]/l1_err_curvature_time[0]  );
    test5b->add_data(time_vec[0] ,linf_err_curvature_time[0]/linf_err_curvature_time[0]  );

    testref0->add_data(time_vec[0] , area_ref );
    testref1->add_data(time_vec[0] , perimetre_ref );
    testref2->add_data(time_vec[0] , circularity_ref );

    testanal0->add_data(time_vec[0] , area_analytic );
    testanal1->add_data(time_vec[0] , perimeter_analytic );

    for(size_t i = 0; i< tot; i++ )
    {
        test0->add_data(time_vec[i+1] ,area_time[i+1] );
        test1->add_data(time_vec[i+1] ,l1_err_u_n_time[i] );
        test2->add_data(time_vec[i+1] ,linf_err_u_n_time[i] );
        test3->add_data(time_vec[i+1] ,max_val_u_n_time[i] );
        test4->add_data(time_vec[i+1] ,l1_err_curvature_time[i+1] );
        test5->add_data(time_vec[i+1] ,linf_err_curvature_time[i+1] );

        test0b->add_data(time_vec[i+1] ,area_time[i+1]/area_time[0] );
        test1b->add_data(time_vec[i+1] ,l1_err_u_n_time[i]/l1_err_u_n_time[0] );
        test2b->add_data(time_vec[i+1] ,linf_err_u_n_time[i]/linf_err_u_n_time[0] );
        test3b->add_data(time_vec[i+1] ,max_val_u_n_time[i]/max_val_u_n_time[0]  );
        test4b->add_data(time_vec[i+1] ,l1_err_curvature_time[i+1]/l1_err_curvature_time[0] );
        test5b->add_data(time_vec[i+1] ,linf_err_curvature_time[i+1]/linf_err_curvature_time[0]  );



        testcomx->add_data(time_vec[i+1] , std::abs(centre_mass_err_time[i+1].first - centre_mass_err_time[0].first ) / centre_mass_err_time[0].first );
        testcomy->add_data(time_vec[i+1] ,std::abs(centre_mass_err_time[i+1].second - centre_mass_err_time[0].second ) / centre_mass_err_time[0].second  );
        testcom->add_data(time_vec[i+1] ,std::abs(centre_mass_err_time[i+1].first - centre_mass_err_time[0].first ) / centre_mass_err_time[0].first  + std::abs(centre_mass_err_time[i+1].second - centre_mass_err_time[0].second ) / centre_mass_err_time[0].second  );


        testm0->add_data(time_vec[i+1] , min_max_vec[i+1].first );
        testm1->add_data(time_vec[i+1] ,min_max_vec[i+1].first/min_max_vec[0].first );
        testM0->add_data(time_vec[i+1] , min_max_vec[i+1].second );
        testM1->add_data(time_vec[i+1] ,min_max_vec[i+1].second/min_max_vec[0].second );


        testper0->add_data(time_vec[i+1] , perimeter_time[i+1] );
        testper1->add_data(time_vec[i+1] , perimeter_time[i+1]/perimeter_time[0] );
        testper2->add_data(time_vec[i+1] , std::abs( perimeter_time[i+1] - perimetre_ref) / perimetre_ref );

        testcirc->add_data(time_vec[i+1] , circularity_time[i+1] );
        testcirc1->add_data(time_vec[i+1] , std::abs(circularity_time[i+1] - circularity_ref)/circularity_ref );

        test0c->add_data(time_vec[i+1] , std::abs(area_time[i+1] - area_time[0] )/area_time[0]);
        //test4c->add_data(time_vec[i+1] , std::abs(l1_err_curvature_time[i+1] - l1_err_curvature_time[0] )/l1_err_curvature_time[0]);

        testflux ->add_data(time_vec[i+1] , flux_interface_time[i] );
        testvelx ->add_data(time_vec[i+1] , std::abs(rise_velocity_time[i].first) );
        testvely ->add_data(time_vec[i+1] , std::abs(rise_velocity_time[i].second) );
        testvel  ->add_data(time_vec[i+1] , std::abs(rise_velocity_time[i].first) + std::abs(rise_velocity_time[i].second) );

        testref0->add_data(time_vec[i+1] , area_ref );
        testref1->add_data(time_vec[i+1] , perimetre_ref );
        testref2->add_data(time_vec[i+1] , circularity_ref );

        testanal0->add_data(time_vec[i+1] , area_analytic );
        testanal1->add_data(time_vec[i+1] , perimeter_analytic );

        //std::cout<<"time_vec[i] = "<<time_vec[i]<<", time_vec[i+1] = "<<time_vec[i+1]<<", dt = "<<dt<<", error = "<<std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt )<<std::endl;
        if( std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt ) > 1e-10 ){
            test_dt->add_data(time_vec[i] , 0.0 );
            test_dt->add_data(time_vec[i+1] , 0.0 );
        }
    }


    postoutput.add_object(test0);
    postoutput.add_object(test1);
    postoutput.add_object(test2);
    postoutput.add_object(test3);
    postoutput.add_object(test4);
    postoutput.add_object(test5);
    postoutput.add_object(test0b);
    postoutput.add_object(test1b);
    postoutput.add_object(test2b);
    postoutput.add_object(test3b);
    postoutput.add_object(test4b);
    postoutput.add_object(test5b);

    postoutput.add_object(testcomx);
    postoutput.add_object(testcomy);
    postoutput.add_object(testcom);

    postoutput.add_object(testm0);
    postoutput.add_object(testm1);
    postoutput.add_object(testM0);
    postoutput.add_object(testM1);

    postoutput.add_object(testper0);
    postoutput.add_object(testper1);
    postoutput.add_object(testper2);

    postoutput.add_object(testcirc);
    postoutput.add_object(testcirc1);

    postoutput.add_object(test0c);
    //postoutput.add_object(test4c);

    postoutput.add_object(testflux);
    postoutput.add_object(testvelx);
    postoutput.add_object(testvely);
    postoutput.add_object(testvel);

    postoutput.add_object(testref0);
    postoutput.add_object(testref1);
    postoutput.add_object(testref2);

    postoutput.add_object(testanal0);
    postoutput.add_object(testanal1);


    postoutput.add_object(test_dt);

    postoutput.write();

}





template< typename T >
void
plotting_in_time(const std::vector<T>& time_vec , const std::vector<T>& area_time ,const std::vector<T>& l1_err_u_n_time ,const std::vector<T>& linf_err_u_n_time ,const std::vector<T>& max_val_u_n_time ,const std::vector<T>& l1_err_curvature_time ,const std::vector<T>& linf_err_curvature_time , T dt )
{

    postprocess_output<T> postoutput;

    auto test0  = std::make_shared< gnuplot_output_object_time<double> >("area_time.dat");
    auto test1  = std::make_shared< gnuplot_output_object_time<double> >("l1_err_u_n_time.dat");
    auto test2  = std::make_shared< gnuplot_output_object_time<double> >("linf_err_u_n_time.dat");
    auto test3  = std::make_shared< gnuplot_output_object_time<double> >("max_val_u_n_time.dat");
    auto test4  = std::make_shared< gnuplot_output_object_time<double> >("l1_err_curvature_time.dat");
    auto test5  = std::make_shared< gnuplot_output_object_time<double> >("linf_err_curvature_time.dat");

    auto test0b  = std::make_shared< gnuplot_output_object_time<double> >("area_time_normalised.dat");
    auto test1b  = std::make_shared< gnuplot_output_object_time<double> >("l1_err_u_n_time_normalised.dat");
    auto test2b  = std::make_shared< gnuplot_output_object_time<double> >("linf_err_u_n_time_normalised.dat");
    auto test3b  = std::make_shared< gnuplot_output_object_time<double> >("max_val_u_n_time_normalised.dat");
    auto test4b  = std::make_shared< gnuplot_output_object_time<double> >("l1_err_curvature_time_normalised.dat");
    auto test5b  = std::make_shared< gnuplot_output_object_time<double> >("linf_err_curvature_time_normalised.dat");

    auto test_dt  = std::make_shared< gnuplot_output_object_time<double> >("dt_M.dat");


    size_t tot = l1_err_u_n_time.size() ;
    test0->add_data(time_vec[0] ,area_time[0] );
    test4->add_data(time_vec[0] ,l1_err_curvature_time[0] );
    test5->add_data(time_vec[0] ,linf_err_curvature_time[0] );

    test0b->add_data(time_vec[0] ,area_time[0]/area_time[0] );
    test4b->add_data(time_vec[0] ,l1_err_curvature_time[0]/l1_err_curvature_time[0]  );
    test5b->add_data(time_vec[0] ,linf_err_curvature_time[0]/linf_err_curvature_time[0]  );

    for(size_t i = 0; i< tot; i++ )
    {
        test0->add_data(time_vec[i+1] ,area_time[i+1] );
        test1->add_data(time_vec[i+1] ,l1_err_u_n_time[i] );
        test2->add_data(time_vec[i+1] ,linf_err_u_n_time[i] );
        test3->add_data(time_vec[i+1] ,max_val_u_n_time[i] );
        test4->add_data(time_vec[i+1] ,l1_err_curvature_time[i+1] );
        test5->add_data(time_vec[i+1] ,linf_err_curvature_time[i+1] );

        test0b->add_data(time_vec[i+1] ,area_time[i+1]/area_time[0] );
        test1b->add_data(time_vec[i+1] ,l1_err_u_n_time[i]/l1_err_u_n_time[0] );
        test2b->add_data(time_vec[i+1] ,linf_err_u_n_time[i]/linf_err_u_n_time[0] );
        test3b->add_data(time_vec[i+1] ,max_val_u_n_time[i]/max_val_u_n_time[0]  );
        test4b->add_data(time_vec[i+1] ,l1_err_curvature_time[i+1]/l1_err_curvature_time[0] );
        test5b->add_data(time_vec[i+1] ,linf_err_curvature_time[i+1]/linf_err_curvature_time[0]  );

        //std::cout<<"time_vec[i] = "<<time_vec[i]<<", time_vec[i+1] = "<<time_vec[i+1]<<", dt = "<<dt<<", error = "<<std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt )<<std::endl;
        if( std::abs( std::abs( time_vec[i+1] - time_vec[i] ) - dt ) > 1e-10 ){
            test_dt->add_data(time_vec[i] , 0.0 );
            test_dt->add_data(time_vec[i+1] , 0.0 );
        }
    }


    postoutput.add_object(test0);
    postoutput.add_object(test1);
    postoutput.add_object(test2);
    postoutput.add_object(test3);
    postoutput.add_object(test4);
    postoutput.add_object(test5);
    postoutput.add_object(test0b);
    postoutput.add_object(test1b);
    postoutput.add_object(test2b);
    postoutput.add_object(test3b);
    postoutput.add_object(test4b);
    postoutput.add_object(test5b);

    postoutput.add_object(test_dt);

    postoutput.write();

}

template< typename FonctionD , typename Mesh  >
void
testing_level_set(const Mesh& msh , const FonctionD& level_set_disc )
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , derDx , derDy ;
    Eigen::Matrix<double,2,1> derD ;
    point<double,2> node;
    size_t N, M;
    
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_disc.dat");


    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");

    auto test_profile_disc  = std::make_shared< gnuplot_output_object<double> >("test_profile_disc.dat");

    for(auto& cl : msh.cells)
    {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();
        for(size_t i = 0 ; i<= N ; i++ )
        {
            double px = pt0_x + i*( (pt1_x - pt0_x)/N);
            for (size_t j = 0 ; j<= M ; j++ )
            {
                
                double py = pt0_y + j*( (pt1_y - pt0_y)/M);
                node = point_type(px,py);
                valueD = level_set_disc(node,msh,cl);
                derD = level_set_disc.gradient(node,msh,cl);



                

                derDx = derD(0);
                derDy = derD(1);


                test_disc->add_data(node,valueD);

                test_disc_gradX->add_data(node,derDx);
                test_disc_gradY->add_data(node,derDy);


            }
            
            node = point_type(px,0.5);
            valueD = level_set_disc(node,msh,cl);
            test_profile_disc->add_data(node,valueD);

            

        }
    }
    postoutput1.add_object(test_disc);


    postoutput1.add_object(test_disc_gradX);

    postoutput1.add_object(test_disc_gradY);

    postoutput1.add_object(test_profile_disc);


    postoutput1.write();

}



template< typename FonctionD , typename Mesh , typename FonctionA >
void
testing_level_set(const Mesh msh , const FonctionD& level_set_disc , const FonctionA& level_set_anal)
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , valueA , derDx , derDy , derAx , derAy , value_profile , value_profile_anal;
    Eigen::Matrix<double,2,1> derD , derA;
    point<double,2> node;
    size_t N, M;
    std::cout<<"In testing_level_set I need 80x80 points to see the interface. Now is 40x40, faster."<<std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_disc.dat");
    auto test_anal = std::make_shared< gnuplot_output_object<double> >("testing_interface_anal.dat");

    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");

    auto test_profile_disc  = std::make_shared< gnuplot_output_object<double> >("test_profile_disc.dat");
    auto test_profile_anal = std::make_shared< gnuplot_output_object<double> >("test_profile_anal.dat");


    double py = 0.5;
    //double iso_val_interface = level_set_disc.iso_val_interface ;
    for(auto& cl : msh.cells)
    {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        for(size_t i = 0 ; i<= N ; i++ )
        {
            double px = pt0_x + i*( (pt1_x - pt0_x)/N);
            for (size_t j = 0 ; j<= M ; j++ )
            {
                double py = pt0_y + j*( (pt1_y - pt0_y)/M);
                node = point_type(px,py);

                valueA = level_set_anal(node);
                valueD = level_set_disc(node,msh,cl);


                test_disc->add_data(node,valueD);
                test_anal->add_data(node,valueA);


                derA = level_set_anal.gradient(node);
                derD = level_set_disc.gradient(node,msh,cl);
                derDx = derD(0);
                derDy = derD(1);
                derAx = derA(0);
                derAy = derA(1);

                test_disc_gradX->add_data(node,derDx);
                test_anal_gradX->add_data(node,derAx);
                test_disc_gradY->add_data(node,derDy);
                test_anal_gradY->add_data(node,derAy);


            }

            node = point_type(px,py);
            value_profile = level_set_disc(node,msh,cl);
            test_profile_disc->add_data(node,value_profile);
            value_profile_anal = level_set_anal(node);
            test_profile_anal->add_data(node,value_profile_anal);
        }

    }


    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);

    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);

    postoutput1.add_object(test_profile_disc);
    postoutput1.add_object(test_profile_anal);

    postoutput1.write();

}


template< typename FonctionD , typename Mesh , typename FonctionA >
void
testing_level_set_disc(const Mesh msh , const FonctionD& level_set_disc , const FonctionA& level_set_anal)
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , valueA , derDx , derDy , derAx , derAy , value_profile , value_profile_anal;
    Eigen::Matrix<double,2,1> derD , derA;
    point<double,2> node;
    size_t N, M;
    std::cout<<"In testing_level_set I need 80x80 points to see the interface. Now is 40x40, faster."<<std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_disc.dat");
    auto test_anal = std::make_shared< gnuplot_output_object<double> >("testing_interface_disc_tmp.dat");

    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_disc_tmp_X.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_disc_tmp_Y.dat");

    auto test_profile_disc  = std::make_shared< gnuplot_output_object<double> >("test_profile_disc.dat");
    auto test_profile_anal = std::make_shared< gnuplot_output_object<double> >("test_profile_disc_tmp.dat");


    double py = 0.5;
    //double iso_val_interface = level_set_disc.iso_val_interface ;
    for(auto& cl : msh.cells)
    {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        for(size_t i = 0 ; i<= N ; i++ )
        {
            double px = pt0_x + i*( (pt1_x - pt0_x)/N);
            for (size_t j = 0 ; j<= M ; j++ )
            {
                double py = pt0_y + j*( (pt1_y - pt0_y)/M);
                node = point_type(px,py);

                valueA = level_set_anal(node,msh,cl);
                valueD = level_set_disc(node,msh,cl);


                test_disc->add_data(node,valueD);
                test_anal->add_data(node,valueA);


                derA = level_set_anal.gradient(node,msh,cl);
                derD = level_set_disc.gradient(node,msh,cl);
                derDx = derD(0);
                derDy = derD(1);
                derAx = derA(0);
                derAy = derA(1);

                test_disc_gradX->add_data(node,derDx);
                test_anal_gradX->add_data(node,derAx);
                test_disc_gradY->add_data(node,derDy);
                test_anal_gradY->add_data(node,derAy);


            }

            node = point_type(px,py);
            value_profile = level_set_disc(node,msh,cl);
            test_profile_disc->add_data(node,value_profile);
            value_profile_anal = level_set_anal(node,msh,cl);
            test_profile_anal->add_data(node,value_profile_anal);
        }

    }


    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);

    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);

    postoutput1.add_object(test_profile_disc);
    postoutput1.add_object(test_profile_anal);

    postoutput1.write();

}





template< typename FonctionD , typename Mesh  >
void
testing_level_set2_bis(const Mesh msh , const FonctionD& level_set_disc )
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD ; // , derDx , derDy ;
    Eigen::Matrix<double,2,1> derD ;
    point<double,2> node;
    size_t N, M;
    std::cout<<"In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster. No analytic solution."<<std::endl;
    N = 40; //80 points to see also the interface!!!
    M = 40; //80 points to see also the interface!!!
    double valueD_gamma ;
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_disc_bis.dat");

    auto test_gamma_disc = std::make_shared< gnuplot_output_object<double> >("test_gamma_disc_bis.dat");

    auto test_profile_disc = std::make_shared< gnuplot_output_object<double> >("test_profile_disc_fin_bis.dat");

    double iso_val_interface = level_set_disc.iso_val_interface ;

    for(size_t i = 0 ; i<= N ; i++ )
    {
        for (size_t j = 0 ; j<= M ; j++ )
        {
            double px = i*(1.0/N);
            double py = j*(1.0/M);
            node = point_type(px,py);

            if (std::abs( level_set_disc(node)-iso_val_interface) <1*1e-3 ) {
                valueD_gamma = 1;
            }
            else
                valueD_gamma = 0;

            valueD = level_set_disc(node);






            if( py == 0.5 )
            {
                test_profile_disc->add_data(node,valueD);

            }


            test_disc->add_data(node,valueD);

            test_gamma_disc->add_data(node,valueD_gamma);


        }

    }
    postoutput1.add_object(test_disc);

    postoutput1.add_object(test_gamma_disc);

    postoutput1.add_object(test_profile_disc);

    postoutput1.write();

}
template< typename FonctionD , typename Mesh  >
void
testing_level_set2(const Mesh& msh , const FonctionD& level_set_disc )
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD  , value_profile ;
    point<double,2> node;
    size_t N, M;
    std::cout<<"In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster. No analytic solution."<<std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!

    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_disc.dat");

    //auto test_gamma_disc = std::make_shared< gnuplot_output_object<double> >("test_gamma_disc.dat");

    auto test_profile_disc = std::make_shared< gnuplot_output_object<double> >("test_profile_disc_fin.dat");

    double py = 0.5;
    //double iso_val_interface = level_set_disc.iso_val_interface ;
    for(auto& cl : msh.cells)
    {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        for(size_t i = 0 ; i<= N ; i++ )
        {
            double px = pt0_x + i*( (pt1_x - pt0_x)/N);
            for (size_t j = 0 ; j<= M ; j++ )
            {
                double py = pt0_y + j*( (pt1_y - pt0_y)/M);
                node = point_type(px,py);

                valueD = level_set_disc(node,msh,cl);
                test_disc->add_data(node,valueD);



            }

            node = point_type(px,py);
            value_profile = level_set_disc(node,msh,cl);
            test_profile_disc->add_data(node,value_profile);
        }

    }
    postoutput1.add_object(test_disc);

    postoutput1.add_object(test_profile_disc);

    postoutput1.write();

}

template< typename FonctionD , typename Mesh  >
void
testing_level_set2(const Mesh msh , const FonctionD& level_set_disc ,const FonctionD& level_set_fin)
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , valueA ; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double,2,1> derD , derA;
    point<double,2> node;
    size_t N, M;
    std::cout<<"In testing_level_set2 I need 80x80 points to see the interface. Now is 40x40, faster."<<std::endl;
    N = 40; //80 points to see also the interface!!!
    M = 40; //80 points to see also the interface!!!
    double valueA_gamma , valueD_gamma ;
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_disc.dat");
    auto test_anal = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_anal.dat");
    auto test_gamma_disc = std::make_shared< gnuplot_output_object<double> >("test_gamma_disc.dat");
     auto test_gamma_anal = std::make_shared< gnuplot_output_object<double> >("test_gamma_anal.dat");

    auto test_profile_disc = std::make_shared< gnuplot_output_object<double> >("test_profile_disc_fin.dat");
    auto test_profile_anal = std::make_shared< gnuplot_output_object<double> >("test_profile_anal_fin.dat");
    /*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for(size_t i = 0 ; i<= N ; i++ )
    {
        for (size_t j = 0 ; j<= M ; j++ )
        {
            double px = i*(1.0/N);
            double py = j*(1.0/M);
            node = point_type(px,py);

            if (std::abs( level_set_disc(node)) <1*1e-3 ) {
                valueD_gamma = 1;
            }
            else
                valueD_gamma = 0;

            valueD = level_set_disc(node);

            if (std::abs( level_set_fin(node)) <1*1e-3 ) {
                valueA_gamma = 1;
            }
            else
                valueA_gamma = 0;

            valueA = level_set_fin(node);


            if( py == 0.5 )
            {
                test_profile_disc->add_data(node,valueD);
                test_profile_anal->add_data(node,valueA);
            }

            /*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node,valueD);
            test_anal->add_data(node,valueA);
            test_gamma_disc->add_data(node,valueD_gamma);
            test_gamma_anal->add_data(node,valueA_gamma);
            /*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
    postoutput1.add_object(test_gamma_disc);
    postoutput1.add_object(test_gamma_anal);
    postoutput1.add_object(test_profile_disc);
    postoutput1.add_object(test_profile_anal);
    /*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh  >
void
testing_level_set_mesh2(const Mesh msh , const FonctionD& level_set_disc ,const FonctionD& level_set_fin)
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , valueA ; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double,2,1> derD , derA;
    point<double,2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_disc_mesh2.dat");
    auto test_anal = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_anal_mesh2.dat");
    /*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for(size_t i = 0 ; i<= N ; i++ )
    {
        for (size_t j = 0 ; j<= M ; j++ )
        {
            double px = i*(1.0/N);
            double py = j*(1.0/M);
            node = point_type(px,py);
            /*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
            valueD = level_set_disc(node);
            /*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
            valueA = level_set_fin(node);
            /*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node,valueD);
            test_anal->add_data(node,valueA);
            /*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
    /*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh  >
void
testing_level_set_mesh1(const Mesh msh , const FonctionD& level_set_disc ,const FonctionD& level_set_fin)
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , valueA ; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double,2,1> derD , derA;
    point<double,2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_disc_mesh1.dat");
    auto test_anal = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_anal_mesh1.dat");
    /*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for(size_t i = 0 ; i<= N ; i++ )
    {
        for (size_t j = 0 ; j<= M ; j++ )
        {
            double px = i*(1.0/N);
            double py = j*(1.0/M);
            node = point_type(px,py);
            /*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
            valueD = level_set_disc(node);
            /*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
            valueA = level_set_fin(node);
            /*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node,valueD);
            test_anal->add_data(node,valueA);
            /*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
    /*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}

// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh  >
void
testing_level_set_mesh0(const Mesh msh , const FonctionD& level_set_disc ,const FonctionD& level_set_fin)
{
    typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;
    double valueD , valueA ; //, derDx , derDy , derAx , derAy;
    Eigen::Matrix<double,2,1> derD , derA;
    point<double,2> node;
    size_t N, M;
    N = 40;
    M = 40;
    auto test_disc  = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_disc_mesh0.dat");
    auto test_anal = std::make_shared< gnuplot_output_object<double> >("testing_interface_fin_anal_mesh0.dat");
    /*
    auto test_disc_gradX  = std::make_shared< gnuplot_output_object<double> >("testing_der_discX.dat");
    auto test_anal_gradX = std::make_shared< gnuplot_output_object<double> >("testing_der_analX.dat");

    auto test_disc_gradY  = std::make_shared< gnuplot_output_object<double> >("testing_der_discY.dat");
    auto test_anal_gradY = std::make_shared< gnuplot_output_object<double> >("testing_der_analY.dat");
    */
    for(size_t i = 0 ; i<= N ; i++ )
    {
        for (size_t j = 0 ; j<= M ; j++ )
        {
            double px = i*(1.0/N);
            double py = j*(1.0/M);
            node = point_type(px,py);
            /*
            if (std::abs( level_set_disc(node)) <1e-2 ) {
                valueD = 1;
            }
            else
                valueD = 0;
            */
            valueD = level_set_disc(node);
            /*
            if (std::abs( level_set_anal(node)) <1e-2 ) {
                valueA = 1;
            }
            else
                valueA = 0;
            */
            valueA = level_set_fin(node);
            /*
            derD = level_set_disc.gradient(node);
            derA = level_set_fin.gradient(node);


            derDx = derD(0);
            derDy = derD(1);
            derAx = derA(0);
            derAy = derA(1);
            */
            test_disc->add_data(node,valueD);
            test_anal->add_data(node,valueA);
            /*
            test_disc_gradX->add_data(node,derDx);
            test_anal_gradX->add_data(node,derAx);
            test_disc_gradY->add_data(node,derDy);
            test_anal_gradY->add_data(node,derAy);
            */
        }

    }
    postoutput1.add_object(test_disc);
    postoutput1.add_object(test_anal);
    /*
    postoutput1.add_object(test_disc_gradX);
    postoutput1.add_object(test_anal_gradX);
    postoutput1.add_object(test_disc_gradY);
    postoutput1.add_object(test_anal_gradY);
    */
    postoutput1.write();

}
// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh , typename FonctionA >
void
test_new_method(const Mesh msh , const FonctionD& level_set_disc , const FonctionA& level_set_anal , const typename Mesh::cell_type & cl)
{
    //typedef typename Mesh::point_type       point_type;
    double valueD1 , valueD2 ,valueA ;

    auto pts =points(msh,cl);




    timecounter tc1;
    tc1.tic();
    for(auto& pt : pts)
    {
        valueD1 = level_set_disc(pt,msh,cl);
       // valueA = level_set_anal(pt);
       // valueD2 = level_set_disc(pt);
       // std::cout<<"Differnce between two evaluation system "<<(valueD1-valueD2)<<std::endl;
      //  std::cout<<"Im in test_new_method";
    }




    tc1.toc();
    std::cout << bold << yellow << "Time for the new evaluation: " << tc1 << " seconds" << reset << std::endl;

   tc1.tic();
       for(auto& pt : pts)
       {
           valueD2 = level_set_disc(pt);
         //  std::cout<<"Im in test_new_method";
       }
    tc1.toc();
    std::cout << bold << yellow << "Time for the old evaluation: " << tc1 << " seconds" << reset << std::endl;

    tc1.tic();
         for(auto& pt : pts)
         {
             valueA = level_set_anal(pt);
         }
      tc1.toc();
      std::cout << bold << yellow << "Time for the analytic evaluation: " << tc1 << " seconds" << reset << std::endl;


}

// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh >
void
time_NEWdiscrete_testing(const Mesh msh , const FonctionD& level_set_disc , const typename Mesh::cell_type & cl)
{
    //typedef typename Mesh::point_type       point_type;
    double valueD1 ; //, valueD2 ,valueA ;

    auto pts =points(msh,cl);


    for(auto& pt : pts)
    {
        valueD1 = level_set_disc(pt,msh,cl);

    }


}

// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh >
void
time_OLDdiscrete_testing(const Mesh msh , const FonctionD& level_set_disc , const typename Mesh::cell_type & cl)
{
    //typedef typename Mesh::point_type       point_type;
    double valueD1 ; //, valueA ; // valueD2 ,

    auto pts =points(msh,cl);


    for(auto& pt : pts)
    {
        valueD1 = level_set_disc(pt);

    }


}

template< typename FonctionA , typename Mesh >
void
time_analytic_testing(const Mesh msh , const FonctionA& level_set_anal , const typename Mesh::cell_type & cl)
{
    //typedef typename Mesh::point_type       point_type;
    double valueA ; // valueD1 , valueD2 ,

    auto pts =points(msh,cl);


    for(auto& pt : pts)
    {
        valueA = level_set_anal(pt);

    }


}


template< typename FonctionD , typename Mesh >
void
time_face_testing(const Mesh msh , const FonctionD& level_set_disc , const typename Mesh::face_type & fc)
{

    //typedef typename Mesh::point_type       point_type;
    double valueD1 ;// , valueD2 ,valueA ;

    auto pts =points(msh,fc);


    for(auto& pt : pts)
    {
        valueD1 = level_set_disc(pt,msh,fc);

    }



}

template< typename FonctionA , typename Mesh >
void
time_faceANALITIC_testing(const Mesh msh , const FonctionA& level_set_anal , const typename Mesh::face_type & fc)
{

    //typedef typename Mesh::point_type       point_type;
    double valueA ; // valueD1 , valueD2 ,

    auto pts =points(msh,fc);


    for(auto& pt : pts)
    {
        valueA = level_set_anal(pt);

    }



}



// Qualitative testing of the discrete level set function wrt the analytical one
template< typename FonctionD , typename Mesh , typename FonctionA >
void
test_new_method(const Mesh msh , const FonctionD& level_set_disc , const FonctionA& level_set_anal , const typename Mesh::cell_type & cl , const typename Mesh::face_type & fc)
{
    //typedef typename Mesh::point_type       point_type;
    double valueD1  ,valueA , valueD3; //, valueD2

    auto pts =points(msh,fc);




    timecounter tc1;
    tc1.tic();
    for(auto& pt : pts)
    {
        valueD1 = level_set_disc(pt,msh,fc);
        valueA = level_set_anal(pt);
        //valueD2 = level_set_disc(pt,msh,cl);
        valueD3 = level_set_disc(pt);

        std::cout<<"Differnce between FACE and OLD evaluation system "<<(valueD1-valueD3)<<std::endl;
        std::cout<<"Error between analytic and face evaluation "<<(valueD1-valueA)<<std::endl;
    }



}



template<typename T>
std::vector<point<T,1> >
reference_nodes_ordered(size_t degree)
{
    auto comp_degree = degree + 1;
    size_t reqd_nodes = comp_degree;

    std::vector<point<T,1> > ret;
    ret.reserve(reqd_nodes);

    point<T,1>  qp , qp_1;
    T           a1, a2;
    T           delta_x;
    switch(reqd_nodes)
    {
        case 1:
            qp = point<T,1>({0.0});
            ret.push_back(qp);
            return ret;

        case 2:
            qp = point<T,1>({ 1.0 });
            ret.push_back( -qp );
            ret.push_back( qp );
            return ret;

        case 3:
            qp = point<T,1>({ 1.0 });
            ret.push_back( -qp );
            ret.push_back( qp );
            qp = point<T,1>({0.0});
            ret.push_back( qp );
            return ret;

        case 4:
            a1 = 1.0/3.0;
            qp = point<T,1>({ 1.0 });
            ret.push_back( -qp );
            ret.push_back( qp );
            qp = point<T,1>({ a1 });
            ret.push_back( -qp );
            ret.push_back( qp );
            return ret;

        case 5:
            // Be carefull in what order data is inserted in ret!
            // In Gauss Legendre the first one was 0.0, now is the last one
            a2 = 0.5;
            a1 = 1.0;
            qp = point<T,1>({ a1 });
            ret.push_back( -qp );
            ret.push_back( qp );

            qp = point<T,1>({ a2 });
            ret.push_back( -qp );
            qp_1 = point<T,1>({ 0.0 });
            ret.push_back( qp_1 );
            ret.push_back( qp );

         //   qp = point<T,1>({ 0.0 });
         //   ret.push_back( qp );
            return ret;

        default:

            delta_x = 2.0/degree;
            a1 = 1.0;
            while (a1>1e-10) {
                qp = point<T,1>({ a1 });
                ret.push_back( -qp );
                ret.push_back( qp );
                a1-=delta_x;

            }
            if(a1<1e-10 && a1>-1e-10)
            {
                qp = point<T,1>({0.0});
                ret.push_back( qp );
            }
            std::sort(ret.begin()+2, ret.end() ,[](point<T,1>  a, point<T,1>  b) {
                return a.x() < b.x();
            } );
            return ret;
    }
    return ret;
}


// Lagrangian basis b_kl(x,y) = b_k(x)*b_l(y) over a set of equidistributed 2-dimensional nodes (3D CASE NOT YET IMPLEMENTED)

template<typename T,typename Mesh>
std::vector< point<T,2> >
equidistriduted_nodes_ordered_bis(const Mesh& msh,
          const typename Mesh::cell_type& cl,
          size_t degree)
{
    typedef typename Mesh::point_type    point_type;

    auto qps = reference_nodes_ordered<T>(degree); //Ordering:  0 2 3 4 5 6 ... 1

    // 3 -  12 - 11 - 10 - 2
    // 13 - 22 - 21 - 20 - 9
    // 14 - 23 - 24 - 19 - 8
    // 15 - 16 - 17 - 18 - 7
    // 0 -  4 -  5  - 6  - 1

    auto pts = points(msh, cl);

    //auto v0 = pts[1] - pts[0];
    //auto v1 = pts[2] - pts[1];
    //auto v2 = pts[3] - pts[2];
    //auto v3 = pts[3] - pts[0];

    std::vector< point<T,2> > ret((degree+1)*(degree+1));

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1-xi)*(1-eta) +
               0.25 * pts[1].x() * (1+xi)*(1-eta) +
               0.25 * pts[2].x() * (1+xi)*(1+eta) +
               0.25 * pts[3].x() * (1-xi)*(1+eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1-xi)*(1-eta) +
               0.25 * pts[1].y() * (1+xi)*(1-eta) +
               0.25 * pts[2].y() * (1+xi)*(1+eta) +
               0.25 * pts[3].y() * (1-xi)*(1+eta);
    };

    /// ADDING VERTICES:

    // (-1,-1)
    auto qp_x = qps[0];
    auto qp_y = qps[0];
    auto xi = qp_x.x();
    auto eta = qp_y.x();
    auto px = P(xi, eta);
    auto py = Q(xi, eta);
    ret[0] = ( point_type(px, py) );

    if( degree == 0 )
        return ret ;

    // (1,-1)
    qp_x = qps[1];
    qp_y = qps[0];
    xi = qp_x.x();
    eta = qp_y.x();
    px = P(xi, eta);
    py = Q(xi, eta);
    ret[1] = ( point_type(px, py) );
    // (1,1)
    qp_x = qps[1];
    qp_y = qps[1];
    xi = qp_x.x();
    eta = qp_y.x();
    px = P(xi, eta);
    py = Q(xi, eta);
    ret[2] = ( point_type(px, py) );
    // (-1,1)
    qp_x = qps[0];
    qp_y = qps[1];
    xi = qp_x.x();
    eta = qp_y.x();
    px = P(xi, eta);
    py = Q(xi, eta);
    ret[3] = ( point_type(px, py) );

    /// Counter for each side of the 2D - square : starting to count from a vertice, the position where I save the point in ret is (degree -1)*j , with j the j-esima face.

    int  count0 = 4 , count1 = 4 + degree - 1 , count2 = 4 + 2*(degree - 1), count3 = 4 + 3*(degree - 1)  ;

    int count_bis0 = 4*degree ; // counter initialisation (USELESS)
    int j_max = floor((degree-1)/2) ; // number of internal layour of points
  //  std::cout<<"j max "<<j_max<<std::endl;
    int pos_right = 100; // initial point from the right from bottom -> up
    int pos_left = 100; // initial point from the left from left -> right
   // size_t i_min = 0;
 //   std::cout<<"inizia ciclo"<<std::endl;
    for (int j = 0 ; j <= j_max ; j++ ) { // for each layout of point
       // bool i_loop = FALSE;
        for(int i = std::max(0,j-1) ; i < degree -1 - j ; i++ ) // I move from into the points over a side of each layout
        {

            if( i == std::max(0,j-1) && j > 0) // vertices
            {
                // different pos_left depending on the layout. Especially this rules the y starting point
                if(j == 0)
                    pos_left = 0;
                else if(j == 1)
                    pos_left = 2;
                else
                    pos_left = 2+(j-1);

                //   std::cout<<"pos_left "<<pos_left<<std::endl;
                qp_x = qps[2+i];
                qp_y = qps[pos_left]; //qps[0 + 2*j];
                //   std::cout<<"qp_y "<<qp_y<<std::endl;
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                // Here change counters. No more count0, count1 etc.. Just count_bis0, to have the vertices enumerate one after the other.
                count_bis0 = count0; // counter_bis0 re-initialisation for each loop (first loop)
                //std::cout<<"count bis 0 "<<count_bis0<<std::endl;
                ret[count_bis0] = ( point_type(px, py) ); // adding point bottom layout
                //std::cout<<"count0 is "<<count0<<" , pt0"<<point_type(px, py)<<std::endl;
                //std::cout<<ret[count0]<<std::endl;
                count_bis0++;

                if(j==0)
                    pos_right = 1;
                else
                    pos_right = degree + 1 - j;
                // size_t pos = (1 + j*(degree-1));
                // if(pos>degree)
                //     pos -= j*degree ;

                qp_x =  qps[pos_right];
                qp_y = qps[2 + i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count_bis0] = ( point_type(px, py) ); // adding point right layout in count_bis0 pos.
                //std::cout<<"count1 is "<<count1<<" , pt1"<<point_type(px, py)<<std::endl;
                //std::cout<<"count_bis0 is "<<count_bis0<<std::endl;
                //std::cout<<ret[count_bis0]<<std::endl;
                count_bis0++;

                qp_x = qps[degree - i];
                qp_y =  qps[pos_right] ;
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count_bis0] = ( point_type(px, py) ); // adding point top layout in count_bis0 pos.
                //std::cout<<"count_bis0 is "<<count_bis0<<" and pt "<<ret[count_bis0]<<std::endl;
                //std::cout<<"count2 is "<<count2<<" , pt2"<<point_type(px, py)<<std::endl;

                count_bis0++;
                qp_x = qps[pos_left];
                qp_y = qps[degree - i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count_bis0] = ( point_type(px, py) ); // adding point left layout in count_bis0 pos.
                //std::cout<<"count_bis0 is "<<count_bis0<<" and pt "<<ret[count_bis0]<<std::endl;
                //std::cout<<"count3 is "<<count3<<" , pt3"<<point_type(px, py)<<std::endl;
                count_bis0++;

                // Updating counters according to count_bis0. I start enumerate "face" unknown for the current layout (IN ELSE HERE BELOW) from the last position count_bis0.
                count0 = count_bis0 ;
                count1 = count0 + degree - 1.0 - 2.0*j; //  count0 + (degree - 2); it was
                count2 = count1 + degree - 1.0 - 2.0*j;
                count3 = count2 + degree - 1.0 - 2.0*j;



            }
            else // NOT vertices -> node in the sides of each layout
            {

                //   std::cout<<"i "<<i<<" j "<<j<<std::endl;
                // vertical position where starting for each bottom side layout.
                if(j == 0)
                    pos_left = 0;
                else if(j == 1)
                    pos_left = 2;
                else
                    pos_left = 2+(j-1);

                //   std::cout<<"pos_left "<<pos_left<<std::endl;
                qp_x = qps[2+i];
                qp_y = qps[pos_left]; //qps[0 + 2*j];
                //   std::cout<<"qp_y "<<qp_y<<std::endl;
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count0] = ( point_type(px, py) ); // from left, node of each bottom side layout
                //std::cout<<"count0 is "<<count0<<" , pt0"<<point_type(px, py)<<std::endl;
                //std::cout<<ret[count0]<<std::endl;
                count0++;
                // x-position where to start to increase to get points for each right side layout of points
                if(j==0)
                    pos_right = 1;
                else
                    pos_right = degree + 1 - j;
                // size_t pos = (1 + j*(degree-1));
                // if(pos>degree)
                //     pos -= j*degree ;

                qp_x =  qps[pos_right];
                qp_y = qps[2 + i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count1] = ( point_type(px, py) ); // using count1 that allows correct enumeration
                //std::cout<<"count1 is "<<count1<<" , pt1"<<point_type(px, py)<<std::endl;
                //std::cout<<ret[count1]<<std::endl;
                count1++; // count1 bigger than count0. Count1 just enumerate right faces' layout

                qp_x = qps[degree - i];
                qp_y =  qps[pos_right] ;
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count2] = ( point_type(px, py) );
                //std::cout<<"count2 is "<<count2<<" , pt2"<<point_type(px, py)<<std::endl;
                count2++; // count2 just enumerate top faces' layout

                qp_x = qps[pos_left];
                qp_y = qps[degree - i];
                xi = qp_x.x();
                eta = qp_y.x();
                px = P(xi, eta);
                py = Q(xi, eta);
                ret[count3] = ( point_type(px, py) );
                //std::cout<<"count3 is "<<count3<<" , pt3"<<point_type(px, py)<<std::endl;
                count3++; // count3 just enumerate left faces' layout


            }
        }
        // Updating for the next layout.
        count0 = count3 ;
        count1 = count0 + (degree - 2*(j+1)); //  count0 + (degree - 2); it was
        count2 = count1 + (degree - 2*(j+1));
        count3 = count2 + (degree - 2*(j+1));


        //}
    }

    /// Middle point --> the internal node is treated a part of the others. Just even degrees have it.
    if( degree % 2 == 0)
    {
        qp_x = qps[degree - floor((degree-1)/2)];
        qp_y = qps[degree - floor((degree-1)/2)];
        xi = qp_x.x();
        eta = qp_y.x();
        px = P(xi, eta);
        py = Q(xi, eta);
        ret[count0] = ( point_type(px, py) );
        //std::cout<<"counto MIDDLE is "<<count0<<" , pt3"<<point_type(px, py)<<std::endl;
    }
    return ret;
}

template<typename Mesh, typename T >
class cell_basis_Lagrangian_ordered
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    std::vector<point<T, 2> >          nodes;
    std::vector<size_t>         row_indeces , col_indeces ;

public:
    cell_basis_Lagrangian_ordered(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        //nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);
        // nodes           = equidistriduted_nodes_ordered<T,Mesh>(msh, cl, degree);
        nodes           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);
        set_col_row_indeces();

    }

    void set_col_row_indeces()
    {
        //std::cout<<"SONO QUA NEL SET INDECES "<<row_indeces.size()<<" and "<<col_indeces.size()<<std::endl;
        // It could be cool to just save once and not call each time. To do that or call the  variable Static(?) or give it just as external fx and initiliaze once.
        if(row_indeces.size()==0 && col_indeces.size()==0 )
        {
            row_indeces.push_back(0);
            row_indeces.push_back(1);
            col_indeces.push_back(0);
            col_indeces.push_back(3);
            for(size_t i = 0 ; i<basis_degree-1 ; i++){
                row_indeces.push_back(4+i);
                col_indeces.push_back(3*basis_degree+1);
            }

        }
    }


    /*
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, const std::vector<size_t>& indeces)
    {

        nodes = equidistriduted_nodes_subcell<T,Mesh>(msh, cl, degree, indeces);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);

    }
    */

    Matrix<T, Dynamic, 1>
    eval_basis(const point_type& pt)
    {
        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_degree+1);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_degree+1);
        Matrix<T, Dynamic, 1> ret =  Matrix<T, Dynamic, 1>::Zero(basis_size);


        /*
        for(size_t i = 0 ; i<basis_degree+1 ; i++){
            std::cout<<row_indeces[i]<<" , ";
        }
        std::cout<<std::endl;
        for(size_t i = 0 ; i<basis_degree+1 ; i++){
            std::cout<<col_indeces[i]<<" , ";
        }
        std::cout<<std::endl;
        */
        // the indeces of first row and column are already saved. Just need a loop over them and then do the right tensor product maintaining the ordering of the nodes.
        size_t ct = 0;
        for(auto& k : row_indeces)
        {
            T bk = 1;
            for ( auto& j : row_indeces ){
                if(j!=k){
            bk *= ( ( pt.x() - (nodes.at(j)).x() )/ ( (nodes.at(k)).x() - (nodes.at(j)).x() ) );
                }
            }

            retx(ct) = bk;
            ct++;
        }

        ct = 0;
        for(auto& l : col_indeces)
        {
            T bl = 1;
            for ( auto& j : col_indeces ){
                if(j!=l){
            bl *= ( ( pt.y() - (nodes.at(j)).y() )/ ( (nodes.at(l)).y() - (nodes.at(j)).y() ) );
                }
            }
            rety(ct) = bl;
            ct++;
        }



        // VERTICES FUNCTIONS:
        if( basis_degree == 0){
            ret(0) = rety(0)*retx(0);
            return ret ;
        }


        ret(0) = rety(0)*retx(0);
        ret(1) = rety(0)*retx(1);
        ret(2) = rety(1)*retx(1);
        ret(3) = rety(1)*retx(0);

        if( basis_degree == 1)
            return ret ;

        int  count0 = 4 , count1 = 4 + basis_degree - 1 , count2 = 4 + 2*(basis_degree - 1), count3 = 4 + 3*(basis_degree - 1)  ;
        int count_bis0 = 4*basis_degree ; // counter initialisation (USELESS)
        int j_max = floor((basis_degree-1)/2) ; // number of internal layour of points
        int pos_right = 100; // initial point from the right from bottom -> up
        int pos_left = 100; // initial point from the left from left -> right

        for (int j = 0 ; j <= j_max ; j++ ) { // for each layout of point
            // bool i_loop = FALSE;
            for(int i = std::max(0,j-1) ; i < basis_degree -1 - j ; i++ ) // I move from left into the points over a side of each layout
            {
                if( i == std::max(0,j-1) && j > 0) // vertices
                {
                    // different pos_left depending on the layout. Especially this rules the y starting point
                    if(j == 0)
                        pos_left = 0;
                    else if(j == 1)
                        pos_left = 2;
                    else
                        pos_left = 2+(j-1);

                    // Here change counters. No more count0, count1 etc.. Just count_bis0, to have the vertices enumerate one after the other.
                    count_bis0 = count0; // counter_bis0 re-initialisation for each loop (first loop)
                    //std::cout<<"count bis 0 "<<count_bis0<<std::endl;
                    ret(count_bis0) = ( retx(2+i)*rety(pos_left) ); // adding point bottom layout
                    count_bis0++;
                    if(j==0)
                        pos_right = 1;
                    else
                        pos_right = basis_degree + 1 - j;

                    ret(count_bis0) = ( retx(pos_right)*rety(2 + i) ); // adding point right layout in count_bis0 pos.
                    count_bis0++;

                    ret(count_bis0) = ( retx(basis_degree - i)*rety(pos_right) ); // adding point top layout in count_bis0 pos.

                    count_bis0++;

                    ret(count_bis0) = ( retx(pos_left)*rety(basis_degree - i) );

                    count_bis0++;

                    // Updating counters according to count_bis0. I start enumerate "face" unknown for the current layout (IN ELSE HERE BELOW) from the last position count_bis0.
                    count0 = count_bis0 ;
                    count1 = count0 + std::ceil((basis_degree - 2.0*j)/2.0); //  count0 + (degree - 2); it was
                    count2 = count1 + std::ceil((basis_degree - 2.0*j)/2.0);
                    count3 = count2 + std::ceil((basis_degree - 2.0*j)/2.0);

                }
                else // NOT vertices -> node in the sides of each layout
                {
                    //   std::cout<<"i "<<i<<" j "<<j<<std::endl;
                    // vertical position where starting for each bottom side layout.
                    if(j == 0)
                        pos_left = 0;
                    else if(j == 1)
                        pos_left = 2;
                    else
                        pos_left = 2+(j-1);

                    ret(count0) = ( retx(2+i)*rety(pos_left) );
                    count0++;
                    // x-position where to start to increase to get points for each right side layout of points
                    if(j==0)
                        pos_right = 1;
                    else
                        pos_right = basis_degree + 1 - j;

                    ret(count1) = ( retx(pos_right)*rety(2 + i) );
                    count1++; // count1 bigger than count0. Count1 just enumerate right faces' layout

                    ret(count2) = ( retx(basis_degree - i)*rety(pos_right) );
                    count2++; // count2 just enumerate top faces' layout

                    ret(count3) = ( retx(pos_left)*rety(basis_degree - i) );
                    count3++; // count3 just enumerate left faces' layout


                }
            }
            // Updating for the next layout.
            count0 = count3 ;
            count1 = count0 + (basis_degree - 2*(j+1));
            count2 = count1 + (basis_degree - 2*(j+1));
            count3 = count2 + (basis_degree - 2*(j+1));

        }

        /// Middle point --> the internal node is treated a part of the others. Just even degrees have it.
        if( basis_degree % 2 == 0)
            ret(count0) = (retx(basis_degree - floor((basis_degree-1)/2))*rety(basis_degree - floor((basis_degree-1)/2)));

        return ret;


    }



    Matrix<T, Dynamic, 2>
    eval_gradients(const point_type& pt)
    {
        // Modified Yves Daoust Algorithm (https://math.stackexchange.com/questions/809927/first-derivative-of-lagrange-polynomial)

        Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Zero(basis_size, 2);

        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sy = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sx = Matrix<T, Dynamic, 1>::Zero(basis_size);


        // for each l, b_l(y)' = {sum(tmpy!=l)[prod(jy!=l,jy!=tmpy)[x-x_jy]]}/prod(tmpy!=l)[x_l-x_tmpy]

        for ( size_t l = 0; l < basis_size ; l++ )
        {
            size_t col = l%(basis_degree+1);
            T bl = 1.0 , bl_der = 1.0 ;
            T sumy = 0.0;
            for (size_t tmpy = col; tmpy <= col+(basis_degree+1)*basis_degree; tmpy+=(basis_degree+1))
            {
                 T sumyy = 1.0 ;
                if (tmpy!=l)
                {

                    bl *= ( ( pt.y() - (nodes.at(tmpy)).y() )/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );

                    bl_der *= ( 1.0/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );
                    for ( size_t jy = col; jy <= col+(basis_degree+1)*basis_degree; jy+=(basis_degree+1) )
                   {
                        if (jy!=tmpy && jy!=l)
                        {
                            sumyy *= ( pt.y()-(nodes.at(jy)).y() );
                        }
                    }
                    sumy +=sumyy;
                }
            }
            rety(l) = bl;
            sy(l) = bl_der*sumy;
        }

        // For the x-derivative of b_k(x), same procedure of b_l(y)'

        for (size_t k = 0 ; k < basis_size ; k++ )
        {
            size_t row=floor( k/(basis_degree+1) );
            T bk = 1.0 , bk_der = 1.0 ;
            T sumx = 0.0;
            for (size_t tmpx = (basis_degree+1)*row; tmpx <= (basis_degree+1)*(row+1)-1; tmpx++)
            {
                T sumxx = 1.0 ;

                if (tmpx!=k) {

                    bk *= ( ( pt.x() - (nodes.at(tmpx)).x() )/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                    bk_der *= ( 1.0/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                    for (size_t jx = (basis_degree+1)*row; jx <= (basis_degree+1)*(row+1)-1; jx++)
                    {
                        if (jx!=tmpx && jx!=k)
                        {
                            sumxx *= ( pt.x()-(nodes.at(jx)).x() );
                        }
                    }
                    sumx += sumxx;

                }
            }
            retx(k) = bk;
            sx(k) = bk_der*sumx;
        }

        for (size_t i = 0; i<basis_size; i++)
        {
            ret(i,0) = rety(i)*sx(i);
            ret(i,1) = retx(i)*sy(i);

        }
        return ret;

    }

    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return (degree+1)*(degree+1);
    }
};



int binomial_coeff_fx(int n , int k) {

        int C[n + 1][k + 1];
        int i, j;

        // Caculate value of Binomial Coefficient
        // in bottom up manner
        for (i = 0; i <= n; i++)
        {
            for (j = 0; j <= std::min(i, k); j++)
            {
                // Base Cases
                if (j == 0 || j == i)
                    C[i][j] = 1;

                // Calculate value using previously
                // stored values
                else
                    C[i][j] = C[i - 1][j - 1] +
                              C[i - 1][j];
            }
        }

        return C[n][k];
}



template<typename Mesh, typename VT>
class cell_basis_Bernstein
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    coordinate_type min_x , max_x , min_y , max_y ;
    coordinate_type scaling_x , scaling_y ;

#ifdef POWER_CACHE
    std::vector<coordinate_type>  power_cache , power_cache_bis;
    std::vector<size_t>  binomial_coeff , binomial_coeff_bis ;
#endif

public:
    cell_basis_Bernstein(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        //cell_bar        = barycenter(msh, cl);
        //cell_h          = diameter(msh, cl);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);
        min_x = points(msh,cl)[0].x();
        max_x = points(msh,cl)[1].x();
        min_y = points(msh,cl)[0].y();
        max_y = points(msh,cl)[2].y();
        scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );
        scaling_y = 1.0/( pow( (max_y - min_y), basis_degree) );

    }

    Matrix<VT, Dynamic, 1>
    eval_basis(const point_type& pt)
    {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);

        auto bx0 = pt.x() - min_x ;
        auto bx1 = max_x - pt.x() ;
        auto by0 = pt.y() - min_y ;
        auto by1 = max_y - pt.y() ;

#ifdef POWER_CACHE
        if ( power_cache.size() != (basis_degree+1)*2 )
          power_cache.resize( (basis_degree+1)*2);

        if ( binomial_coeff.size() != (basis_degree+1) )
        binomial_coeff.resize( basis_degree+1 );

        // Creation of the exponential terms
        for (size_t i = 0 ; i <= basis_degree ; i++)
        {
            size_t j = basis_degree - i;
            //if(i == 0)
             //   binomial_coeff[0] = 1.0 ;
            //else if(i == basis_degree)
            //    binomial_coeff[basis_degree+1] = 1.0 ;
           // else

            binomial_coeff[i] = binomial_coeff_fx(basis_degree,i);


            power_cache[2*i]    = binomial_coeff[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j);
            power_cache[2*i+1]  = binomial_coeff[i]*iexp_pow(by0, i)*iexp_pow(by1, j);

        }

#endif
        size_t pos = 0;

        // Case degree FEM = 0
        if (basis_degree == 0){
            VT one = 1.0;
            ret(pos++) = one;
        }
        // Case degree FEM = 1 -> i.e. just vertices
        // Cell ordering:
        // 3 -- 2
        // 0 -- 1

        else if(basis_degree == 1){
            for (int pow_y = 0; pow_y <= basis_degree; pow_y +=basis_degree){
                if( pow_y == 0 ) // ordering from sx to dx 0->1
                {
                for (int pow_x = 0; pow_x <= basis_degree; pow_x+=basis_degree){
#ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
#endif
                    ret(pos++) = bv;
                }
                }
                else{ // ordering from dx to sx 2->3
                    for (int pow_x = basis_degree; pow_x >= 0; pow_x-=basis_degree){
#ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
#endif
                    ret(pos++) = bv;
                }
                }
            }
        }

        else
        {
            // case degree FEM >= 2
            int N = basis_degree ;
            int starter = 0;
            int internal_bases = basis_degree + 1 ; // counting the number of layout of internal nodes: initially there are basis_degree +1 nodes

            while(internal_bases > 1) // if there is a deeper layout of nodes
            {
                // Vertices nodes of a quadrangular cell. For each loop of internal_bases I add the vertice of "inner quadrangualar nodes" ( it's not properly true speaking of nodes, being a modal approach; better say the picks of the shape functions).
                for (int pow_y = starter; pow_y <= N; pow_y +=(N-starter)){

                    if(pow_y == starter ) // if bottom line -> from sx to dx
                    {
                       // if not external layout of nodes ( vertices level ) -> I don't take extremes since internal layout has 2 nodes less.
                        for (int pow_x = starter; pow_x <= N; pow_x+=(N-starter)){
#ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
#endif
                        ret(pos++) = bv;
                        // std::cout<<"pos vertices bottom is "<<pos<<std::endl;
                        }
                    }
                    else{ // if top line -> from dx to sx
                        for (int pow_x = N; pow_x >= starter; pow_x-=(N-starter)){
#ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
#else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
#endif
                        ret(pos++) = bv;
                       // std::cout<<"pos vertices upper is "<<pos<<std::endl;
                        }

                    }

                }


                // After the vertices elements, step by faces bases.

                //size_t pos = 4;
                // face 0 (BOTTOM)
                for (size_t pow_x = starter + 1 ; pow_x <= N - 1 ; pow_x++)
                {
                    size_t pow_y = starter;
#ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
#else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
#endif
                    ret(pos++) = bv;
                   //  std::cout<<"pos face 0 is "<<pos<<std::endl;
                }

                // face 1 (RIGHT)
                for (size_t pow_y = starter + 1; pow_y <= N - 1 ; pow_y++)
                {
                    size_t pow_x = N;
        #ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
        #else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
        #endif
                    ret(pos++) = bv;
                  //   std::cout<<"pos face 1 is "<<pos<<std::endl;
                }

                // face 2 (TOP)
                for (size_t pow_x = N - 1; pow_x >= starter + 1 ; pow_x--)
                {
                    size_t pow_y = N;
        #ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
        #else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
        #endif
                    ret(pos++) = bv;
                  //   std::cout<<"pos face 2 is "<<pos<<std::endl;
                }


                // face 3 (LEFT)

                for (size_t pow_y = N - 1; pow_y >= starter + 1 ; pow_y--)
                {
                    size_t pow_x = starter;
        #ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
        #else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
        #endif
                    ret(pos++) = bv;
                  //   std::cout<<"pos face 3 is "<<pos<<std::endl;
                }

                N--; // for each layout of "nodes", I have un unknown less from right
                starter++; // for each layout of "nodes", I have un unknown less from left
                internal_bases -= 2 ; // each layout I have 2 nodes less than the previous

            }
            // for B_k, with k even, odd number of bases: there is a central one.
            if( basis_degree % 2 == 0 )
            {
             //   std::cout<<"N is "<<N<< " and starter is "<<starter<<std::endl;
                assert( N == starter );
                size_t pow_x = starter ;
                size_t pow_y = starter ;
#ifdef POWER_CACHE
                auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
#else
                size_t j_x = basis_degree - pow_x;
                size_t j_y = basis_degree - pow_y;

                auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) * scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
#endif
                ret(pos++) = bv;
               //  std::cout<<"pos %2 is "<<pos<<std::endl;
            }
        }
       // std::cout<<"pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;
    }

    // Same approach of eval
    Matrix<VT, Dynamic, 2>
    eval_gradients(const point_type& pt)
    {
        Matrix<VT, Dynamic, 2> ret = Matrix<VT, Dynamic, 2>::Zero(basis_size, 2);

        auto bx0 = pt.x() - min_x ;
        auto bx1 = max_x - pt.x() ;
        auto by0 = pt.y() - min_y ;
        auto by1 = max_y - pt.y() ;
        //The stuff below should be in the constructor, but gradient is used less times than eval.
        auto N = basis_degree - 1 ;
        auto coeff_dx = basis_degree/(max_x - min_x); // n/(b-a)
        auto coeff_dy = basis_degree/(max_y - min_y);
        auto scaling_x_bis = 1.0/(pow(max_x - min_x,N) ); // 1/(b-a)^(n-1)
        auto scaling_y_bis = 1.0/(pow(max_y - min_y,N) );
        //std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

#ifdef POWER_CACHE
        if ( power_cache.size() != (basis_degree+1)*2 )
          power_cache.resize( (basis_degree+1)*2) ;

        if ( power_cache_bis.size() != (N+1)*2 )
            power_cache_bis.resize( (N+1)*2) ;

        if ( binomial_coeff.size() != (basis_degree+1) )
            binomial_coeff.resize( basis_degree+1 ) ;

        if ( binomial_coeff_bis.size() != (N+1) )
            binomial_coeff_bis.resize( N+1 ) ;

       // Construction of the exponenatial term for bernstein basis B^N and B^(N-1) (useful for derivative)
        for (size_t i = 0; i <= basis_degree ; i++)
        {
            size_t j = basis_degree - i;
            binomial_coeff[i] = binomial_coeff_fx( basis_degree , i );
            power_cache[2*i]    = scaling_x *binomial_coeff[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j);
            power_cache[2*i+1]  = scaling_y *binomial_coeff[i]*iexp_pow(by0, i)*iexp_pow(by1, j);

            if( i < basis_degree )
            {
                size_t j_bis = N - i;
                binomial_coeff_bis[i] = binomial_coeff_fx( N , i );
                power_cache_bis[2*i] = scaling_x_bis * binomial_coeff_bis[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j_bis);
                power_cache_bis[2*i+1] = scaling_y_bis * binomial_coeff_bis[i]*iexp_pow(by0, i)*iexp_pow(by1, j_bis);

            }

        }
#endif

        size_t pos = 0;
        // Case FEM degree = 0
        if (basis_degree == 0){
            VT zero = 0.0;
            ret(pos,0) =  zero;
            ret(pos,1) = zero;
            pos++;
        }
        // Case FEM degree = 1
        else if(basis_degree == 1){
            VT coeffx = 1.0/(max_x - min_x);
            VT coeffy = 1.0/(max_y - min_y);
            //std::cout<<"min x "<<min_x<<"max x "<<max_x<<"min y "<<min_y<<"max y "<<max_y<<std::endl;
            auto px = 0.0 , py = 0.0 ;
            int j = 1; // useful for the sign of the derivative in y
            // Pick just vertices
            for (int pow_y = 0; pow_y <= basis_degree; pow_y +=basis_degree){
                if( pow_y == 0 ) // bottom
                {
                    int i = 1;  // useful for the sign of the derivative in x
                    for (int pow_x = 0; pow_x <= basis_degree; pow_x+=basis_degree){
        #ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
        #else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;
                    py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
        #endif


                    ret(pos,0) =  py * coeffx * pow(-1,i);
                    ret(pos,1) = px * coeffy * pow(-1,j);
                    //std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                    pos++;
                    i++;
                    }

                }
                else{
                    int i = 2;
                    for (int pow_x = basis_degree; pow_x >= 0; pow_x-=basis_degree){
        #ifdef POWER_CACHE
                    auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
        #else
                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                    px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;
                    py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
        #endif

                    ret(pos,0) =  py * coeffx * pow(-1,i);
                    ret(pos,1) = px * coeffy * pow(-1,j);
                  //  std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                    pos++;
                    i--;
                    }
                }
                j++;
            }

        }

        else{
            // if degree FEM >= 2
            //std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree ;
            int starter = 0;
            int internal_bases = basis_degree + 1 ;

            while(internal_bases > 1) // for each layour of internal node
            {
                for (int pow_y = starter; pow_y <= N_partial ; pow_y +=(N_partial-starter)){

                    if(pow_y == starter ) // Bottom side
                    {

                        for (int pow_x = starter; pow_x <= N_partial; pow_x+=(N_partial-starter)){

                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative

#ifdef POWER_CACHE
                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            else
                                auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                            if ( pow_y == 0 )
                                auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            else
                                auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

#else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;

                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = -coeff_dx * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * (px_bis1 -px_bis0);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                               // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = -coeff_dy *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            }
                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * ( py_bis1 - py_bis0 );
                            //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;
                            ret(pos,0) = dx*py;
                            ret(pos,1) = px*dy;
                            pos++;


                        }
                    }
                    else{ // Top side
                        for (int pow_x = N_partial; pow_x >= starter; pow_x-=(N_partial-starter)){
                            VT ix_bis = pow_x-1;
                            VT iy_bis = pow_y-1;

#ifdef POWER_CACHE
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            if ( pow_x == 0 )
                                auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            else
                                auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                            if ( pow_y == 0 )
                                auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            else
                                auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
#else

                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;

                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;

                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = -coeff_dx * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_dx * (px_bis1 -px_bis0);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                               // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = -coeff_dy *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            }
                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_dy * ( py_bis1 - py_bis0 );
                            //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                            }


#endif

                            ret(pos,0) = dx*py;
                            ret(pos,1) = px*dy;
                            pos++;


                        } // loop for top side vertices




                    } // else bottom-top side

                } // end loop for vertices


                // face 0 (BOTTOM)
                for (size_t pow_x = starter + 1 ; pow_x <= N_partial - 1 ; pow_x++)
                {
                    size_t pow_y = starter;

                    VT ix_bis = pow_x-1;
                    VT iy_bis = pow_y-1;

#ifdef POWER_CACHE
                    auto px = power_cache[2*pow_x];
                    auto py = power_cache[2*pow_y+1];
                    if ( pow_x == 0 )
                        auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    else if ( pow_x == basis_degree )
                        auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    else
                        auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                    if ( pow_y == 0 )
                        auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    else if ( pow_y == basis_degree )
                        auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    else
                        auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                    //std::cout<<"j_x Face0 "<<j_x<<std::endl;
                    //std::cout<<"coeff_n_x Face0 "<<coeff_n_x<<std::endl;
                    //std::cout<<"scaling_x Face0 "<<scaling_x<<std::endl;
                    //std::cout<<"pow_x Face0 "<<pow_x<<std::endl;
                    //std::cout<<"bx0 Face0 "<<bx0<<std::endl;
                    //std::cout<<"bx1 Face0 "<<bx1<<std::endl;


                    // DERIVATIVES
                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0 , dy = 0.0 ;

                    if ( pow_x == 0 ){
                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0 ;
                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    }
                    else if ( pow_x == basis_degree ){
                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1 ;
                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    }
                    else{
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 -px_bis0);
                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if ( pow_y == 0 ){
                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy *  py_bis0 ;
                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    }
                    else if ( pow_y == basis_degree ){
                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1  ;
                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    }
                    else{
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * ( py_bis1 - py_bis0 );
                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }

#endif

                    ret(pos,0) = dx*py;
                    ret(pos,1) = px*dy;
                    pos++;

                }

                // face 1 (RIGHT)
                for (size_t pow_y = starter + 1; pow_y <= N_partial - 1 ; pow_y++)
                {
                    size_t pow_x = N_partial;
                    VT ix_bis = pow_x-1;
                    VT iy_bis = pow_y-1;

#ifdef POWER_CACHE
                    auto px = power_cache[2*pow_x];
                    auto py = power_cache[2*pow_y+1];
                    if ( pow_x == 0 )
                        auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    else if ( pow_x == basis_degree )
                        auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    else
                        auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                    if ( pow_y == 0 )
                        auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    else if ( pow_y == basis_degree )
                        auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    else
                        auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                    // DERIVATIVES
                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0 , dy = 0.0 ;

                    if ( pow_x == 0 ){
                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0 ;
                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    }
                    else if ( pow_x == basis_degree ){
                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1 ;
                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    }
                    else{
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 -px_bis0);
                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if ( pow_y == 0 ){
                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy *  py_bis0 ;
                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    }
                    else if ( pow_y == basis_degree ){
                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1  ;
                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    }
                    else{
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * ( py_bis1 - py_bis0 );
                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos,0) = dx*py;
                    ret(pos,1) = px*dy;
                    pos++;
                }

                // face 2 (TOP)
                for (size_t pow_x = N_partial - 1; pow_x >= starter + 1 ; pow_x--)
                {
                    size_t pow_y = N_partial;
                    VT ix_bis = pow_x-1;
                    VT iy_bis = pow_y-1;

#ifdef POWER_CACHE
                    auto px = power_cache[2*pow_x];
                    auto py = power_cache[2*pow_y+1];
                    if ( pow_x == 0 )
                        auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    else if ( pow_x == basis_degree )
                        auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    else
                        auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                    if ( pow_y == 0 )
                        auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    else if ( pow_y == basis_degree )
                        auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    else
                        auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                    // DERIVATIVES
                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0 , dy = 0.0 ;

                    if ( pow_x == 0 ){
                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0 ;
                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    }
                    else if ( pow_x == basis_degree ){
                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1 ;
                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    }
                    else{
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 -px_bis0);
                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if ( pow_y == 0 ){
                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy *  py_bis0 ;
                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    }
                    else if ( pow_y == basis_degree ){
                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1  ;
                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    }
                    else{
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * ( py_bis1 - py_bis0 );
                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos,0) = dx*py;
                    ret(pos,1) = px*dy;
                    pos++;
                }


                // face 3 (LEFT)

                for (size_t pow_y = N_partial - 1; pow_y >= starter + 1 ; pow_y--)
                {
                    size_t pow_x = starter;
                    VT ix_bis = pow_x-1;
                    VT iy_bis = pow_y-1;

#ifdef POWER_CACHE
                    auto px = power_cache[2*pow_x];
                    auto py = power_cache[2*pow_y+1];
                    if ( pow_x == 0 )
                        auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    else if ( pow_x == basis_degree )
                        auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    else
                        auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                    if ( pow_y == 0 )
                        auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    else if ( pow_y == basis_degree )
                        auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    else
                        auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
#else

                    size_t j_x = basis_degree - pow_x;
                    size_t j_y = basis_degree - pow_y;

                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                    // DERIVATIVES
                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0 , dy = 0.0 ;

                    if ( pow_x == 0 ){
                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0 ;
                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    }
                    else if ( pow_x == basis_degree ){
                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1 ;
                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    }
                    else{
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 -px_bis0);
                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if ( pow_y == 0 ){
                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy *  py_bis0 ;
                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    }
                    else if ( pow_y == basis_degree ){
                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1  ;
                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    }
                    else{
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * ( py_bis1 - py_bis0 );
                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


#endif

                    ret(pos,0) = dx*py;
                    ret(pos,1) = px*dy;
                    pos++;
                }

                N_partial--;
                starter++;
                internal_bases -= 2;

            }

            // for B_k, with k even, I.E. odd number of bases: there is a central one.
            if( basis_degree % 2 == 0 )
            {
                //  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                assert( N_partial == starter );
                size_t pow_x = starter ;
                size_t pow_y = starter ;
                VT ix_bis = pow_x-1;
                VT iy_bis = pow_y-1;

#ifdef POWER_CACHE
                auto px = power_cache[2*pow_x];
                auto py = power_cache[2*pow_y+1];
                if ( pow_x == 0 )
                    auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                else if ( pow_x == basis_degree )
                    auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                else
                    auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                if ( pow_y == 0 )
                    auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                else if ( pow_y == basis_degree )
                    auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                else
                    auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
#else

                size_t j_x = basis_degree - pow_x;
                size_t j_y = basis_degree - pow_y;

                auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                // DERIVATIVES
                //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0 , dy = 0.0 ;

                if ( pow_x == 0 ){
                    //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = -coeff_dx * px_bis0 ;
                    //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                }
                else if ( pow_x == basis_degree ){
                    //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * px_bis1 ;
                    //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                }
                else{
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * (px_bis1 -px_bis0);
                    //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }

                if ( pow_y == 0 ){
                    //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                   // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                    dy = -coeff_dy *  py_bis0 ;
                    //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                }
                else if ( pow_y == basis_degree ){
                    //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_dy * py_bis1  ;
                    //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                }
                else{
                    size_t j_y_bis0 = N - pow_y;
                    auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                    size_t j_y_bis1 = N - iy_bis;
                    auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                    dy = coeff_dy * ( py_bis1 - py_bis0 );
                //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                }


#endif

                ret(pos,0) = dx*py;
                ret(pos,1) = px*dy;
                pos++;
            }
        }

          //  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
            assert(pos == basis_size);

            return ret;


    }




    // Same approach of eval
        Matrix<VT, Dynamic, 1>
        eval_derivative_xy(const point_type& pt)
        {
            Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

            auto bx0 = pt.x() - min_x ;
            auto bx1 = max_x - pt.x() ;
            auto by0 = pt.y() - min_y ;
            auto by1 = max_y - pt.y() ;
            //The stuff below should be in the constructor, but gradient is used less times than eval.
            auto N = basis_degree - 1 ;
            auto coeff_dx = basis_degree/(max_x - min_x); // n/(b-a)
            auto coeff_dy = basis_degree/(max_y - min_y);
            auto scaling_x_bis = 1.0/(pow(max_x - min_x,N) ); // 1/(b-a)^(n-1)
            auto scaling_y_bis = 1.0/(pow(max_y - min_y,N) );
            //std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

    #ifdef POWER_CACHE
            if ( power_cache.size() != (basis_degree+1)*2 )
              power_cache.resize( (basis_degree+1)*2) ;

            if ( power_cache_bis.size() != (N+1)*2 )
                power_cache_bis.resize( (N+1)*2) ;

            if ( binomial_coeff.size() != (basis_degree+1) )
                binomial_coeff.resize( basis_degree+1 ) ;

            if ( binomial_coeff_bis.size() != (N+1) )
                binomial_coeff_bis.resize( N+1 ) ;

           // Construction of the exponenatial term for bernstein basis B^N and B^(N-1) (useful for derivative)
            for (size_t i = 0; i <= basis_degree ; i++)
            {
                size_t j = basis_degree - i;
                binomial_coeff[i] = binomial_coeff_fx( basis_degree , i );
                power_cache[2*i]    = scaling_x *binomial_coeff[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j);
                power_cache[2*i+1]  = scaling_y *binomial_coeff[i]*iexp_pow(by0, i)*iexp_pow(by1, j);

                if( i < basis_degree )
                {
                    size_t j_bis = N - i;
                    binomial_coeff_bis[i] = binomial_coeff_fx( N , i );
                    power_cache_bis[2*i] = scaling_x_bis * binomial_coeff_bis[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j_bis);
                    power_cache_bis[2*i+1] = scaling_y_bis * binomial_coeff_bis[i]*iexp_pow(by0, i)*iexp_pow(by1, j_bis);

                }

            }
    #endif

            size_t pos = 0;
            // Case FEM degree = 0
            if (basis_degree == 0){
                VT zero = 0.0;
                ret(pos) =  zero;

                pos++;
            }
            // Case FEM degree = 1
            else if(basis_degree == 1){
                VT coeffx = 1.0/(max_x - min_x);
                VT coeffy = 1.0/(max_y - min_y);
                //std::cout<<"min x "<<min_x<<"max x "<<max_x<<"min y "<<min_y<<"max y "<<max_y<<std::endl;
                auto px = 0.0 , py = 0.0 ;
                int j = 1; // useful for the sign of the derivative in y
                // Pick just vertices
                for (int pow_y = 0; pow_y <= basis_degree; pow_y +=basis_degree){
                    if( pow_y == 0 ) // bottom
                    {
                        int i = 1;  // useful for the sign of the derivative in x
                        for (int pow_x = 0; pow_x <= basis_degree; pow_x+=basis_degree){
            #ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
            #else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;
                        py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
            #endif


                        ret(pos) =  coeffy * pow(-1,j) * coeffx * pow(-1,i);
                        //ret(pos,1) = px * coeffy * pow(-1,j);
                        //std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                        pos++;
                        i++;
                        }

                    }
                    else{
                        int i = 2;
                        for (int pow_x = basis_degree; pow_x >= 0; pow_x-=basis_degree){
            #ifdef POWER_CACHE
                        auto bv = scaling_x * power_cache[2*pow_x] * scaling_y * power_cache[2*pow_y+1];
            #else
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;

                        auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                        px = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;
                        py = scaling_y * coeff_n_y * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y) ;
            #endif

                        ret(pos) =  coeffy * pow(-1,j) * coeffx * pow(-1,i);

                      //  std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                        pos++;
                        i--;
                        }
                    }
                    j++;
                }

            }

            else{
                // if degree FEM >= 2
                //std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                int N_partial = basis_degree ;
                int starter = 0;
                int internal_bases = basis_degree + 1 ;

                while(internal_bases > 1) // for each layour of internal node
                {
                    for (int pow_y = starter; pow_y <= N_partial ; pow_y +=(N_partial-starter)){

                        if(pow_y == starter ) // Bottom side
                        {

                            for (int pow_x = starter; pow_x <= N_partial; pow_x+=(N_partial-starter)){

                                VT ix_bis = pow_x-1; // element i-1 for derivative
                                VT iy_bis = pow_y-1; // element i-1 for derivative

    #ifdef POWER_CACHE
                                std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                auto px = power_cache[2*pow_x];
                                auto py = power_cache[2*pow_y+1];
                                //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                if ( pow_x == 0 )
                                    auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                                else if ( pow_x == basis_degree )
                                    auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                else
                                    auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                                if ( pow_y == 0 )
                                    auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                                else if ( pow_y == basis_degree )
                                    auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                else
                                    auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
                                //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

    #else

                                //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                //size_t j_x = basis_degree - pow_x;
                                //size_t j_y = basis_degree - pow_y;
                                //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                //std::cout<<"px PRE "<<px<<std::endl;

                                // DERIVATIVES
                                //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                                VT dx = 0.0 , dy = 0.0 ;

                                if ( pow_x == 0 ){
                                    //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = -coeff_dx * px_bis0 ;
                                    //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                }
                                else if ( pow_x == basis_degree ){
                                    //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * px_bis1 ;
                                    //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                }
                                else{
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * (px_bis1 -px_bis0);
                                    //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if ( pow_y == 0 ){
                                    //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                   // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = -coeff_dy *  py_bis0 ;
                                    //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                }
                                else if ( pow_y == basis_degree ){
                                    //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * py_bis1  ;
                                    //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                }
                                else{
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * ( py_bis1 - py_bis0 );
                                //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


    #endif
                                //std::cout<<"pos "<<pos<<std::endl;
                                //std::cout<<"dx "<<dx<<std::endl;
                                //std::cout<<"dy "<<dy<<std::endl;
                                //std::cout<<"px "<<px<<std::endl;
                                //std::cout<<"py "<<py<<std::endl;
                                ret(pos) = dx*dy;
                                //ret(pos,1) = px*dy;
                                pos++;


                            }
                        }
                        else{ // Top side
                            for (int pow_x = N_partial; pow_x >= starter; pow_x-=(N_partial-starter)){
                                VT ix_bis = pow_x-1;
                                VT iy_bis = pow_y-1;

    #ifdef POWER_CACHE
                                auto px = power_cache[2*pow_x];
                                auto py = power_cache[2*pow_y+1];
                                if ( pow_x == 0 )
                                    auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                                else if ( pow_x == basis_degree )
                                    auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                else
                                    auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                                if ( pow_y == 0 )
                                    auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                                else if ( pow_y == basis_degree )
                                    auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                else
                                    auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
    #else

                                //size_t j_x = basis_degree - pow_x;
                                //size_t j_y = basis_degree - pow_y;

                                //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                                //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                                // DERIVATIVES
                                //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                                VT dx = 0.0 , dy = 0.0 ;

                                if ( pow_x == 0 ){
                                    //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                    dx = -coeff_dx * px_bis0 ;
                                    //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                }
                                else if ( pow_x == basis_degree ){
                                    //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * px_bis1 ;
                                    //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                }
                                else{
                                    size_t j_x_bis0 = N - pow_x;
                                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                                    size_t j_x_bis1 = N - ix_bis;
                                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                    dx = coeff_dx * (px_bis1 -px_bis0);
                                    //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                }

                                if ( pow_y == 0 ){
                                    //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                   // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                    dy = -coeff_dy *  py_bis0 ;
                                    //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                }
                                else if ( pow_y == basis_degree ){
                                    //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * py_bis1  ;
                                    //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                }
                                else{
                                    size_t j_y_bis0 = N - pow_y;
                                    auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                    auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                                    size_t j_y_bis1 = N - iy_bis;
                                    auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                    auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                    dy = coeff_dy * ( py_bis1 - py_bis0 );
                                //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                }


    #endif

                                ret(pos) = dx*dy;
                                //ret(pos,1) = px*dy;
                                pos++;


                            } // loop for top side vertices




                        } // else bottom-top side

                    } // end loop for vertices


                    // face 0 (BOTTOM)
                    for (size_t pow_x = starter + 1 ; pow_x <= N_partial - 1 ; pow_x++)
                    {
                        size_t pow_y = starter;

                        VT ix_bis = pow_x-1;
                        VT iy_bis = pow_y-1;

    #ifdef POWER_CACHE
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        if ( pow_x == 0 )
                            auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        else
                            auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                        if ( pow_y == 0 )
                            auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        else
                            auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
    #else

                        //size_t j_x = basis_degree - pow_x;
                        //size_t j_y = basis_degree - pow_y;

                        //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                        //std::cout<<"j_x Face0 "<<j_x<<std::endl;
                        //std::cout<<"coeff_n_x Face0 "<<coeff_n_x<<std::endl;
                        //std::cout<<"scaling_x Face0 "<<scaling_x<<std::endl;
                        //std::cout<<"pow_x Face0 "<<pow_x<<std::endl;
                        //std::cout<<"bx0 Face0 "<<bx0<<std::endl;
                        //std::cout<<"bx1 Face0 "<<bx1<<std::endl;


                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        }
                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 -px_bis0);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                           // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        }
                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }
                        else{
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * ( py_bis1 - py_bis0 );
                        //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }

    #endif

                        ret(pos) = dx*dy;
                        //ret(pos,1) = px*dy;
                        pos++;

                    }

                    // face 1 (RIGHT)
                    for (size_t pow_y = starter + 1; pow_y <= N_partial - 1 ; pow_y++)
                    {
                        size_t pow_x = N_partial;
                        VT ix_bis = pow_x-1;
                        VT iy_bis = pow_y-1;

    #ifdef POWER_CACHE
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        if ( pow_x == 0 )
                            auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        else
                            auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                        if ( pow_y == 0 )
                            auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        else
                            auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
    #else

                        //size_t j_x = basis_degree - pow_x;
                        //size_t j_y = basis_degree - pow_y;

                        //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        }
                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 -px_bis0);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                           // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        }
                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }
                        else{
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * ( py_bis1 - py_bis0 );
                        //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


    #endif

                        ret(pos) = dx*dy;
                        //ret(pos,1) = px*dy;
                        pos++;
                    }

                    // face 2 (TOP)
                    for (size_t pow_x = N_partial - 1; pow_x >= starter + 1 ; pow_x--)
                    {
                        size_t pow_y = N_partial;
                        VT ix_bis = pow_x-1;
                        VT iy_bis = pow_y-1;

    #ifdef POWER_CACHE
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        if ( pow_x == 0 )
                            auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        else
                            auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                        if ( pow_y == 0 )
                            auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        else
                            auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
    #else

                        //size_t j_x = basis_degree - pow_x;
                        //size_t j_y = basis_degree - pow_y;

                        //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        }
                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 -px_bis0);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                           // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        }
                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }
                        else{
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * ( py_bis1 - py_bis0 );
                        //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


    #endif

                        ret(pos) = dx*dy;
                        //ret(pos,1) = px*dy;
                        pos++;
                    }


                    // face 3 (LEFT)

                    for (size_t pow_y = N_partial - 1; pow_y >= starter + 1 ; pow_y--)
                    {
                        size_t pow_x = starter;
                        VT ix_bis = pow_x-1;
                        VT iy_bis = pow_y-1;

    #ifdef POWER_CACHE
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        if ( pow_x == 0 )
                            auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        else
                            auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                        if ( pow_y == 0 )
                            auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        else
                            auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
    #else

                        //size_t j_x = basis_degree - pow_x;
                        //size_t j_y = basis_degree - pow_y;

                        //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                        //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = -coeff_dx * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                        }
                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_dx * (px_bis1 -px_bis0);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }

                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                           // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = -coeff_dy *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                        }
                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }
                        else{
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_dy * ( py_bis1 - py_bis0 );
                        //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                        }


    #endif

                        ret(pos) = dx*dy;
                        //ret(pos,1) = px*dy;
                        pos++;
                    }

                    N_partial--;
                    starter++;
                    internal_bases -= 2;

                }

                // for B_k, with k even, I.E. odd number of bases: there is a central one.
                if( basis_degree % 2 == 0 )
                {
                    //  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                    assert( N_partial == starter );
                    size_t pow_x = starter ;
                    size_t pow_y = starter ;
                    VT ix_bis = pow_x-1;
                    VT iy_bis = pow_y-1;

    #ifdef POWER_CACHE
                    auto px = power_cache[2*pow_x];
                    auto py = power_cache[2*pow_y+1];
                    if ( pow_x == 0 )
                        auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                    else if ( pow_x == basis_degree )
                        auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    else
                        auto dx = coeff_dx*( power_cache_bis[2*ix_bis] - power_cache_bis[2*pow_x] );

                    if ( pow_y == 0 )
                        auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                    else if ( pow_y == basis_degree )
                        auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    else
                        auto dy = coeff_dy*( power_cache_bis[2*iy_bis+1] - power_cache_bis[2*pow_y+1] );
    #else

                    //size_t j_x = basis_degree - pow_x;
                    //size_t j_y = basis_degree - pow_y;

                    //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                    //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);

                    //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                    //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);

                    // DERIVATIVES
                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                    VT dx = 0.0 , dy = 0.0 ;

                    if ( pow_x == 0 ){
                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                        dx = -coeff_dx * px_bis0 ;
                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                    }
                    else if ( pow_x == basis_degree ){
                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * px_bis1 ;
                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                    }
                    else{
                        size_t j_x_bis0 = N - pow_x;
                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                        size_t j_x_bis1 = N - ix_bis;
                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                        dx = coeff_dx * (px_bis1 -px_bis0);
                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                    }

                    if ( pow_y == 0 ){
                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                        dy = -coeff_dy *  py_bis0 ;
                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                    }
                    else if ( pow_y == basis_degree ){
                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * py_bis1  ;
                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                    }
                    else{
                        size_t j_y_bis0 = N - pow_y;
                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);

                        size_t j_y_bis1 = N - iy_bis;
                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                        dy = coeff_dy * ( py_bis1 - py_bis0 );
                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                    }


    #endif

                    ret(pos) = dx*dy;
                    //ret(pos,1) = px*dy;
                    pos++;
                }
            }

              //  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
                assert(pos == basis_size);

                return ret;


        }




    // Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_divergence(const point_type& pt)
    {
                Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

                auto bx0 = pt.x() - min_x ;
                auto bx1 = max_x - pt.x() ;
                auto by0 = pt.y() - min_y ;
                auto by1 = max_y - pt.y() ;
                //The stuff below should be in the constructor, but gradient is used less times than eval.
                auto N = basis_degree - 2 ;
                auto coeff_d2x = basis_degree*(basis_degree-1)/((max_x - min_x)*(max_x - min_x));
                auto coeff_d2y = basis_degree*(basis_degree-1)/((max_y - min_y)*(max_y - min_y));
                auto scaling_x_bis = 1.0/(pow(max_x - min_x,N) ); // 1/(b-a)^(n-1)
                auto scaling_y_bis = 1.0/(pow(max_y - min_y,N) );
                //std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

        #ifdef POWER_CACHE
                if ( power_cache.size() != (basis_degree+1)*2 )
                  power_cache.resize( (basis_degree+1)*2) ;

                if ( power_cache_bis.size() != (N+1)*2 )
                    power_cache_bis.resize( (N+1)*2) ;

                if ( binomial_coeff.size() != (basis_degree+1) )
                    binomial_coeff.resize( basis_degree+1 ) ;

                if ( binomial_coeff_bis.size() != (N+1) )
                    binomial_coeff_bis.resize( N+1 ) ;

               // Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
                for (size_t i = 0; i <= basis_degree ; i++)
                {
                    size_t j = basis_degree - i;
                    binomial_coeff[i] = binomial_coeff_fx( basis_degree , i );
                    power_cache[2*i]    = scaling_x *binomial_coeff[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j);
                    power_cache[2*i+1]  = scaling_y *binomial_coeff[i]*iexp_pow(by0, i)*iexp_pow(by1, j);

                    if( i < basis_degree - 1 )
                    {
                        size_t j_bis = N - i;
                        binomial_coeff_bis[i] = binomial_coeff_fx( N , i );
                        power_cache_bis[2*i] = scaling_x_bis * binomial_coeff_bis[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j_bis);
                        power_cache_bis[2*i+1] = scaling_y_bis * binomial_coeff_bis[i]*iexp_pow(by0, i)*iexp_pow(by1, j_bis);

                    }

                }
        #endif

                size_t pos = 0;
                // Case FEM degree = 0
                if (basis_degree == 0 || basis_degree == 1){
                    VT zero = 0.0;
                    while(pos < basis_size){
                        ret(pos) =  zero;
                        pos++;
                    }
                }
                else{
                    // if degree FEM >= 2
                    //std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                    int N_partial = basis_degree ;
                    int starter = 0;
                    int internal_bases = basis_degree + 1 ;

                    while(internal_bases > 1) // for each layout of internal node
                    {
                        for (int pow_y = starter; pow_y <= N_partial ; pow_y +=(N_partial-starter)){

                            if(pow_y == starter ) // Bottom side
                            {

                                for (int pow_x = starter; pow_x <= N_partial; pow_x+=(N_partial-starter))
                                {

                                    VT ix_bis = pow_x-1; // element i-1 for derivative
                                    VT iy_bis = pow_y-1; // element i-1 for derivative
                                    VT ix2_bis = pow_x-2; // element i-2 for derivative
                                    VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE
                                    std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                    auto px = power_cache[2*pow_x];
                                    auto py = power_cache[2*pow_y+1];
                                    //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                    if ( pow_x == 0 )
                                        auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                                    else if ( pow_x == basis_degree )
                                        auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                                    else if ( pow_x == 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                                    else if ( pow_x == basis_degree - 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                                    else
                                        auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );

                                    if ( pow_y == 0 )
                                        auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                                    else if ( pow_y == basis_degree )
                                        auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                                    else if ( pow_y == 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else if ( pow_y == basis_degree - 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else
                                        auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                                    //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

        #else

                                    //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                    size_t j_x = basis_degree - pow_x;
                                    size_t j_y = basis_degree - pow_y;
                                    //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                    //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                    //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                    //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                    //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                    //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                    //std::cout<<"px PRE "<<px<<std::endl;

                                    // DERIVATIVES
                                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                    VT dx = 0.0 , dy = 0.0 ;

                                    if ( pow_x == 0 ){
                                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        dx = coeff_d2x * px_bis0 ;
                                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                    }
                                    else if ( pow_x == basis_degree ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * px_bis1 ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_x == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }

                                    else if ( pow_x == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - ix_bis;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        size_t j_x_bis2 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                        dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                    }

                                    if ( pow_y == 0 ){
                                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                        dy = coeff_d2y *  py_bis0 ;
                                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                    }
                                    else if ( pow_y == basis_degree ){
                                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * py_bis1  ;
                                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                    }
                                    else if ( pow_y == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_y == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - iy_bis;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        size_t j_y_bis2 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                        dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );
                                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                    }


        #endif
                                    //std::cout<<"pos "<<pos<<std::endl;
                                    //std::cout<<"dx "<<dx<<std::endl;
                                    //std::cout<<"dy "<<dy<<std::endl;
                                    //std::cout<<"px "<<px<<std::endl;
                                    //std::cout<<"py "<<py<<std::endl;
                                    ret(pos) = dx*py + px*dy;
                                    pos++;


                                }
                            }
                            else{ // Top side
                                for (int pow_x = N_partial; pow_x >= starter; pow_x-=(N_partial-starter))
                                {

                                    VT ix_bis = pow_x-1; // element i-1 for derivative
                                    VT iy_bis = pow_y-1; // element i-1 for derivative
                                    VT ix2_bis = pow_x-2; // element i-2 for derivative
                                    VT iy2_bis = pow_y-2; // element i-2 for derivative

            #ifdef POWER_CACHE

                                    std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                    auto px = power_cache[2*pow_x];
                                    auto py = power_cache[2*pow_y+1];
                                    //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                    if ( pow_x == 0 )
                                        auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                                    else if ( pow_x == basis_degree )
                                        auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                                    else if ( pow_x == 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                                    else if ( pow_x == basis_degree - 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                                    else
                                        auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                                    if ( pow_y == 0 )
                                        auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                                    else if ( pow_y == basis_degree )
                                        auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                                    else if ( pow_y == 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else if ( pow_y == basis_degree - 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else
                                        auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                                    //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                                    //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                    size_t j_x = basis_degree - pow_x;
                                    size_t j_y = basis_degree - pow_y;
                                    //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                    //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                    //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                    //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                    //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                    //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                    //std::cout<<"px PRE "<<px<<std::endl;

                                    // DERIVATIVES
                                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                    VT dx = 0.0 , dy = 0.0 ;

                                    if ( pow_x == 0 ){

                                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        dx = coeff_d2x * px_bis0 ;
                                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                    }
                                    else if ( pow_x == basis_degree ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * px_bis1 ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_x == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }


                                    else if ( pow_x == basis_degree - 1 ){

                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - ix_bis;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        size_t j_x_bis2 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                        dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                    }


                                    if ( pow_y == 0 ){
                                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                        dy = coeff_d2y *  py_bis0 ;
                                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                    }
                                    else if ( pow_y == basis_degree ){
                                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * py_bis1  ;
                                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                    }
                                    else if ( pow_y == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_y == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - iy_bis;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        size_t j_y_bis2 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                        dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                                    }

            #endif
                                    //std::cout<<"pos "<<pos<<std::endl;
                                    //std::cout<<"dx "<<dx<<std::endl;
                                    //std::cout<<"dy "<<dy<<std::endl;
                                    //std::cout<<"px "<<px<<std::endl;
                                    //std::cout<<"py "<<py<<std::endl;
                                    ret(pos) = dx*py + px*dy;
                                    pos++;




                                } // loop for top side vertices




                            } // else bottom-top side

                        } // end loop for vertices


                        // face 0 (BOTTOM)
                        for (size_t pow_x = starter + 1 ; pow_x <= N_partial - 1 ; pow_x++)
                        {
                            size_t pow_y = starter;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

    #ifdef POWER_CACHE

                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;

                            if ( pow_x == 0 ){

                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }



                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            }
                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py + px*dy;
                            pos++;




                        }

                        // face 1 (RIGHT) size_t pow_x = N_partial;
                        for (size_t pow_y = starter + 1; pow_y <= N_partial - 1 ; pow_y++)
                        {
                            size_t pow_x = N_partial;
                            VT ix_bis = pow_x-1; // element i-1 for derivative

                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else
                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py + px*dy;
                            pos++;
                        }

                        // face 2 (TOP)
                        for (size_t pow_x = N_partial - 1; pow_x >= starter + 1 ; pow_x--)
                        {
                            size_t pow_y = N_partial;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE

                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            //DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            }

                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }

                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif

                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py + px*dy;
                            pos++;
                        }


                        // face 3 (LEFT)

                        for (size_t pow_y = N_partial - 1; pow_y >= starter + 1 ; pow_y--)
                        {
                            size_t pow_x = starter;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            }

                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }

                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

                #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py + px*dy;
                            pos++;
                        }

                        N_partial--;
                        starter++;
                        internal_bases -= 2;

                    }

                    // for B_k, with k even, I.E. odd number of bases: there is a central one.
                    if( basis_degree % 2 == 0 )
                    {
                        //  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                        assert( N_partial == starter );
                        size_t pow_x = starter ;
                        size_t pow_y = starter ;

                        VT ix_bis = pow_x-1; // element i-1 for derivative
                        VT iy_bis = pow_y-1; // element i-1 for derivative
                        VT ix2_bis = pow_x-2; // element i-2 for derivative
                        VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                        std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        //std::cout<<"px POWER_CACHE "<<px<<std::endl;

                        if ( pow_x == 0 )
                            auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                        else if ( pow_x == 1 )
                            auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                        else if ( pow_x == basis_degree - 1 )
                            auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                        else
                            auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );

                        if ( pow_y == 0 )
                            auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                        else if ( pow_y == 1 )
                            auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                        else if ( pow_y == basis_degree - 1 )
                            auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                        else
                            auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                        //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

    #else
                        //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
                        //std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                        //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                        //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                        //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                        //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                        //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                        //std::cout<<"px PRE "<<px<<std::endl;

                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        }

                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else if ( pow_x == 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else if ( pow_x == basis_degree - 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }


                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        }

                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }

                        else if ( pow_y == 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else if ( pow_y == basis_degree - 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else{
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                        }

    #endif
                        //std::cout<<"pos "<<pos<<std::endl;
                        //std::cout<<"dx "<<dx<<std::endl;
                        //std::cout<<"dy "<<dy<<std::endl;
                        //std::cout<<"px "<<px<<std::endl;
                        //std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx*py + px*dy;
                        pos++;



                    }
                }

                  //  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
                    assert(pos == basis_size);

                    return ret;


    }

    // Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_double_derivative_x(const point_type& pt)
    {
                Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

                auto bx0 = pt.x() - min_x ;
                auto bx1 = max_x - pt.x() ;
                auto by0 = pt.y() - min_y ;
                auto by1 = max_y - pt.y() ;
                //The stuff below should be in the constructor, but gradient is used less times than eval.
                auto N = basis_degree - 2 ;
                auto coeff_d2x = basis_degree*(basis_degree-1)/((max_x - min_x)*(max_x - min_x));
                auto coeff_d2y = basis_degree*(basis_degree-1)/((max_y - min_y)*(max_y - min_y));
                auto scaling_x_bis = 1.0/(pow(max_x - min_x,N) ); // 1/(b-a)^(n-1)
                auto scaling_y_bis = 1.0/(pow(max_y - min_y,N) );
                //std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

        #ifdef POWER_CACHE
                if ( power_cache.size() != (basis_degree+1)*2 )
                  power_cache.resize( (basis_degree+1)*2) ;

                if ( power_cache_bis.size() != (N+1)*2 )
                    power_cache_bis.resize( (N+1)*2) ;

                if ( binomial_coeff.size() != (basis_degree+1) )
                    binomial_coeff.resize( basis_degree+1 ) ;

                if ( binomial_coeff_bis.size() != (N+1) )
                    binomial_coeff_bis.resize( N+1 ) ;

               // Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
                for (size_t i = 0; i <= basis_degree ; i++)
                {
                    size_t j = basis_degree - i;
                    binomial_coeff[i] = binomial_coeff_fx( basis_degree , i );
                    power_cache[2*i]    = scaling_x *binomial_coeff[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j);
                    power_cache[2*i+1]  = scaling_y *binomial_coeff[i]*iexp_pow(by0, i)*iexp_pow(by1, j);

                    if( i < basis_degree - 1 )
                    {
                        size_t j_bis = N - i;
                        binomial_coeff_bis[i] = binomial_coeff_fx( N , i );
                        power_cache_bis[2*i] = scaling_x_bis * binomial_coeff_bis[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j_bis);
                        power_cache_bis[2*i+1] = scaling_y_bis * binomial_coeff_bis[i]*iexp_pow(by0, i)*iexp_pow(by1, j_bis);

                    }

                }
        #endif

                size_t pos = 0;
                // Case FEM degree = 0
                if (basis_degree == 0 || basis_degree == 1){
                    VT zero = 0.0;
                    while(pos < basis_size){
                        ret(pos) =  zero;
                        pos++;
                    }
                }
                else{
                    // if degree FEM >= 2
                    //std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                    int N_partial = basis_degree ;
                    int starter = 0;
                    int internal_bases = basis_degree + 1 ;

                    while(internal_bases > 1) // for each layout of internal node
                    {
                        for (int pow_y = starter; pow_y <= N_partial ; pow_y +=(N_partial-starter)){

                            if(pow_y == starter ) // Bottom side
                            {

                                for (int pow_x = starter; pow_x <= N_partial; pow_x+=(N_partial-starter))
                                {

                                    VT ix_bis = pow_x-1; // element i-1 for derivative
                                    VT iy_bis = pow_y-1; // element i-1 for derivative
                                    VT ix2_bis = pow_x-2; // element i-2 for derivative
                                    VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE
                                    std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                    auto px = power_cache[2*pow_x];
                                    auto py = power_cache[2*pow_y+1];
                                    //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                    if ( pow_x == 0 )
                                        auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                                    else if ( pow_x == basis_degree )
                                        auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                                    else if ( pow_x == 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                                    else if ( pow_x == basis_degree - 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                                    else
                                        auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );

                                    if ( pow_y == 0 )
                                        auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                                    else if ( pow_y == basis_degree )
                                        auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                                    else if ( pow_y == 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else if ( pow_y == basis_degree - 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else
                                        auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                                    //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

        #else

                                    //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                    //size_t j_x = basis_degree - pow_x;
                                    size_t j_y = basis_degree - pow_y;
                                    //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                    //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                    //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                    //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                    //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                    //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                    //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                    //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                    //std::cout<<"px PRE "<<px<<std::endl;

                                    // DERIVATIVES
                                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                    VT dx = 0.0 , dy = 0.0 ;

                                    if ( pow_x == 0 ){
                                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        dx = coeff_d2x * px_bis0 ;
                                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                    }
                                    else if ( pow_x == basis_degree ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * px_bis1 ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_x == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }

                                    else if ( pow_x == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - ix_bis;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        size_t j_x_bis2 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                        dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                    }

                                    if ( pow_y == 0 ){
                                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                        dy = coeff_d2y *  py_bis0 ;
                                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                    }
                                    else if ( pow_y == basis_degree ){
                                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * py_bis1  ;
                                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                    }
                                    else if ( pow_y == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_y == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - iy_bis;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        size_t j_y_bis2 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                        dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );
                                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                    }


        #endif
                                    //std::cout<<"pos "<<pos<<std::endl;
                                    //std::cout<<"dx "<<dx<<std::endl;
                                    //std::cout<<"dy "<<dy<<std::endl;
                                    //std::cout<<"px "<<px<<std::endl;
                                    //std::cout<<"py "<<py<<std::endl;
                                    ret(pos) = dx*py ; //+ px*dy;
                                    pos++;


                                }
                            }
                            else{ // Top side
                                for (int pow_x = N_partial; pow_x >= starter; pow_x-=(N_partial-starter))
                                {

                                    VT ix_bis = pow_x-1; // element i-1 for derivative
                                    VT iy_bis = pow_y-1; // element i-1 for derivative
                                    VT ix2_bis = pow_x-2; // element i-2 for derivative
                                    VT iy2_bis = pow_y-2; // element i-2 for derivative

            #ifdef POWER_CACHE

                                    std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                    auto px = power_cache[2*pow_x];
                                    auto py = power_cache[2*pow_y+1];
                                    //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                    if ( pow_x == 0 )
                                        auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                                    else if ( pow_x == basis_degree )
                                        auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                                    else if ( pow_x == 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                                    else if ( pow_x == basis_degree - 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                                    else
                                        auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                                    if ( pow_y == 0 )
                                        auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                                    else if ( pow_y == basis_degree )
                                        auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                                    else if ( pow_y == 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else if ( pow_y == basis_degree - 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else
                                        auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                                    //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                                    //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                    //size_t j_x = basis_degree - pow_x;
                                    size_t j_y = basis_degree - pow_y;
                                    //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                    //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                    auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                    //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                    //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                    //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                    //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                    //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                    //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                    auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                    //std::cout<<"px PRE "<<px<<std::endl;

                                    // DERIVATIVES
                                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                    VT dx = 0.0 , dy = 0.0 ;

                                    if ( pow_x == 0 ){

                                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        dx = coeff_d2x * px_bis0 ;
                                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                    }
                                    else if ( pow_x == basis_degree ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * px_bis1 ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_x == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }


                                    else if ( pow_x == basis_degree - 1 ){

                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - ix_bis;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        size_t j_x_bis2 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                        dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                    }


                                    if ( pow_y == 0 ){
                                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                        dy = coeff_d2y *  py_bis0 ;
                                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                    }
                                    else if ( pow_y == basis_degree ){
                                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * py_bis1  ;
                                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                    }
                                    else if ( pow_y == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_y == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - iy_bis;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        size_t j_y_bis2 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                        dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                                    }

            #endif
                                    //std::cout<<"pos "<<pos<<std::endl;
                                    //std::cout<<"dx "<<dx<<std::endl;
                                    //std::cout<<"dy "<<dy<<std::endl;
                                    //std::cout<<"px "<<px<<std::endl;
                                    //std::cout<<"py "<<py<<std::endl;
                                    ret(pos) = dx*py ; // + px*dy;
                                    pos++;




                                } // loop for top side vertices




                            } // else bottom-top side

                        } // end loop for vertices


                        // face 0 (BOTTOM)
                        for (size_t pow_x = starter + 1 ; pow_x <= N_partial - 1 ; pow_x++)
                        {
                            size_t pow_y = starter;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

    #ifdef POWER_CACHE

                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            //size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;

                            if ( pow_x == 0 ){

                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }



                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            }
                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py ; // + px*dy;
                            pos++;




                        }

                        // face 1 (RIGHT) size_t pow_x = N_partial;
                        for (size_t pow_y = starter + 1; pow_y <= N_partial - 1 ; pow_y++)
                        {
                            size_t pow_x = N_partial;
                            VT ix_bis = pow_x-1; // element i-1 for derivative

                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else
                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            //size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py ; // + px*dy;
                            pos++;
                        }

                        // face 2 (TOP)
                        for (size_t pow_x = N_partial - 1; pow_x >= starter + 1 ; pow_x--)
                        {
                            size_t pow_y = N_partial;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE

                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            //size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            //DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            }

                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }

                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif

                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py ; // + px*dy;
                            pos++;
                        }


                        // face 3 (LEFT)

                        for (size_t pow_y = N_partial - 1; pow_y >= starter + 1 ; pow_y--)
                        {
                            size_t pow_x = starter;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            //size_t j_x = basis_degree - pow_x;
                            size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            }

                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }

                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

                #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = dx*py ; // + px*dy;
                            pos++;
                        }

                        N_partial--;
                        starter++;
                        internal_bases -= 2;

                    }

                    // for B_k, with k even, I.E. odd number of bases: there is a central one.
                    if( basis_degree % 2 == 0 )
                    {
                        //  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                        assert( N_partial == starter );
                        size_t pow_x = starter ;
                        size_t pow_y = starter ;

                        VT ix_bis = pow_x-1; // element i-1 for derivative
                        VT iy_bis = pow_y-1; // element i-1 for derivative
                        VT ix2_bis = pow_x-2; // element i-2 for derivative
                        VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                        std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        //std::cout<<"px POWER_CACHE "<<px<<std::endl;

                        if ( pow_x == 0 )
                            auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                        else if ( pow_x == 1 )
                            auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                        else if ( pow_x == basis_degree - 1 )
                            auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                        else
                            auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );

                        if ( pow_y == 0 )
                            auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                        else if ( pow_y == 1 )
                            auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                        else if ( pow_y == basis_degree - 1 )
                            auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                        else
                            auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                        //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

    #else
                        //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        //size_t j_x = basis_degree - pow_x;
                        size_t j_y = basis_degree - pow_y;
                        //std::cout<<"j_x PRE "<<j_x<<std::endl;
                        //auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                        //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                        //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                        //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                        //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                        //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        //auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                        //std::cout<<"px PRE "<<px<<std::endl;

                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        }

                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else if ( pow_x == 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else if ( pow_x == basis_degree - 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }


                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        }

                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }

                        else if ( pow_y == 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else if ( pow_y == basis_degree - 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else{
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                        }

    #endif
                        //std::cout<<"pos "<<pos<<std::endl;
                        //std::cout<<"dx "<<dx<<std::endl;
                        //std::cout<<"dy "<<dy<<std::endl;
                        //std::cout<<"px "<<px<<std::endl;
                        //std::cout<<"py "<<py<<std::endl;

                        ret(pos) = dx*py ; // + px*dy;
                        pos++;



                    }
                }

                  //  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
                    assert(pos == basis_size);

                    return ret;


    }

    // Same approach of eval
    Matrix<VT, Dynamic, 1>
    eval_double_derivative_y(const point_type& pt)
    {
                Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);

                auto bx0 = pt.x() - min_x ;
                auto bx1 = max_x - pt.x() ;
                auto by0 = pt.y() - min_y ;
                auto by1 = max_y - pt.y() ;
                //The stuff below should be in the constructor, but gradient is used less times than eval.
                auto N = basis_degree - 2 ;
                auto coeff_d2x = basis_degree*(basis_degree-1)/((max_x - min_x)*(max_x - min_x));
                auto coeff_d2y = basis_degree*(basis_degree-1)/((max_y - min_y)*(max_y - min_y));
                auto scaling_x_bis = 1.0/(pow(max_x - min_x,N) ); // 1/(b-a)^(n-1)
                auto scaling_y_bis = 1.0/(pow(max_y - min_y,N) );
                //std::cout<<"scaling_x_bis "<<scaling_x_bis<<std::endl;

        #ifdef POWER_CACHE
                if ( power_cache.size() != (basis_degree+1)*2 )
                  power_cache.resize( (basis_degree+1)*2) ;

                if ( power_cache_bis.size() != (N+1)*2 )
                    power_cache_bis.resize( (N+1)*2) ;

                if ( binomial_coeff.size() != (basis_degree+1) )
                    binomial_coeff.resize( basis_degree+1 ) ;

                if ( binomial_coeff_bis.size() != (N+1) )
                    binomial_coeff_bis.resize( N+1 ) ;

               // Construction of the exponenatial term for bernstein basis B^N and B^(N-2) (useful for derivative)
                for (size_t i = 0; i <= basis_degree ; i++)
                {
                    size_t j = basis_degree - i;
                    binomial_coeff[i] = binomial_coeff_fx( basis_degree , i );
                    power_cache[2*i]    = scaling_x *binomial_coeff[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j);
                    power_cache[2*i+1]  = scaling_y *binomial_coeff[i]*iexp_pow(by0, i)*iexp_pow(by1, j);

                    if( i < basis_degree - 1 )
                    {
                        size_t j_bis = N - i;
                        binomial_coeff_bis[i] = binomial_coeff_fx( N , i );
                        power_cache_bis[2*i] = scaling_x_bis * binomial_coeff_bis[i]*iexp_pow(bx0, i)*iexp_pow(bx1, j_bis);
                        power_cache_bis[2*i+1] = scaling_y_bis * binomial_coeff_bis[i]*iexp_pow(by0, i)*iexp_pow(by1, j_bis);

                    }

                }
        #endif

                size_t pos = 0;
                // Case FEM degree = 0
                if (basis_degree == 0 || basis_degree == 1){
                    VT zero = 0.0;
                    while(pos < basis_size){
                        ret(pos) =  zero;
                        pos++;
                    }
                }
                else{
                    // if degree FEM >= 2
                    //std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
                    int N_partial = basis_degree ;
                    int starter = 0;
                    int internal_bases = basis_degree + 1 ;

                    while(internal_bases > 1) // for each layout of internal node
                    {
                        for (int pow_y = starter; pow_y <= N_partial ; pow_y +=(N_partial-starter)){

                            if(pow_y == starter ) // Bottom side
                            {

                                for (int pow_x = starter; pow_x <= N_partial; pow_x+=(N_partial-starter))
                                {

                                    VT ix_bis = pow_x-1; // element i-1 for derivative
                                    VT iy_bis = pow_y-1; // element i-1 for derivative
                                    VT ix2_bis = pow_x-2; // element i-2 for derivative
                                    VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE
                                    std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                    auto px = power_cache[2*pow_x];
                                    auto py = power_cache[2*pow_y+1];
                                    //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                    if ( pow_x == 0 )
                                        auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                                    else if ( pow_x == basis_degree )
                                        auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                                    else if ( pow_x == 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                                    else if ( pow_x == basis_degree - 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                                    else
                                        auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );

                                    if ( pow_y == 0 )
                                        auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                                    else if ( pow_y == basis_degree )
                                        auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                                    else if ( pow_y == 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else if ( pow_y == basis_degree - 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else
                                        auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                                    //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

        #else

                                    //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                    size_t j_x = basis_degree - pow_x;
                                    //size_t j_y = basis_degree - pow_y;
                                    //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                    //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                    //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                    //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                    //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                    //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                    //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                    //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                    //std::cout<<"px PRE "<<px<<std::endl;

                                    // DERIVATIVES
                                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                    VT dx = 0.0 , dy = 0.0 ;

                                    if ( pow_x == 0 ){
                                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        dx = coeff_d2x * px_bis0 ;
                                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                    }
                                    else if ( pow_x == basis_degree ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * px_bis1 ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_x == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }

                                    else if ( pow_x == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - ix_bis;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        size_t j_x_bis2 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                        dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                    }

                                    if ( pow_y == 0 ){
                                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                       // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                        dy = coeff_d2y *  py_bis0 ;
                                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                    }
                                    else if ( pow_y == basis_degree ){
                                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * py_bis1  ;
                                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                    }
                                    else if ( pow_y == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_y == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - iy_bis;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        size_t j_y_bis2 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                        dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );
                                    //auto dy=coeff_dy*(power_cache_bis[2*iy_bis+1]-power_cache_bis[2*pow_y+1]);
                                    }


        #endif
                                    //std::cout<<"pos "<<pos<<std::endl;
                                    //std::cout<<"dx "<<dx<<std::endl;
                                    //std::cout<<"dy "<<dy<<std::endl;
                                    //std::cout<<"px "<<px<<std::endl;
                                    //std::cout<<"py "<<py<<std::endl;
                                    ret(pos) = px*dy;
                                    pos++;


                                }
                            }
                            else{ // Top side
                                for (int pow_x = N_partial; pow_x >= starter; pow_x-=(N_partial-starter))
                                {

                                    VT ix_bis = pow_x-1; // element i-1 for derivative
                                    VT iy_bis = pow_y-1; // element i-1 for derivative
                                    VT ix2_bis = pow_x-2; // element i-2 for derivative
                                    VT iy2_bis = pow_y-2; // element i-2 for derivative

            #ifdef POWER_CACHE

                                    std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                                    auto px = power_cache[2*pow_x];
                                    auto py = power_cache[2*pow_y+1];
                                    //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                                    if ( pow_x == 0 )
                                        auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                                    else if ( pow_x == basis_degree )
                                        auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                                    else if ( pow_x == 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                                    else if ( pow_x == basis_degree - 1 )
                                        auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                                    else
                                        auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                                    if ( pow_y == 0 )
                                        auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                                    else if ( pow_y == basis_degree )
                                        auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                                    else if ( pow_y == 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else if ( pow_y == basis_degree - 1 )
                                        auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                                    else
                                        auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                                    //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                                    //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                                    size_t j_x = basis_degree - pow_x;
                                    //size_t j_y = basis_degree - pow_y;
                                    //std::cout<<"j_x PRE "<<j_x<<std::endl;
                                    auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                                    //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                                    //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                                    //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                                    //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                                    //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                                    //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                                    auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                                    //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                                    //std::cout<<"px PRE "<<px<<std::endl;

                                    // DERIVATIVES
                                    //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                                    //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                                    VT dx = 0.0 , dy = 0.0 ;

                                    if ( pow_x == 0 ){

                                        //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        dx = coeff_d2x * px_bis0 ;
                                        //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                                    }
                                    else if ( pow_x == basis_degree ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * px_bis1 ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_x == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }


                                    else if ( pow_x == basis_degree - 1 ){

                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_x_bis0 = N - ix_bis;
                                        size_t j_x_bis1 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                        dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_x_bis0 = N - pow_x;
                                        size_t j_x_bis1 = N - ix_bis;
                                        size_t j_x_bis2 = N - ix2_bis;
                                        auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                        auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                        auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                        auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                        auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                        auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                        dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                                    }


                                    if ( pow_y == 0 ){
                                        //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                        dy = coeff_d2y *  py_bis0 ;
                                        //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                                    }
                                    else if ( pow_y == basis_degree ){
                                        //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * py_bis1  ;
                                        //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                                    }
                                    else if ( pow_y == 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else if ( pow_y == basis_degree - 1 ){
                                        //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                        size_t j_y_bis0 = N - iy_bis;
                                        size_t j_y_bis1 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                        dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                                    }
                                    else{
                                        size_t j_y_bis0 = N - pow_y;
                                        size_t j_y_bis1 = N - iy_bis;
                                        size_t j_y_bis2 = N - iy2_bis;
                                        auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                        auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                        auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                        auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                        auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                        auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                        dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                                    }

            #endif
                                    //std::cout<<"pos "<<pos<<std::endl;
                                    //std::cout<<"dx "<<dx<<std::endl;
                                    //std::cout<<"dy "<<dy<<std::endl;
                                    //std::cout<<"px "<<px<<std::endl;
                                    //std::cout<<"py "<<py<<std::endl;
                                    ret(pos) = px*dy;
                                    pos++;




                                } // loop for top side vertices




                            } // else bottom-top side

                        } // end loop for vertices


                        // face 0 (BOTTOM)
                        for (size_t pow_x = starter + 1 ; pow_x <= N_partial - 1 ; pow_x++)
                        {
                            size_t pow_y = starter;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

    #ifdef POWER_CACHE

                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            //size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;

                            if ( pow_x == 0 ){

                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);


                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }



                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;

                            }
                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);


                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = px*dy;
                            pos++;




                        }

                        // face 1 (RIGHT) size_t pow_x = N_partial;
                        for (size_t pow_y = starter + 1; pow_y <= N_partial - 1 ; pow_y++)
                        {
                            size_t pow_x = N_partial;
                            VT ix_bis = pow_x-1; // element i-1 for derivative

                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else
                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            //size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                            }
                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = px*dy;
                            pos++;
                        }

                        // face 2 (TOP)
                        for (size_t pow_x = N_partial - 1; pow_x >= starter + 1 ; pow_x--)
                        {
                            size_t pow_y = N_partial;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE

                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            //size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            //DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            }

                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }

                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }
                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

            #endif

                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = px*dy;
                            pos++;
                        }


                        // face 3 (LEFT)

                        for (size_t pow_y = N_partial - 1; pow_y >= starter + 1 ; pow_y--)
                        {
                            size_t pow_x = starter;
                            VT ix_bis = pow_x-1; // element i-1 for derivative
                            VT iy_bis = pow_y-1; // element i-1 for derivative
                            VT ix2_bis = pow_x-2; // element i-2 for derivative
                            VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                            std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                            auto px = power_cache[2*pow_x];
                            auto py = power_cache[2*pow_y+1];
                            //std::cout<<"px POWER_CACHE "<<px<<std::endl;
                            if ( pow_x == 0 )
                                auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                            else if ( pow_x == basis_degree )
                                auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                            else if ( pow_x == 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                            else if ( pow_x == basis_degree - 1 )
                                auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                            else
                                auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );


                            if ( pow_y == 0 )
                                auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                            else if ( pow_y == basis_degree )
                                auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                            else if ( pow_y == 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                            else if ( pow_y == basis_degree - 1 )
                                auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                            else
                                auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                            //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

            #else

                            //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                            size_t j_x = basis_degree - pow_x;
                            //size_t j_y = basis_degree - pow_y;
                            //std::cout<<"j_x PRE "<<j_x<<std::endl;
                            auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                            //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                            //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                            //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                            //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                            //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                            //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                            auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                            //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                            //std::cout<<"px PRE "<<px<<std::endl;

                            // DERIVATIVES
                            //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                            //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                            VT dx = 0.0 , dy = 0.0 ;


                            if ( pow_x == 0 ){
                                //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                dx = coeff_d2x * px_bis0 ;
                                //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                            }

                            else if ( pow_x == basis_degree ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else if ( pow_x == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_x == basis_degree - 1 ){

                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_x_bis0 = N - ix_bis;
                                size_t j_x_bis1 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                                dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                            }
                            else{
                                size_t j_x_bis0 = N - pow_x;
                                size_t j_x_bis1 = N - ix_bis;
                                size_t j_x_bis2 = N - ix2_bis;
                                auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                                auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                                auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                                auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                                auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                                auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                                dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                                //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                            }

                            if ( pow_y == 0 ){
                                //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                                dy = coeff_d2y *  py_bis0 ;
                                //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                            }

                            else if ( pow_y == basis_degree ){
                                //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * py_bis1  ;
                                //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                            }

                            else if ( pow_y == 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }

                            else if ( pow_y == basis_degree - 1 ){
                                //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                                size_t j_y_bis0 = N - iy_bis;
                                size_t j_y_bis1 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                                dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                            }
                            else{
                                size_t j_y_bis0 = N - pow_y;
                                size_t j_y_bis1 = N - iy_bis;
                                size_t j_y_bis2 = N - iy2_bis;
                                auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                                auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                                auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                                auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                                auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                                auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                                dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                            }

                #endif
                            //std::cout<<"pos "<<pos<<std::endl;
                            //std::cout<<"dx "<<dx<<std::endl;
                            //std::cout<<"dy "<<dy<<std::endl;
                            //std::cout<<"px "<<px<<std::endl;
                            //std::cout<<"py "<<py<<std::endl;

                            ret(pos) = px*dy;
                            pos++;
                        }

                        N_partial--;
                        starter++;
                        internal_bases -= 2;

                    }

                    // for B_k, with k even, I.E. odd number of bases: there is a central one.
                    if( basis_degree % 2 == 0 )
                    {
                        //  std::cout<<"N is "<<N_partial<< " and starter is "<<starter<<std::endl;
                        assert( N_partial == starter );
                        size_t pow_x = starter ;
                        size_t pow_y = starter ;

                        VT ix_bis = pow_x-1; // element i-1 for derivative
                        VT iy_bis = pow_y-1; // element i-1 for derivative
                        VT ix2_bis = pow_x-2; // element i-2 for derivative
                        VT iy2_bis = pow_y-2; // element i-2 for derivative

        #ifdef POWER_CACHE


                        std::cout<<"Bernstein Gradient, basis >=2: POWER_CACHE"<<std::endl;
                        auto px = power_cache[2*pow_x];
                        auto py = power_cache[2*pow_y+1];
                        //std::cout<<"px POWER_CACHE "<<px<<std::endl;

                        if ( pow_x == 0 )
                            auto dx = coeff_d2x * power_cache_bis[2*pow_x] ;
                        else if ( pow_x == basis_degree )
                            auto dx = coeff_d2x * power_cache_bis[2*ix2_bis] ;
                        else if ( pow_x == 1 )
                            auto dx = coeff_d2x * ( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] );
                        else if ( pow_x == basis_degree - 1 )
                            auto dx = coeff_d2x * ( power_cache_bis[2*ix2_bis] -2*power_cache_bis[2*ix_bis] );
                        else
                            auto dx = coeff_d2x*( power_cache_bis[2*pow_x] -2*power_cache_bis[2*ix_bis] + power_cache_bis[2*ix2_bis] );

                        if ( pow_y == 0 )
                            auto dy = coeff_d2y*power_cache_bis[2*pow_y+1] ;
                        else if ( pow_y == basis_degree )
                            auto dy = coeff_d2y*power_cache_bis[2*iy2_bis+1] ;
                        else if ( pow_y == 1 )
                            auto dy = coeff_d2y * ( power_cache_bis[2*pow_y+1] -2*power_cache_bis[2*iy_bis+1] );
                        else if ( pow_y == basis_degree - 1 )
                            auto dy = coeff_d2y * ( power_cache_bis[2*iy2_bis+1] -2*power_cache_bis[2*iy_bis+1] );
                        else
                            auto dy = coeff_d2y*( power_cache_bis[2*pow_y+1] - 2*power_cache_bis[2*iy_bis+1] + power_cache_bis[2*iy2_bis+1] );
                        //std::cout<<"dx POWER_CACHE "<<dx<<std::endl;

    #else
                        //std::cout<<"Bernstein Gradient, basis >=2: NOT CACHE"<<std::endl;
                        size_t j_x = basis_degree - pow_x;
                        //size_t j_y = basis_degree - pow_y;
                        //std::cout<<"j_x PRE "<<j_x<<std::endl;
                        auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                        //auto coeff_n_y = binomial_coeff_fx(basis_degree,pow_y);
                        //std::cout<<"coeff_n_x PRE "<<coeff_n_x<<std::endl;
                        //std::cout<<"scaling_x PRE "<<scaling_x<<std::endl;
                        //std::cout<<"pow_x PRE "<<pow_x<<std::endl;
                        //std::cout<<"bx0 PRE "<<bx0<<std::endl;
                        //std::cout<<"bx1 PRE "<<bx1<<std::endl;

                        auto px = scaling_x *coeff_n_x* iexp_pow(bx0, pow_x)*iexp_pow(bx1, j_x);
                        //auto py = scaling_y *coeff_n_y* iexp_pow(by0, pow_y)*iexp_pow(by1, j_y);
                        //std::cout<<"px PRE "<<px<<std::endl;

                        // DERIVATIVES
                        //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                        //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 , px_bis2 = 0.0 , py_bis2 = 0.0 ;
                        VT dx = 0.0 , dy = 0.0 ;

                        if ( pow_x == 0 ){
                            //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            dx = coeff_d2x * px_bis0 ;
                            //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;
                        }

                        else if ( pow_x == basis_degree ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * px_bis1 ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }
                        else if ( pow_x == 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis0 - 2*px_bis1) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else if ( pow_x == basis_degree - 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_x_bis0 = N - ix_bis;
                            size_t j_x_bis1 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis *  coeff_n_x_bis0 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis1);
                            dx = coeff_d2x * (px_bis1 - 2*px_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;

                        }
                        else{
                            size_t j_x_bis0 = N - pow_x;
                            size_t j_x_bis1 = N - ix_bis;
                            size_t j_x_bis2 = N - ix2_bis;
                            auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                            auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                            auto coeff_n_x_bis2 = binomial_coeff_fx(N,ix2_bis);
                            auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                            auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                            auto px_bis2 = scaling_x_bis * coeff_n_x_bis2 * iexp_pow(bx0, ix2_bis) * iexp_pow(bx1, j_x_bis2);

                            dx = coeff_d2x * (px_bis0 -2*px_bis1 +px_bis2);
                            //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                        }


                        if ( pow_y == 0 ){
                            //std::cout<<"into bottom pow_y = 0: HO b_i^K-1(y)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            // auto dy = coeff_dy * ( py_bis1 - py_bis0 );
                            dy = coeff_d2y *  py_bis0 ;
                            //auto dy = -coeff_dy*power_cache_bis[2*pow_y+1] ;
                        }

                        else if ( pow_y == basis_degree ){
                            //std::cout<<"into bottom pow_y != basis_degree: HO b_i-1^K-1(y)"<<std::endl;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * py_bis1  ;
                            //auto dy = coeff_dy*power_cache_bis[2*iy_bis+1] ;
                        }

                        else if ( pow_y == 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis0 - 2*py_bis1) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else if ( pow_y == basis_degree - 1 ){
                            //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                            size_t j_y_bis0 = N - iy_bis;
                            size_t j_y_bis1 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,iy_bis);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis0 = scaling_y_bis *  coeff_n_y_bis0 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis1);
                            dy = coeff_d2y * (py_bis1 - 2*py_bis0) ;
                            //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                        }

                        else{
                            size_t j_y_bis0 = N - pow_y;
                            size_t j_y_bis1 = N - iy_bis;
                            size_t j_y_bis2 = N - iy2_bis;
                            auto coeff_n_y_bis0 = binomial_coeff_fx(N,pow_y);
                            auto coeff_n_y_bis1 = binomial_coeff_fx(N,iy_bis);
                            auto coeff_n_y_bis2 = binomial_coeff_fx(N,iy2_bis);
                            auto py_bis0 = scaling_y_bis * coeff_n_y_bis0 * iexp_pow(by0, pow_y) * iexp_pow(by1, j_y_bis0);
                            auto py_bis1 = scaling_y_bis * coeff_n_y_bis1 * iexp_pow(by0, iy_bis) * iexp_pow(by1, j_y_bis1);
                            auto py_bis2 = scaling_y_bis * coeff_n_y_bis2 * iexp_pow(by0, iy2_bis) * iexp_pow(by1, j_y_bis2);
                            dy = coeff_d2y * ( py_bis0 - 2*py_bis1 + py_bis2 );

                        }

    #endif
                        //std::cout<<"pos "<<pos<<std::endl;
                        //std::cout<<"dx "<<dx<<std::endl;
                        //std::cout<<"dy "<<dy<<std::endl;
                        //std::cout<<"px "<<px<<std::endl;
                        //std::cout<<"py "<<py<<std::endl;

                        ret(pos) = px*dy;
                        pos++;



                    }
                }

                  //  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
                    assert(pos == basis_size);

                    return ret;


    }

    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return (degree+1)*(degree+1);
    }
};



template<typename Mesh, typename VT>
class cell_basis_Bernstein_1d_reference
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;
    typedef typename Mesh::cell_type       cell_type;

    //point_type          cell_bar;
    //coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    coordinate_type min_x , max_x , min_y , max_y ;
    coordinate_type scaling_x ;
    std::vector<point<VT,2>> physical_pts ;
    cell_type m_cl ;
    Mesh msh_orig ;
    Mesh msh_agglo ;
   
public:
    cell_basis_Bernstein_1d_reference(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
       {
           //cell_bar        = barycenter(msh, cl);
           //cell_h          = diameter(msh, cl);
           basis_degree    = degree;
           basis_size      = (basis_degree+1);
           auto ref_nodes = reference_nodes_ordered<VT>(degree) ;
           physical_pts = cl.user_data.interface ;
           
           min_x = 0.0 ; // points(msh,cl)[0].x();
           max_x = 1.0 ; //points(msh,cl)[1].x();
           scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );
            
           m_cl = cl ;

    }



    Matrix<VT, Dynamic, 1>
    eval_basis_1d(const VT& pt)
    {

        size_t pos = 0;
        auto bx0 = pt - min_x ;
        auto bx1 = max_x - pt ;
        
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);
        if (basis_degree == 0){ // Case degree FEM = 0
            VT one = 1.0;
            ret(pos++) = one;

        }
        else if(basis_degree == 1)
        {
            for (int pow_x = 0; pow_x <= basis_degree; pow_x+=basis_degree)
            {
                size_t j_x = basis_degree - pow_x;
                auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                auto bv = scaling_x *  coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;

                ret(pos++) = bv;


            }
        }
        else
        {
            int N = basis_degree ;
            int starter = 0;
            for (int pow_x = starter; pow_x <= N; pow_x+=(N-starter)){

                size_t j_x = basis_degree - pow_x;
                auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;
                
                ret(pos++) = bv;
                                // std::cout<<"pos vertices bottom is "<<pos<<std::endl;
            }

            // face 0 (BOTTOM)
            for (size_t pow_x = starter + 1 ; pow_x <= N - 1 ; pow_x++)
            {

                size_t j_x = basis_degree - pow_x;


                auto coeff_n_x = binomial_coeff_fx(basis_degree,pow_x);
                auto bv = scaling_x * coeff_n_x * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x) ;
                ret(pos++) = bv;
                           //  std::cout<<"pos face 0 is "<<pos<<std::endl;
            }
        }
        // std::cout<<"pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;
    }

    Matrix<VT, 2, 1>
    eval_basis_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_basis_1d(pt) ;
        
        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;
        
        
        if (size_cls == 1){
    
            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();
            
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }
            
            return ret;
        }

        
        
        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }


    // ANCORA DA DEFINIRE
    Matrix<VT, Dynamic, 1>
    eval_gradients_1d(const VT& pt)
    {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);
        auto bx0 = pt - min_x ;
        auto bx1 = max_x - pt ;
        auto N = basis_degree - 1 ;
        
        auto coeff_dx = basis_degree/(max_x - min_x);
        auto scaling_x_bis = 1.0/(pow(max_x - min_x,N) ); // 1/(b-a)^(n-1)
        //std::cout<<"check = "<< 1.0 - 1.0/(pow(max_x - min_x,N) ) <<std::endl;
        
        size_t pos = 0;
        // Case FEM degree = 0
        if (basis_degree == 0)
        {
            VT zero = 0.0;
            ret(pos) =  zero;
            pos++;
        }
        // Case FEM degree = 1
        else if(basis_degree == 1)
        {// Pick just vertices
            int i = 1;  // useful for the sign of the derivative in x
            VT coeffx = 1.0/(max_x - min_x);
            
            
            for (int pow_x = 0; pow_x <= basis_degree; pow_x+=basis_degree)
            {
                ret(pos) = coeffx *  pow(-1,i);
                //std::cout<<"i is "<<i<< " and pow (-1,i) = "<<pow(-1,i)<<std::endl;
                pos++;
                i++;
            }

        }
        else
        {   // if degree FEM >= 2
            //std::cout<<"Bernstein Gradient, basis >=2 "<<std::endl;
            int N_partial = basis_degree ;
            int starter = 0;
           
            for (int pow_x = starter; pow_x <= N_partial; pow_x+=(N_partial-starter))
            {
                VT ix_bis = pow_x-1; // element i-1 for derivative
                
                // DERIVATIVES
                //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0  ;

                if ( pow_x == 0 )
                {
                    //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = - coeff_dx *  px_bis0 ;
                    //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                }
                else if ( pow_x == basis_degree )
                {
                    //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                    auto px_bis1 =  scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx *  px_bis1 ;
                                //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                }
                else{
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                    auto px_bis0 =  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    
                    dx = coeff_dx * (px_bis1 -px_bis0);
                    //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }
                ret(pos) = dx;
                pos++;
            }
                    
            // face 0 (BOTTOM)
            for (size_t pow_x = starter + 1 ; pow_x <= N_partial - 1 ; pow_x++)
            {
                    
                VT ix_bis = pow_x-1;
               
                // DERIVATIVES
                //std::cout<<"pow_x= "<<pow_x<<"pow_y= "<<pow_y<<std::endl;
                //auto px_bis0 = 0.0 , py_bis0 = 0.0 , px_bis1 = 0.0 , py_bis1 = 0.0 ;
                VT dx = 0.0  ;

                if ( pow_x == 0 ){
                    //std::cout<<"into bottom pow_x == 0: HO b_i^K-1(x)"<<std::endl;
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                    auto px_bis0 = scaling_x_bis * coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);
                    dx = -coeff_dx * px_bis0 ;
                    //auto dx = -coeff_dx*power_cache_bis[2*pow_x] ;

                }
                else if ( pow_x == basis_degree ){
                    //std::cout<<"into bottom pow_x != basis_degree: HO b_i-1^K-1(x)"<<std::endl;
                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * px_bis1 ;
                        //auto dx = coeff_dx*power_cache_bis[2*ix_bis] ;
                }
                else{
                    size_t j_x_bis0 = N - pow_x;
                    auto coeff_n_x_bis0 = binomial_coeff_fx(N,pow_x);
                    auto px_bis0 =  coeff_n_x_bis0 * iexp_pow(bx0, pow_x) * iexp_pow(bx1, j_x_bis0);

                    size_t j_x_bis1 = N - ix_bis;
                    auto coeff_n_x_bis1 = binomial_coeff_fx(N,ix_bis);
                    auto px_bis1 = scaling_x_bis * coeff_n_x_bis1 * iexp_pow(bx0, ix_bis) * iexp_pow(bx1, j_x_bis1);
                    dx = coeff_dx * (px_bis1 -px_bis0);
                        //auto dx = coeff_dx*( power_cache_bis[2*ix_bis]-power_cache_bis[2*pow_x]);
                }


                ret(pos,0) = dx;
                pos++;

            }

              
        }

          
        //  std::cout<<"GRADIENTE: pos is"<<pos<<" and basis size is "<< basis_size<<std::endl;
        assert(pos == basis_size);

        return ret;


    }

    
   
    Matrix<VT, 2, 1>
    eval_gradients_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_gradients_1d(pt) ;
        
        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;
        
        
        if (size_cls == 1){
    
            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();
            
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }
            
            return ret;
        }

        
        
        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }


    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return (degree+1);
    }
};








template<typename Mesh, typename VT>
class cell_basis_Lagrange_1d_reference
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;
    typedef typename Mesh::cell_type       cell_type;

    //point_type          cell_bar;
    //coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    coordinate_type min_x , max_x , min_y , max_y ;
    coordinate_type scaling_x ;
    std::vector<point<VT,2>> physical_pts ;
    std::vector<point<VT,1> > ref_nodes ;
    cell_type m_cl ;
    Mesh msh_orig ;
    Mesh msh_agglo ;
   
public:
    cell_basis_Lagrange_1d_reference(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
       {
           //cell_bar        = barycenter(msh, cl);
           //cell_h          = diameter(msh, cl);
           basis_degree    = degree;
           basis_size      = (basis_degree+1);
           
           ref_nodes = reference_nodes_ordered_01<VT>(degree) ; //[0,1]
           //ref_nodes = reference_nodes_ordered<VT>(degree) ; //[-1,1]
           physical_pts = cl.user_data.interface ;
           
           //min_x = 0.0 ; // points(msh,cl)[0].x();
           //max_x = 1.0 ; //points(msh,cl)[1].x();
           //scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );
            
           m_cl = cl ;

    }
    
    cell_basis_Lagrange_1d_reference(size_t degree)
    {
           //cell_bar        = barycenter(msh, cl);
           //cell_h          = diameter(msh, cl);
           basis_degree    = degree;
           basis_size      = (basis_degree+1);
           
           ref_nodes = reference_nodes_ordered_01<VT>(degree) ; //[0,1]
           //ref_nodes = reference_nodes_ordered<VT>(degree) ; //[-1,1]
           //physical_pts = cl.user_data.interface ;
           
           //min_x = 0.0 ; // points(msh,cl)[0].x();
           //max_x = 1.0 ; //points(msh,cl)[1].x();
           //scaling_x = 1.0/( pow( (max_x - min_x), basis_degree) );
            
           //m_cl = cl ;

    }

    

    Matrix<VT, Dynamic, 1>
    eval_basis_1d(const VT& pt)
    {

        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size);
        
        
        for(size_t k = 0 ; k < basis_size ; k++)
        {
            VT bk = 1;
            for ( size_t j = 0 ; j < basis_size ; j++ ){
                if(j!=k){
                    bk *= ( ( pt - ref_nodes.at(j).x() )/ ( ref_nodes.at(k).x() - ref_nodes.at(j).x() ) );
                    //std::cout<<"ref_nodes.at(j).x() = " << ref_nodes.at(j).x() << " , ref_nodes.at(k).x() = "<<ref_nodes.at(k).x()<<std::endl;
                }
            }

            ret(k) = bk;
           
        }
        
       
       

        return ret;
    }

    /*
    Matrix<VT, 2, 1>
    eval_basis_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_basis_1d(pt) ;
        
        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;
        
        
        if (size_cls == 1){
    
            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();
                       
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }
            
        return ret;
        }

        
        
        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }
    */

    // ANCORA DA DEFINIRE
    Matrix<VT, Dynamic, 1>
    eval_gradients_1d(const VT& pt)
    {
        Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);
        
        
        for (size_t k = 0 ; k < basis_size ; k++ )
        {
            VT  bk_der = 1.0 ;
            VT sumx = 0.0;
            for (size_t tmpx = 0 ; tmpx < basis_size; tmpx++)
            {
                VT sumxx = 1.0 ;

                if (tmpx!=k) {

                    
                    bk_der *= ( 1.0/ ( ref_nodes.at(k).x()  - ref_nodes.at(tmpx).x() )  );
                    for (size_t jx = 0 ; jx < basis_size; jx++)
                    {
                        if (jx!=tmpx && jx!=k)
                        {
                            sumxx *= ( pt-ref_nodes.at(jx).x() );
                        }
                    }
                    sumx += sumxx;

                }
            }
          
            ret(k) = bk_der*sumx;
        }
        
       

        return ret;


    }
    
    
    
    Matrix<VT, Dynamic, 1>
    eval_double_derivative_1d(const VT& pt)
    {

         Matrix<VT, Dynamic, 1> ret = Matrix<VT, Dynamic, 1>::Zero(basis_size, 1);
            
        if( basis_degree == 0)
            exit(9) ;
        if( basis_degree == 1)
            return ret ;
        if( basis_degree == 2)
        {
            for (size_t k = 0 ; k < basis_size ; k++ )
            {
                VT  bk_der = 1.0 ;
                for (size_t tmpx = 0 ; tmpx < basis_size; tmpx++)
                {
                    if (tmpx!=k)
                        bk_der *= ( 1.0/ ( ref_nodes.at(k).x()  - ref_nodes.at(tmpx).x() )  );
                    
                }
                     
                ret(k) = bk_der*2.0;
            }
        
            return ret ;
        }
        if( basis_degree == 3)
        {
            for (size_t k = 0 ; k < basis_size ; k++ )
            {
                VT  bk_der = 1.0 ;
                VT b_tot = 0.0;
                for (size_t tmpx = 0 ; tmpx < basis_size; tmpx++)
                {
                    VT b = 1.0 ;

                    if (tmpx!=k)
                    {

                                
                        bk_der *= ( 1.0/ ( ref_nodes.at(k).x()  - ref_nodes.at(tmpx).x() )  );
                        size_t jx= tmpx ;
                        bool inserted = false ;
                        while (!inserted)
                        {
                            if (jx!=k ){
                                b *= ( pt-ref_nodes.at(jx).x() );
                                inserted = true ;
                            }
                             
                            jx++;
                             
                        }
                        b_tot += 2.0*b;
            
                    }
                 
                }
            
                ret(k) = bk_der*b_tot;
                 
            }
            return ret;
        }
          
        
        if(basis_degree == 4)
        { // In the generic case it doesn't work since amount is fine for just (x-xj)*(x-xl), with l>j, but iif I have more than two terms it need somehting more general
        
        for (size_t k = 0 ; k < basis_size ; k++ ) // basis k
        {
            VT  bk_der = 1.0 ;
            VT b_tot = 0.0;
            size_t pos = 0 ; // iter
            for( size_t amount = 0 ; amount < basis_degree -1 ; amount++)
            {
                if(pos == k)
                    pos++;
                
                 size_t jx= pos ;
                // starting from amount k = 0  num counts how many terms have (x-x1)*(), how many(x-x2)*() etc --> pos defines the term
                // For k generic, it always starts from pos=0(at least that k=0) and just skip pos=k
                for( size_t num = basis_degree - 1 -amount ; num >0 ; num-- )
                {
                    VT b = ( pt-ref_nodes.at(pos).x() );
                    size_t m = 0 ;
                   
                    while ( m !=  basis_degree - 3)
                    {
                        if (jx!=k && jx!=pos){
                            b *= ( pt-ref_nodes.at(jx).x() );
                            m++;
                        }
                
                        jx++;
                    }
                    b_tot += 2.0*b;
                }
                pos++;
            }
            
            for (size_t tmpx = 0 ; tmpx < basis_size; tmpx++)
            {
                if (tmpx!=k)
                    bk_der *= ( 1.0/ ( ref_nodes.at(k).x()  - ref_nodes.at(tmpx).x() )  );
            }
                
           
            ret(k) = bk_der*b_tot;
            
        }
     
        return ret;
        }
    }
    

    /*
       Matrix<VT, 2, 1>
    eval_gradients_curv(const VT& pt , int r = 0 )
    {
        Matrix<VT, 2, 1> ret = Matrix<VT, 2, 1>::Zero(2, 1);
        auto basis = eval_gradients_1d(pt) ;
        
        auto size_pts = physical_pts.size() ;
        auto size_cls = size_pts/basis_size ;
        
        
        if (size_cls == 1){
    
            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_size].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_size].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_size].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_size].y();
            
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_size].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_size].y();
            }
            
            return ret;
        }

        
        
        //ret.col(0) = eval_basis_1d(pt).transpose()*( physical_pts.x()  ) ;
        //ret.col(1) = eval_basis_1d(pt)*( physical_pts.y()  ) ;
        //return ret ;

    }
     */
    
    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return (degree+1);
    }
};




template<typename Mesh, typename T >
class cell_basis_Lagrangian
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    std::vector<point<T, 2> >          nodes;
    //std::vector<size_t>         indeces;

public:
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);
        //nodes           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);

        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);
    }

    /*
    cell_basis_Lagrangian(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, const std::vector<size_t>& indeces)
    {

        nodes = equidistriduted_nodes_subcell<T,Mesh>(msh, cl, degree, indeces);
        basis_degree    = degree;
        basis_size      = (basis_degree+1)*(basis_degree+1);

    }
    */

    Matrix<T, Dynamic, 1>
    eval_basis(const point_type& pt)
    {
        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);

        // Per la y, trovo la colonna facendo col = l%(degree+1)
        // scorro su tutta la colonna tmpy = [col:(degree+1): col+(degree+1)*degree]
        // faccio base bl moltiplicando tutti tranne quando tmpy = l
        for ( size_t l = 0; l < basis_size ; l++ )
        {
            size_t col = l%(basis_degree+1);
            T bl = 1.0;
            for (size_t tmpy = col; tmpy <= col+(basis_degree+1)*basis_degree; tmpy+=(basis_degree+1))
            {
                if (tmpy!=l)
                {
                    bl *= ( ( pt.y() - (nodes.at(tmpy)).y() )/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );
                }
            }
            rety(l) = bl;
        }

        // Per la x, trovo la riga facendo riga = floor(k/(degree+1))
        //scorro su tutta la riga tmpx = [(degree+1)*riga: (degree+1)*(riga+1)-1]
        // faccio base bk moltiplicando tutti tranne quando tmpx = k

        for (size_t k = 0 ; k < basis_size ; k++ )
        {
            T bk = 1.0;
            size_t row=floor( k/(basis_degree+1) );
            for (size_t tmpx = (basis_degree+1)*row; tmpx <= (basis_degree+1)*(row+1)-1; tmpx++)
            {
                if (tmpx!=k) {
                    bk *= ( ( pt.x() - (nodes.at(tmpx)).x() )/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                }
            }
            retx(k) = bk;
        }

        for (size_t i = 0; i<basis_size; i++)
        {
            ret(i) = rety(i)*retx(i);
        }
        return ret;

    }

    Matrix<T, Dynamic, 2>
    eval_gradients(const point_type& pt)
    {
        // Modified Yves Daoust Algorithm (https://math.stackexchange.com/questions/809927/first-derivative-of-lagrange-polynomial)

        Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Zero(basis_size, 2);

        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sy = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> sx = Matrix<T, Dynamic, 1>::Zero(basis_size);


        // for each l, b_l(y)' = {sum(tmpy!=l)[prod(jy!=l,jy!=tmpy)[x-x_jy]]}/prod(tmpy!=l)[x_l-x_tmpy]

        for ( size_t l = 0; l < basis_size ; l++ )
        {
            size_t col = l%(basis_degree+1);
            T bl = 1.0 , bl_der = 1.0 ;
            T sumy = 0.0;
            for (size_t tmpy = col; tmpy <= col+(basis_degree+1)*basis_degree; tmpy+=(basis_degree+1))
            {
                 T sumyy = 1.0 ;
                if (tmpy!=l)
                {

                    bl *= ( ( pt.y() - (nodes.at(tmpy)).y() )/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );

                    bl_der *= ( 1.0/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );
                    for ( size_t jy = col; jy <= col+(basis_degree+1)*basis_degree; jy+=(basis_degree+1) )
                   {
                        if (jy!=tmpy && jy!=l)
                        {
                            sumyy *= ( pt.y()-(nodes.at(jy)).y() );
                        }
                    }
                    sumy +=sumyy;
                }
            }
            rety(l) = bl;
            sy(l) = bl_der*sumy;
        }

        // For the x-derivative of b_k(x), same procedure of b_l(y)'

        for (size_t k = 0 ; k < basis_size ; k++ )
        {
            size_t row=floor( k/(basis_degree+1) );
            T bk = 1.0 , bk_der = 1.0 ;
            T sumx = 0.0;
            for (size_t tmpx = (basis_degree+1)*row; tmpx <= (basis_degree+1)*(row+1)-1; tmpx++)
            {
                T sumxx = 1.0 ;

                if (tmpx!=k) {

                    bk *= ( ( pt.x() - (nodes.at(tmpx)).x() )/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                    bk_der *= ( 1.0/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                    for (size_t jx = (basis_degree+1)*row; jx <= (basis_degree+1)*(row+1)-1; jx++)
                    {
                        if (jx!=tmpx && jx!=k)
                        {
                            sumxx *= ( pt.x()-(nodes.at(jx)).x() );
                        }
                    }
                    sumx += sumxx;

                }
            }
            retx(k) = bk;
            sx(k) = bk_der*sumx;
        }

        for (size_t i = 0; i<basis_size; i++)
        {
            ret(i,0) = rety(i)*sx(i);
            ret(i,1) = retx(i)*sy(i);

        }
        return ret;

    }

    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return (degree+1)*(degree+1);
    }
};

/*
template<typename Mesh, typename T >
class cell_basis_Raviart_Thomas
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    std::vector<point<T, 2> >          nodes;
    //std::vector<size_t>         indeces;
    Matrix<T, Dynamic, 1> P_k , P_km1_k , P_k_km1 ;
    std::vector<point<T,1> > nodes_1d ;

public:

    cell_basis_Raviart_Thomas(const Mesh& msh, size_t degree)
    {
        //nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);

        basis_degree    = degree;
        basis_size      = 2*(basis_degree+1)*(basis_degree+2);
        P_k             = Matrix<T, Dynamic, 1>::Ones(basis_degree+1);
        P_km1_k         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));
        P_k_km1         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));
        nodes_1d        = reference_nodes_ordered<T>(degree);

        for(size_t fc_i = 0 ; fc_i < 4 ; fc_i++) // for each face of a quadrangular square
        {
            for(size_t i = 1 ; i < nodes_1d.size() ; i++) // for each polynomial defined over a face
            {

                auto nd = nodes_1d[i]  ;

                P_k(i) = nd[i]*P_k(i-1); // non va bene devo fare una base cosi
                if(fc_i == 0) // the normal is (0,-1)
                {

                }

               if(fc_i == 1) // the normal is (1,0)
                {

                }

                if(fc_i == 2) // the normal is (0,1)
                {

                }

                if(fc_i == 3) // the normal is (-1,0)
                {

                }

            }

        }



    }

    cell_basis_Raviart_Thomas(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        nodes           = equidistriduted_nodes<T,Mesh>(msh, cl, degree);

        basis_degree    = degree;
        basis_size      = 2*(basis_degree+1)*(basis_degree+2);
        P_k             = Matrix<T, Dynamic, 1>::Zero(basis_degree+1);
        P_km1_k         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));
        P_k_km1         = Matrix<T, Dynamic, 1>::Zero((basis_degree+1)*(basis_degree));

        for(auto&fc : faces(msh, cl))
        {
            for(size_t i = 0 ; i < basis_degree+1 ; i++)
            {

            }

        }



    }


    Matrix<T, Dynamic, 1>
    eval_basis(const point_type& pt)
    {
        Matrix<T, Dynamic, 1> rety = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> retx = Matrix<T, Dynamic, 1>::Zero(basis_size);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(basis_size);

        // Per la y, trovo la colonna facendo col = l%(degree+1)
        // scorro su tutta la colonna tmpy = [col:(degree+1): col+(degree+1)*degree]
        // faccio base bl moltiplicando tutti tranne quando tmpy = l
        for ( size_t l = 0; l < basis_size ; l++ )
        {
            size_t col = l%(basis_degree+1);
            T bl = 1.0;
            for (size_t tmpy = col; tmpy <= col+(basis_degree+1)*basis_degree; tmpy+=(basis_degree+1))
            {
                if (tmpy!=l)
                {
                    bl *= ( ( pt.y() - (nodes.at(tmpy)).y() )/ ( (nodes.at(l)).y() - (nodes.at(tmpy)).y() ) );
                }
            }
            rety(l) = bl;
        }

        // Per la x, trovo la riga facendo riga = floor(k/(degree+1))
        //scorro su tutta la riga tmpx = [(degree+1)*riga: (degree+1)*(riga+1)-1]
        // faccio base bk moltiplicando tutti tranne quando tmpx = k

        for (size_t k = 0 ; k < basis_size ; k++ )
        {
            T bk = 1.0;
            size_t row=floor( k/(basis_degree+1) );
            for (size_t tmpx = (basis_degree+1)*row; tmpx <= (basis_degree+1)*(row+1)-1; tmpx++)
            {
                if (tmpx!=k) {
                    bk *= ( ( pt.x() - (nodes.at(tmpx)).x() )/ ( (nodes.at(k)).x() - (nodes.at(tmpx)).x() ) );
                }
            }
            retx(k) = bk;
        }

        for (size_t i = 0; i<basis_size; i++)
        {
            ret(i) = rety(i)*retx(i);
        }
        return ret;

    }



    size_t size() const
    {
        return basis_size;
    }

    size_t degree() const
    {
        return basis_degree;
    }

    static size_t size(size_t degree)
    {
        return 2*(degree+1)*(degree+2);
    }
};

template<typename Mesh, typename T >
class P_k_basis
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree, basis_size;
    std::vector<point<T, 2> >          nodes;



public:

    P_k_basis(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree)
    {
        // nodes I do not know it is useful!
        nodes           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);
        basis_degree    = degree;
        basis_size      = (basis_degree+1);



    }

    Matrix<T, Dynamic, 2>
    eval_basis(const point_type& pt)
    {

        Matrix<T, Dynamic, 2> ret = Matrix<T, Dynamic, 2>::Ones(basis_size,2);

        // Column 0 is the x P^k basis ; column 1 is the y P^k basis
        for ( size_t i = 1; i < basis_size ; i++ )
        {
            // Before it should be moved into the correct cell
            ret(i,0) = pt.x()*ret(i-1);
            ret(i,1) = pt.y()*ret(i-1);


        }


        return ret;

    }

};

template<typename Mesh, typename T >
class P_k_l_basis
{
    typedef typename Mesh::coordinate_type  coordinate_type;
    typedef typename Mesh::point_type       point_type;

    point_type          cell_bar;
    coordinate_type     cell_h;
    size_t              basis_degree_x,basis_degree_y, basis_size;
    std::vector<point<T, 2> >          nodes_x , nodes_y ;


public:

    P_k_l_basis(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree_k ,size_t degree_l )
    {
        // nodes I do not know it is useful!
        nodes_x           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_k);
        nodes_y           = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_l);
        basis_degree_x    = degree_k;
        basis_degree_y    = degree_l;
        basis_size      = (basis_degree_x+1)*(basis_degree_y+1);



    }

    Matrix<T, Dynamic, 1>
    eval_basis(const point_type& pt)
    {

        Matrix<T, Dynamic, 1> ret_x = Matrix<T, Dynamic, 1>::Ones(basis_degree_x);
        Matrix<T, Dynamic, 1> ret_y = Matrix<T, Dynamic, 1>::Ones(basis_degree_y);
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Ones(basis_size);


        // Column 0 is the x P^k basis ; column 1 is the y P^k basis
        size_t count = 1; // ATTENCTION IF THE FIRST ELEMENT IS NOT 1 (cell mapping)
        for ( size_t i = 1; i < basis_degree_x ; i++ )
        {
            // Before it should be moved into the correct cell
            ret_x(i) = pt.x()*ret_x(i-1);
            for ( size_t j = 1; j< basis_degree_y ; j++ )
            {
                // Before it should be moved into the correct cell
                ret_y(j) = pt.y()*ret_y(j-1);
                ret(count) = ret_x(i)*ret_y(j) ;
                count++;
            }

        }


        // ALTERNATIVA: CHIAMARE DIRETTAMENTE LA CLASSE Pk
        //EX:
        //auto p_k =  P_k_basis(msh, cl,  degree_k) ;
        //auto p_l =  P_k_basis(msh, cl,  degree_l) ;

         //size_t count = 0;
         //for ( size_t i = 1; i < basis_degree_x ; i++ )
         //{
         //    for ( size_t j = 1; j< basis_degree_y ; j++ )
         //    {
          //       ret(count) = p_k(i)*p_l(j) ;
          //       count++;
          //   }

        // }
// }



        return ret;

    }

};

*/


template<typename T>
std::vector<point<T,1> >
reference_nodes(size_t degree)
{
    auto comp_degree = degree + 1;

    size_t reqd_nodes = comp_degree;

    std::vector<point<T,1> > ret;
    ret.reserve(reqd_nodes);

    point<T,1>  qp;
    T           a1, a2;
    T           delta_x;
    switch(reqd_nodes)
    {
        case 1:
            qp = point<T,1>({0.0});
            ret.push_back(qp);
            return ret;

        case 2:
            qp = point<T,1>({ 1.0 });
            ret.push_back( -qp );
            ret.push_back( qp );
            return ret;

        case 3:
            qp = point<T,1>({ 1.0 });
            ret.push_back( -qp );
            ret.push_back( qp );
            qp = point<T,1>({0.0});
            ret.push_back( qp );
            return ret;

        case 4:
            a1 = 1.0/3.0;
            qp = point<T,1>({ 1.0 });
            ret.push_back( -qp );
            ret.push_back( qp );
            qp = point<T,1>({ a1 });
            ret.push_back( -qp );
            ret.push_back( qp );
            return ret;

        case 5:
            // Be carefull in what order data is inserted in ret!
            // In Gauss Legendre the first one was 0.0, now is the last one
            a2 = 0.5;
            a1 = 1.0;
            qp = point<T,1>({ a1 });
            ret.push_back( -qp );
            ret.push_back( qp );

            qp = point<T,1>({ a2 });
            ret.push_back( -qp );
            ret.push_back( qp );

            qp = point<T,1>({ 0.0 });
            ret.push_back( qp );

            return ret;

        default:

            delta_x = 1.0/degree;
            a1 = 1.0;
            while (a1>0) {
                qp = point<T,1>({ a1 });
                ret.push_back( -qp );
                ret.push_back( qp );
                a1-=delta_x;

            }
            if(a1==0)
            {
                qp = point<T,1>({0.0});
                ret.push_back( qp );
            }
            return ret;
    }

    return ret;
}

template<typename T,typename Mesh>
std::vector< point<T,2> >
equidistriduted_nodes(const Mesh& msh,
          const typename Mesh::cell_type& cl,
          size_t degree)
{
    typedef typename Mesh::point_type    point_type;

    auto qps = reference_nodes<T>(degree);


    auto pts = points(msh, cl);

    auto v0 = pts[1] - pts[0];
    auto v1 = pts[2] - pts[1];
    auto v2 = pts[3] - pts[2];
    auto v3 = pts[3] - pts[0];

    std::vector< point<T,2> > ret;

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1-xi)*(1-eta) +
               0.25 * pts[1].x() * (1+xi)*(1-eta) +
               0.25 * pts[2].x() * (1+xi)*(1+eta) +
               0.25 * pts[3].x() * (1-xi)*(1+eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1-xi)*(1-eta) +
               0.25 * pts[1].y() * (1+xi)*(1-eta) +
               0.25 * pts[2].y() * (1+xi)*(1+eta) +
               0.25 * pts[3].y() * (1-xi)*(1+eta);
    };

    for (auto jtor = qps.begin(); jtor != qps.end(); jtor++)
    {
        for (auto itor = qps.begin(); itor != qps.end(); itor++)
        {
            auto qp_x = *itor;
            auto qp_y = *jtor;

            auto xi = qp_x.x();
            auto eta = qp_y.x();

            auto px = P(xi, eta);
            auto py = Q(xi, eta);

            ret.push_back( point_type(px, py) );
        }
    }

    return ret;
}


// Qualitative testing of the discrete level set function wrt the analytical one
template< typename Fonction , typename Mesh  >
void
testing_velocity_field_L2projected(const Mesh msh , const Fonction& vel )
{
    //typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;

    auto test_discx  = std::make_shared< gnuplot_output_object<double> >("L2vel_HHOX.dat");
    auto test_discy  = std::make_shared< gnuplot_output_object<double> >("L2vel_HHOY.dat");


    for(auto& cl:msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<double,Mesh> (msh,cl,vel.degree_FEM);
        for(auto&pt : pts)
        {
            auto value = vel(pt,msh,cl);
            test_discx->add_data(pt,value.first);
            test_discy->add_data(pt,value.second);


        }
    }

    postoutput1.add_object(test_discx);
    postoutput1.add_object(test_discy);



    postoutput1.write();

}
template< typename Fonction , typename Mesh  >
void
testing_velocity_field(const Mesh msh , const Fonction& vel )
{
    //typedef typename Mesh::point_type       point_type;
    postprocess_output<double> postoutput1;

    auto test_discx  = std::make_shared< gnuplot_output_object<double> >("vel_HHOX.dat");
    auto test_discy  = std::make_shared< gnuplot_output_object<double> >("vel_HHOY.dat");


    for(auto& cl:msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<double,Mesh> (msh,cl,vel.degree_FEM);
        for(auto&pt : pts)
        {
            auto value = vel(pt,msh,cl);
            test_discx->add_data(pt,value.first);
            test_discy->add_data(pt,value.second);


        }
    }

    postoutput1.add_object(test_discx);
    postoutput1.add_object(test_discy);



    postoutput1.write();

}

template< typename FonctionD , typename Mesh , typename T >
void
testing_level_set_time(const Mesh msh , const FonctionD& level_set_disc , T time , size_t time_step)
{
    typedef typename Mesh::point_type       point_type;


//    postprocess_output<double> postoutput0;
//    std::string filename_FEM = "sol_FEM_t=" + std::to_string(time_step) + ".dat";
//    auto test_FEM  = std::make_shared< gnuplot_output_object_val<double> >(filename_FEM);
//    for(size_t i = 0 ; i < level_set_disc.sol_FEM.size() ; i++)
//        test_FEM->add_data( level_set_disc.sol_FEM(i) ) ;
//
//    postoutput0.add_object(test_FEM);
//    postoutput0.write();


    postprocess_output<double> postoutput1;
    double valueD  , value_profile ;
    point<double,2> node;
    size_t N, M;
    std::cout<<"testing_level_set_time: 4x4 points in each cell."<<std::endl;
    N = 4; //80 points to see also the interface!!!
    M = 4; //80 points to see also the interface!!!


    //std::string filename_test_ls = "level_set_" + std::to_string(time_step) + ".dat";
    //auto test_level_set  = std::make_shared< gnuplot_output_object<double> >(filename_test_ls);


    //std::string filename_test_profile = "profile_" + std::to_string(time_step) + ".dat";
    //auto test_profile  = std::make_shared< gnuplot_output_object<double> >(filename_test_profile);



    // CHECK MAX AND MIN
    T ret0 = -10.0;
    T ret1 = 10.0;

    double py_profile = 0.5;
    //double iso_val_interface = level_set_disc.iso_val_interface ;
    for(auto& cl : msh.cells)
    {
        auto pts = points(msh, cl);
        auto pt0_x = pts[0].x();
        auto pt1_x = pts[1].x();
        auto pt0_y = pts[0].y();
        auto pt1_y = pts[3].y();

        for(size_t i = 0 ; i<= N ; i++ )
        {
            double px = pt0_x + i*( (pt1_x - pt0_x)/N);
            for (size_t j = 0 ; j<= M ; j++ )
            {
                double py = pt0_y + j*( (pt1_y - pt0_y)/M);
                node = point_type(px,py);

                valueD = level_set_disc(node,msh,cl);
                //test_level_set->add_data(node,valueD);



            }

            node = point_type(px,py_profile);
            value_profile = level_set_disc(node,msh,cl);
            //test_profile->add_data(node,value_profile);
        }


        auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , level_set_disc.degree_FEM);

        for(auto& nd : nodes ){
            auto new_ret = level_set_disc(nd,msh,cl);
            ret0 = std::max( new_ret , ret0 ) ;
            ret1 = std::min( new_ret , ret1);
        }


    }

    //postoutput1.add_object(test_level_set);
    //postoutput1.add_object(test_profile);
    //postoutput1.write();

    std::cout<<"Initial time: MIN(phi) = "<<level_set_disc.phi_min<<", MAX(phi) = "<<level_set_disc.phi_max<< std::endl;
    std::cout<<"At time t = "<<time<<": MIN(phi) = "<<ret1<<" , MAX(phi) = "<<ret0<< std::endl;

}

template< typename FonctionD , typename Mesh , typename T >
void
testing_level_set_max_min(const Mesh msh , const FonctionD& level_set_disc , size_t time_step , std::vector<std::pair<T,T>>& min_max_vec )
{

    // CHECK MAX AND MIN
    T ret0 = -10.0;
    T ret1 = 10.0;
    

    for(auto& cl : msh.cells)
    {

        auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , level_set_disc.degree_FEM);

        for(auto& nd : nodes ){
            auto new_ret = level_set_disc(nd,msh,cl);
            ret0 = std::max( new_ret , ret0 ) ;
            ret1 = std::min( new_ret , ret1);
        }


    }

    min_max_vec.push_back(std::make_pair(ret1, ret0)) ;

    //std::cout<<"Initial time: MIN(phi) = "<<level_set_disc.phi_min<<", MAX(phi) = "<<level_set_disc.phi_max<< std::endl;
    //std::cout<<"At time t = "<<time<<": MIN(phi) = "<<ret1<<" , MAX(phi) = "<<ret0<< std::endl;

}


/*
template<typename T,typename Mesh>
std::vector< point<T,2> >
equidistriduted_nodes_subcell(const Mesh& msh,
          const typename Mesh::cell_type& cl,
          size_t degree, const std::vector<size_t>& indeces)
{
    typedef typename Mesh::point_type    point_type;

    auto qps = reference_nodes<T>(degree);

    std::vector<typename Mesh::point_type> pts;
    auto all_points = points(msh, cl);
    for (size_t i = 0 ; i < 4 ; i++) {
        pts.push_back( all_points[indeces[i]] );
    }

    auto v0 = pts[1] - pts[0];
    auto v1 = pts[2] - pts[1];
    auto v2 = pts[3] - pts[2];
    auto v3 = pts[3] - pts[0];

    std::vector< point<T,2> > ret;

    auto P = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].x() * (1-xi)*(1-eta) +
               0.25 * pts[1].x() * (1+xi)*(1-eta) +
               0.25 * pts[2].x() * (1+xi)*(1+eta) +
               0.25 * pts[3].x() * (1-xi)*(1+eta);
    };

    auto Q = [&](T xi, T eta) -> T {
        return 0.25 * pts[0].y() * (1-xi)*(1-eta) +
               0.25 * pts[1].y() * (1+xi)*(1-eta) +
               0.25 * pts[2].y() * (1+xi)*(1+eta) +
               0.25 * pts[3].y() * (1-xi)*(1+eta);
    };

    for (auto jtor = qps.begin(); jtor != qps.end(); jtor++)
    {
        for (auto itor = qps.begin(); itor != qps.end(); itor++)
        {
            auto qp_x = *itor;
            auto qp_y = *jtor;

            auto xi = qp_x.x();
            auto eta = qp_y.x();

            auto px = P(xi, eta);
            auto py = Q(xi, eta);

            ret.push_back( point_type(px, py) );
        }
    }

    return ret;
}

*/

/*

template<typename T , typename Mesh>
size_t
cells_counter(const Mesh& msh , const typename Mesh::cell_type& cl)
{

}
*/


/*
// OLD VERSION OF pt_in_cell
template<typename T, typename Mesh>
bool
pt_in_cell(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& cl)
{
    bool ret = 0;
    auto pts =points(msh,cl);
    for (size_t i = 0; i < pts.size(); i++)
    {
        if( pts[i].x()>=point_to_find.x() && pts[i].y()>=point_to_find.y() )
            ret = 1;
    }
    return ret;

}
*/
template<typename T, typename Mesh>
bool
pt_in_cell(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& cl)
{
    auto pts =points(msh,cl);

    //std::cout<<"Point to find "<<std::setprecision(15)<<point_to_find.x()<<", "<<point_to_find.y()<<std::endl;

   // std::cout<<"Min x "<<std::setprecision(15)<<pts[0].x()<<", max x "<<pts[1].x()<<std::endl;

    //std::cout<<"Min y "<<std::setprecision(15)<<pts[1].y()<<", max y "<<pts[2].y()<<std::endl;

    T epsilon = 1e-10;
     if( (pts[0].x()-epsilon)<=point_to_find.x() && (pts[1].x()+epsilon)>=point_to_find.x() && (pts[1].y()-epsilon)<=point_to_find.y() && (pts[2].y()+epsilon)>=point_to_find.y() )
         return TRUE;
    else
        return FALSE;

}

template<typename T, typename Mesh>
size_t
pt_in_subcell(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& agglocl)
{

    for (auto& offset_subcells : agglocl.user_data.offset_subcells)
    {
        //std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
        auto cl = msh.cells[offset_subcells];
        if( pt_in_cell(msh,point_to_find,cl) )
            return offset_subcells;
    }
    // IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
    std::cout<<"the point did not find is "<<point_to_find<<std::endl;
    std::cout<<"IT DIDN'T FIND THE POINT IN SUBCELL "<<offset(msh,agglocl)<<std::endl;
    std::cout<<"CELL vertices:"<<'\n';
    for(auto& pt: points(msh,agglocl) )
        std::cout<<" , pt = "<<pt;
    std::cout<<'\n'<<std::endl;
    throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");

}



template<typename T, typename Mesh>
std::vector<size_t>
pt_in_skeleton(const Mesh& msh, const point<T,2>& point_to_find )
{
    std::vector<size_t> cells_offset;
    for(auto& cl : msh.cells )
    {
        for (auto& offset_subcells : cl.user_data.offset_subcells)
        {
        //std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
            auto cl = msh.cells[offset_subcells];
            if( pt_in_cell(msh,point_to_find,cl) )
                cells_offset.push_back(offset_subcells);
            
        }
    }
    return cells_offset ;
    // IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
//    if( cells_offset.size() == 2  )
//        return cells_offset ;
//    else{
//        std::cout<<"IT IS NOT A SKELETON POINT: pt = "<<point_to_find<<". DIDN'T FIND THE POINT IN AGGLO CELL: "<<offset(msh,agglocl)<<std::endl;
//        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");
//    }

}



template<typename T, typename Mesh>
std::vector<size_t>
pt_in_subcell_skeleton(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& agglocl)
{
    std::vector<size_t> cells_offset;
    for (auto& offset_subcells : agglocl.user_data.offset_subcells)
    {
        //std::cout<<"OFFSET ORIGINAL CELL "<<offset_subcells<<std::endl;
        auto cl = msh.cells[offset_subcells];
        if( pt_in_cell(msh,point_to_find,cl) )
            cells_offset.push_back(offset_subcells);
            
    }
      return cells_offset ;
    // IF IT ARRIVES HERE, IT DIDN'T FIND THE POINT IN THE CELL.
//    if( cells_offset.size() == 2  )
//        return cells_offset ;
//    else{
//        std::cout<<"IT IS NOT A SKELETON POINT: pt = "<<point_to_find<<". DIDN'T FIND THE POINT IN AGGLO CELL: "<<offset(msh,agglocl)<<std::endl;
//        throw std::invalid_argument("Invalid point-> NOT IN AGGLO_CELL");
//    }

}


// SOSPETTO SIA UNITILE
/*
template<typename T , typename Mesh>
std::vector<size_t>
subcell_finder(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& cl, const mesh_init_params<T>& params)
{
    std::vector<size_t> ret(4);
    auto pts = points(msh,cl);
    auto hx = params.hx();
    auto hy = params.hy();
    bool check_already_found_x = FALSE;
    for (size_t i = 0; i < pts.size()-1; i++)
    {
        if( !check_already_found_x && pts[i].x()!= pts[i+1].x() && pts[i].x()<=point_to_find.x() && pts[i+1].x()>=point_to_find.x() )
        {
            if ( (pts[i].y()+hy)>=point_to_find.y() )
            {
                // point in the first row of subcells
                ret[0]=i;
                ret[1]=i+1;
                check_already_found_x = TRUE;
                for (size_t ii = 0; ii < pts.size(); ii++)
                {
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i].x() == pts[ii].x() ){
                        ret[2] = ii;
                    }
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i+1].x() == pts[ii].x() ){
                        ret[3] = ii;
                    }
                }
            }
            else
            {
                // point in the second row of subcells
                check_already_found_x = TRUE;
                for (size_t ii = 0; ii < pts.size(); ii++) // loop to find lower pts
                {
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i].x() == pts[ii].x() )
                    {
                        ret[0] = ii; // now I look for 3rd point
                        for (size_t j = 0; j < pts.size(); j++) {
                            if( (pts[ii].y()+hy) == pts[j].y() && pts[ii].x() == pts[j].x() ){
                                ret[2] = j;
                            }
                        }

                    } // end of the research for 1st and 3rd points
                    if( (pts[i].y()+hy) == pts[ii].y() && pts[i+1].x() == pts[ii].x() )
                    {
                        ret[1] = ii; // now I look for 4th point
                        for (size_t j = 0; j < pts.size(); j++) {
                            if( (pts[ii].y()+hy) == pts[j].y() && pts[ii+1].x() == pts[j].x() ){
                                ret[3] = j;
                            }
                        }

                    }// end of the research for 2nd and 4th points

                } // END of loop to find lower pts
            }  // END of else "search in the second row of subcells"

        } // END of the initial if-> I dont enter if ALREADY CHECKED or consecutive points have: same x or doesn't include pt to find

    } // end of the initial loop over the point
    return ret;
}

*/


template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix<T, Dynamic, 1>
make_bernstein_local_mass_matrix_lumped(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 2)
{

    //auto f_neigh = cl.user_data.f_neighbors;
    //auto d_neigh = cl.user_data.d_neighbors;

    cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
    //Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, (degree)+2); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi ;
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }

    /*
    Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);
    //Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps2 = integrate(msh, cl, (degree)+2); // integration of order 2k

    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);
        ret2 += qp.second * phi ;
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }

    std::cout<<"CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS LUMPED"<<'\n'<<ret-ret2<<'\n'<<std::endl;
    std::cout<<"FINE CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS LUMPED"<<std::endl;


    //ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3
    */
    return ret;
}







template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix<T, Dynamic, Dynamic>
make_bernstein_local_mass_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 1)
{

    //auto f_neigh = cl.user_data.f_neighbors;
    //auto d_neigh = cl.user_data.d_neighbors;

    cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    //Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi * phi.transpose();
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
    //ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3

    // CHECK INTEGRATION
    /*
    auto qps2 = integrate(msh, cl, 2*(degree)); // integration of order 2k
    Matrix<T, Dynamic, Dynamic> ret2 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);
        ret2 += qp.second * phi * phi.transpose();
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
    std::cout<<"CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS MATRIX"<<'\n'<<ret-ret2<<'\n'<<std::endl;
     std::cout<<"FINE CHECKING AMOUNT QUADRATURE POINTS IN LOCAL MASS MATRIX"<<std::endl;
    */
    return ret;
}


template<typename Mesh, typename T = typename Mesh::coordinate_type>
std::pair< Matrix<T, Dynamic, Dynamic> , Matrix<T, Dynamic, Dynamic> >
make_lagrangian_local_cij_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 1)
{
    cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix<T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2*(degree+di) ); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);
        std::cout<< "phi "<<'\n'<<phi<<std::endl;
        auto phi_grad = cb.eval_gradients(qp.first);
        std::cout<< "phi_grad "<<'\n'<<phi_grad<<std::endl;
        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
    }


    return std::make_pair(ret0,ret1);
}

template<typename Mesh,typename Velocity , typename T = typename Mesh::coordinate_type>
std::pair< Matrix<T, Dynamic, Dynamic> , Matrix<T, Dynamic, Dynamic> >
make_bernstein_local_cij_matrix_with_velocity(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree,  Velocity& u ,size_t di = 1 )
{
    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix<T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2*(degree+di) ); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);
        //std::cout<< "phi "<<'\n'<<phi<<std::endl;
        auto phi_grad = cb.eval_gradients(qp.first);
        auto u_val = u(qp.first , msh , cl );
        //std::cout<< "phi_grad "<<'\n'<<phi_grad<<std::endl;
        ret0 += qp.second * u_val.first * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * u_val.second *phi * ((phi_grad).col(1)).transpose();
    }


    return std::make_pair(ret0,ret1);
}

template<typename Mesh, typename T = typename Mesh::coordinate_type>
std::pair< Matrix<T, Dynamic, Dynamic> , Matrix<T, Dynamic, Dynamic> >
make_bernstein_local_cij_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 1)
{
    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix<T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2*(degree+di) ); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

    /*
    // CHECKING ORDER INTEGRATION
    Matrix<T, Dynamic, Dynamic> ret1_bis = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps2 = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps2)
    {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret1_bis += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

    std::cout<<"THE CHECKING FOR CIJ ORDER IS "<<'\n'<<ret1 - ret1_bis<<std::endl;
    */
    return std::make_pair(ret0,ret1);
}

template<typename Mesh, typename T = typename Mesh::coordinate_type ,  typename Fonction >
std::pair<Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1> >
make_bernstein_local_RHS_VEC(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree , const Fonction& f , size_t di = 0)
{

    cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    std::pair<Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1> > ret = std::make_pair( Matrix<T, Dynamic, 1>::Zero(cbs, 1) , Matrix<T, Dynamic, 1>::Zero(cbs, 1) );

    auto qps = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps)
    {
        auto b = cb.eval_basis(qp.first);
        auto value0 = f(qp.first,msh,cl).first;
        auto value1 = f(qp.first,msh,cl).second;
        ret.first += qp.second * value0 * b ;
        ret.second += qp.second * value1 * b ;
    }

    return ret;
}


template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Level_set_berstein_high_order_interpolation: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem

    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;


    // Assembling into global matrix
    SparseMatrix<T>                 Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix<T>                 Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1>      Global_Mass_Lumped; // Global mass, saved for FEM problem

    SparseMatrix<T>         cij_norm , nij0 , nij1 ;
    SparseMatrix<T>         cji_norm , nji0 , nji1 ;


    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Level_set_berstein_high_order_interpolation(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check)
    {
        if(!analytic_check)
        {
            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1>           RHS;    // Known term
            std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_y; // Position elements: Sparse Matrix Notation


            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            Global_Mass = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE ); // Known term (f,b_i)_i , b_i Lagrange basis fx

            Global_c_term_x = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );



            cij_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
            cji_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
            nij0 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nij1 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nji0 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nji1 = SparseMatrix<T>( ndof_FE, ndof_FE );
            /*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );

            //Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


           // std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );

                //auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
                // Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix (msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;


                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first ;
                    for (size_t j = 0; j < local_dim; j++)
                    {
                        /*
                        T c_ij0 = local_cij.first(i,j) ;
                        T c_ij1 = local_cij.second(i,j) ;

                        T c_ji0 = local_cij.first(j,i) ;
                        T c_ji1 = local_cij.second(j,i) ;
                        */
                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first ;

                        triplets.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                        triplets_c_term_x.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                        triplets_c_term_y.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );

                        /*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
                    //Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
                    //RHS(asm_map[i].first) += local_RHS(i) ;
                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop

            //std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            // Finalisation global assembling
            Global_Mass.setFromTriplets( triplets.begin(), triplets.end() );
            triplets.clear();


            // Finalisation global assembling
            Global_c_term_x.setFromTriplets( triplets_c_term_x.begin(), triplets_c_term_x.end() );
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets( triplets_c_term_y.begin(), triplets_c_term_y.end() );
            triplets_c_term_y.clear();

            /*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

            // NORM of c_ij

            cij_norm = ( Global_c_term_x.cwiseProduct(Global_c_term_x) + Global_c_term_y.cwiseProduct(Global_c_term_y) ).cwiseSqrt() ;
            //std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

            // MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient( cij_norm );
            nij1 = Global_c_term_y.cwiseQuotient( cij_norm );

            //std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


            // MATRIX c_ji
            SparseMatrix<T> cji_x = Global_c_term_x.adjoint() ;
            SparseMatrix<T> cji_y = Global_c_term_y.adjoint() ;

            // NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x)+cji_y.cwiseProduct(cji_y)).cwiseSqrt();

            // MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient( cji_norm );
            nji1 = cji_y.cwiseQuotient( cji_norm );




            //std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


              // CALCULATION OF THE SIZE + PLOTTING
              /*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




              //Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

            //std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
            //std::cout<<"local_dim size "<<local_dim<<std::endl;
            //std::cout<<"n_cls "<<n_cls<<std::endl;

              // Global solution saved as discontinuous HHO approach
              // Also saved min & max coefficients + position in HHO notation

              /*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

              /*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


              //std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


              //sol_FEM = sol_FEM_vandermonde ;
              //sol_HHO = sol_HHO_vandermonde ;
              //std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
              // Set of maximum and minimum

            timecounter tcbis ;

           // tcbis.tic();
            set_max_min();
           // tcbis.toc();
            //std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


              /*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

            tc_level_set.toc();
            std::cout << "--> Level set initialisation ( + transport pb matrices): t = " << tc_level_set << " seconds" << std::endl;

        }
        else
        {
            timecounter tc_level_set;
            tc_level_set.tic();

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );


            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;

            //std::cout<<"----> FOR ANALYTIC CHECK 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;


            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                }



                // Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++)
                    RHS_vandermonde(i) = level_set( qps[i]) ;


                auto sol_tmp = cod.solve(RHS_vandermonde) ;
                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {
                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;
                }


            } // end of cl loop

            tc_level_set.toc();
            std::cout << "INITIALISATION (projection of analytic solution - no matrix calculation - no min/max calculation) LEVEL SET: t = " << tc_level_set << " seconds" << std::endl;

        }


    }




    Level_set_berstein_high_order_interpolation()=default;


    void
    coefficients_mapping( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        //std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void
    coefficients_sfasamento( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER 'INVERSE' QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 0 ;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: check that sol_FEM already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        //std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)"<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


    // IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }


    // IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        size_t counter=0;
        //std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        for( const auto& cl:msh.cells)
        {
            if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(counter);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
            counter+=1;

        }
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;
        return ret; //to check if doesn't enter in the loop

    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient(pt,msh,cl);
        return ret/ret.norm();

    }
    /*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

    T divergence( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        auto grad = this->gradient( pt , msh , cl ) ;
        T grad_norm = grad.norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"2*r - grad_norm = "<<2.0/3.0 - grad_norm<<std::endl;

        //std::cout<<"Punto pt =  "<<pt<<", pt.x() - 0.5*(grad(0)+1) = "<<pt.x() - std::abs( 1.0/2.0 * (grad(0) +1.0 ))<<", pt.y() - 0.5*(grad(1)+1)  = "<<pt.y() - std::abs( 1.0/2.0 * (grad(1) +1.0 ))<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )* (  pow( grad(0), 2.0)  * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) +  pow( grad(1), 2.0) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0*  pow( grad(0), 2.0)  *  pow( grad(1), 2.0) * ( values_cell.dot(cb.eval_derivative_xy(pt)) ) ) ;

        //std::cout<<"Curvature = "<<-( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction )<<std::endl;

        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //auto grad_eval = cb.eval_gradients(pt) ;

        //T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )   ) ;

        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;


        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }


    void normal_continuous_setting()
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous creation, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    void gradient_continuous_setting()
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> grad_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }



    Eigen::Matrix<T,2,1> normal_cont_normalised( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }


    T divergence_cont_grad( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->grad_cont( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }





    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }



};



template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Level_set_berstein_high_order_interpolation_fast: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    //std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping



    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;





    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Level_set_berstein_high_order_interpolation_fast(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check)
    {

            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1>           RHS;    // Known term

            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);



            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );



            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


           // std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }



                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {


                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop



            set_max_min();

            tc_level_set.toc();
            std::cout << "--> Level set initialisation ( + transport pb matrices): t = " << tc_level_set << " seconds" << std::endl;



    }




    Level_set_berstein_high_order_interpolation_fast()=default;


    void
    coefficients_mapping( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        //std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void
    coefficients_sfasamento( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER 'INVERSE' QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 0 ;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER 'INVERSE' MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: check that sol_FEM already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        //std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)"<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


    // IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }


    // IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        size_t counter=0;
        //std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        for( const auto& cl:msh.cells)
        {
            if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(counter);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
            counter+=1;

        }
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;
        return ret; //to check if doesn't enter in the loop

    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient(pt,msh,cl);
        return ret/ret.norm();

    }
    /*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

    T divergence( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        auto grad = this->gradient( pt , msh , cl ) ;
        T grad_norm = grad.norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"2*r - grad_norm = "<<2.0/3.0 - grad_norm<<std::endl;

        //std::cout<<"Punto pt =  "<<pt<<", pt.x() - 0.5*(grad(0)+1) = "<<pt.x() - std::abs( 1.0/2.0 * (grad(0) +1.0 ))<<", pt.y() - 0.5*(grad(1)+1)  = "<<pt.y() - std::abs( 1.0/2.0 * (grad(1) +1.0 ))<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )* (  pow( grad(0), 2.0)  * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) +  pow( grad(1), 2.0) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0*  pow( grad(0), 2.0)  *  pow( grad(1), 2.0) * ( values_cell.dot(cb.eval_derivative_xy(pt)) ) ) ;

        //std::cout<<"Curvature = "<<-( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction )<<std::endl;

        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //auto grad_eval = cb.eval_gradients(pt) ;

        //T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )   ) ;

        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;


        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }


    template< typename Transport_Method >
    void normal_continuous_setting(const Transport_Method& method )
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous creation, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }



    template<typename Transport_Method >
    void gradient_continuous_setting( const Transport_Method& method)
    {


        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> grad_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }



    Eigen::Matrix<T,2,1> normal_cont_normalised( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }


    T divergence_cont_grad( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->grad_cont( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }





    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }



};




template< typename Mesh , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Transport_problem_method
{

    Mesh msh ;
    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    //std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem


    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;


    // Assembling into global matrix
    SparseMatrix<T>                 Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix<T>                 Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1>      Global_Mass_Lumped; // Global mass, saved for FEM problem

    SparseMatrix<T>         cij_norm , nij0 , nij1 ;
    SparseMatrix<T>         cji_norm , nji0 , nji1 ;

    Transport_problem_method(const FiniteSpace& fe_data , const Mesh & msh )
          : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE)
      {

              timecounter tc_level_set;
              tc_level_set.tic();

              std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation
              std::vector< Triplet<T> >       triplets_c_term_x; // Position elements: Sparse Matrix Notation
              std::vector< Triplet<T> >       triplets_c_term_y; // Position elements: Sparse Matrix Notation





              Global_Mass = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx


              Global_c_term_x = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
              Global_c_term_y = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx

              Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

              local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );


              cij_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
              cji_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
              nij0 = SparseMatrix<T>( ndof_FE, ndof_FE );
              nij1 = SparseMatrix<T>( ndof_FE, ndof_FE );
              nji0 = SparseMatrix<T>( ndof_FE, ndof_FE );
              nji1 = SparseMatrix<T>( ndof_FE, ndof_FE );



              CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
              //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


              //std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

              //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
              for( const auto& cl : msh.cells )
              {
                  size_t cell_offset = offset(msh, cl) ;

                  if(cell_offset == 0)
                  {
                      auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                      cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                      for (size_t i = 0; i < local_dim; i++)
                      {
                          // Local vandermonde matrix
                          local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                      }

                      cod.compute(local_vandermonde);
                      //cod_2.compute(local_vandermonde);
                  }


                  auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );


                  // Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                  auto local_cij = make_bernstein_local_cij_matrix (msh, cl, degree_FEM);

                  auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;


                  // Costruction of the coefficients of the Bernstein basis
                  auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                  // Assembling triplets for global problem
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map_i = connectivity_matrix[cell_offset][i].first ;
                      for (size_t j = 0; j < local_dim; j++)
                      {

                          size_t asm_map_j = connectivity_matrix[cell_offset][j].first ;

                          triplets.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                          triplets_c_term_x.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                          triplets_c_term_y.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );


                      }
                      Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);

                  }


              } // end of cl loop

              //std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
              // Finalisation global assembling
              Global_Mass.setFromTriplets( triplets.begin(), triplets.end() );
              triplets.clear();


              // Finalisation global assembling
              Global_c_term_x.setFromTriplets( triplets_c_term_x.begin(), triplets_c_term_x.end() );
              triplets_c_term_x.clear();
              Global_c_term_y.setFromTriplets( triplets_c_term_y.begin(), triplets_c_term_y.end() );
              triplets_c_term_y.clear();


              // NORM of c_ij

              cij_norm = ( Global_c_term_x.cwiseProduct(Global_c_term_x) + Global_c_term_y.cwiseProduct(Global_c_term_y) ).cwiseSqrt() ;
              //std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

              // MATRIX n_ij
              nij0 = Global_c_term_x.cwiseQuotient( cij_norm );
              nij1 = Global_c_term_y.cwiseQuotient( cij_norm );

              //std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


              // MATRIX c_ji
              SparseMatrix<T> cji_x = Global_c_term_x.adjoint() ;
              SparseMatrix<T> cji_y = Global_c_term_y.adjoint() ;

              // NORM of c_ji -> i.e. c_ij transposed
              cji_norm = (cji_x.cwiseProduct(cji_x)+cji_y.cwiseProduct(cji_y)).cwiseSqrt();

              // MATRIX n_ij (TRANSPOSED)
              nji0 = cji_x.cwiseQuotient( cji_norm );
              nji1 = cji_y.cwiseQuotient( cji_norm );





              tc_level_set.toc();
              std::cout << "Construction of Transport Problem method : machine time t = " << tc_level_set << " seconds" << std::endl;

      }




};

template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Level_set_berstein_high_order_interpolation_grad_cont: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem

    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;


    // Assembling into global matrix
    SparseMatrix<T>                 Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix<T>                 Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1>      Global_Mass_Lumped; // Global mass, saved for FEM problem

    SparseMatrix<T>         cij_norm , nij0 , nij1 ;
    SparseMatrix<T>         cji_norm , nji0 , nji1 ;


    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Level_set_berstein_high_order_interpolation_grad_cont(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check)
    {
        if(!analytic_check)
        {
            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1>           RHS;    // Known term
            std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_y; // Position elements: Sparse Matrix Notation


            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            Global_Mass = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE ); // Known term (f,b_i)_i , b_i Lagrange basis fx

            Global_c_term_x = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );



            cij_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
            cji_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
            nij0 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nij1 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nji0 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nji1 = SparseMatrix<T>( ndof_FE, ndof_FE );
            /*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );

            //Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


            //std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );

                //auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
                // Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix (msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;


                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first ;
                    for (size_t j = 0; j < local_dim; j++)
                    {
                        /*
                        T c_ij0 = local_cij.first(i,j) ;
                        T c_ij1 = local_cij.second(i,j) ;

                        T c_ji0 = local_cij.first(j,i) ;
                        T c_ji1 = local_cij.second(j,i) ;
                        */
                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first ;

                        triplets.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                        triplets_c_term_x.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                        triplets_c_term_y.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );

                        /*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
                    //Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
                    //RHS(asm_map[i].first) += local_RHS(i) ;
                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop

            //std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            // Finalisation global assembling
            Global_Mass.setFromTriplets( triplets.begin(), triplets.end() );
            triplets.clear();


            // Finalisation global assembling
            Global_c_term_x.setFromTriplets( triplets_c_term_x.begin(), triplets_c_term_x.end() );
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets( triplets_c_term_y.begin(), triplets_c_term_y.end() );
            triplets_c_term_y.clear();

            /*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

            // NORM of c_ij

            cij_norm = ( Global_c_term_x.cwiseProduct(Global_c_term_x) + Global_c_term_y.cwiseProduct(Global_c_term_y) ).cwiseSqrt() ;
            //std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

            // MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient( cij_norm );
            nij1 = Global_c_term_y.cwiseQuotient( cij_norm );

            //std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


            // MATRIX c_ji
            SparseMatrix<T> cji_x = Global_c_term_x.adjoint() ;
            SparseMatrix<T> cji_y = Global_c_term_y.adjoint() ;

            // NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x)+cji_y.cwiseProduct(cji_y)).cwiseSqrt();

            // MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient( cji_norm );
            nji1 = cji_y.cwiseQuotient( cji_norm );




            //std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


              // CALCULATION OF THE SIZE + PLOTTING
              /*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




              //Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

            //std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
            //std::cout<<"local_dim size "<<local_dim<<std::endl;
            //std::cout<<"n_cls "<<n_cls<<std::endl;

              // Global solution saved as discontinuous HHO approach
              // Also saved min & max coefficients + position in HHO notation

              /*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

              /*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


              //std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


              //sol_FEM = sol_FEM_vandermonde ;
              //sol_HHO = sol_HHO_vandermonde ;
              //std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
              // Set of maximum and minimum

            timecounter tcbis ;

            //tcbis.tic();
            set_max_min();
            //tcbis.toc();
            //std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


              /*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

            tc_level_set.toc();
            std::cout << "Initialisation level set (+ matrices transport pb) : t = " << tc_level_set << " seconds" << std::endl;

        }
        else
        {
            timecounter tc_level_set;
            tc_level_set.tic();

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );


            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;

            //std::cout<<"----> FOR ANALYTIC CHECK 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;


            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                }



                // Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++)
                    RHS_vandermonde(i) = level_set( qps[i]) ;


                auto sol_tmp = cod.solve(RHS_vandermonde) ;
                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {
                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;
                }


            } // end of cl loop

            tc_level_set.toc();
            std::cout << bold << yellow << "Initialisation level set: t = " << tc_level_set << " seconds" << reset << std::endl;

        }


    }




    Level_set_berstein_high_order_interpolation_grad_cont()=default;


    void
    coefficients_mapping( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        //std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void
    coefficients_sfasamento( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 0 ;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: sol_FEM has to be already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)."<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient_disc(pt,msh,cl);
        return ret/ret.norm();

    }

    T divergence_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient_disc( pt , msh , cl )).norm() ;
        auto grad_eval = cb.eval_gradients(pt) ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )
                                                             ) ;
        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }


    void normal_continuous_setting()
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            //timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous setting, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    void gradient_continuous_setting()
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }



    Eigen::Matrix<T,2,1> normal( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }


    T divergence( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }

   
//    void curvature_avg_continuous_setting()
//    {
//
//        bool first_cut_cell_found = FALSE ;
//        T distance_pts = 0.0;
//        point<T,2> first_point ;
//        point<T,2> cell_end_point;
//
//        for(auto& cl : msh.cells)
//        {
//
//            if(cl.user_data.location == element_location::ON_INTERFACE)
//            {
//
//                if(!first_cut_cell_found)
//                {
//                        bool agglo_cl = cl.user_data.highlight ;
//                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
//                        std::vector< size_t > index_inner_cls ;
//                        if( agglo_cl ){
//                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
//                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                        }
//        //                if( agglo_cl && amount_sub_cls == 2 )
//        //                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                if( agglo_cl && amount_sub_cls == 3 ){
//        //                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                    index_inner_cls.push_back( 2.0*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//        //                }
//                        size_t pos_index = 0;
//                        size_t pos_index_bis = 0;
//
//                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                        {
//                            T val0 = ls_cell.divergence( *interface_point );
//
//                            point<T,2> curv_var = point_type(distance_pts , 0.0);
//                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
//                                test_curv_var_cell->add_data(curv_var, val0);
//
//
//                             if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
//                             {
//                                 auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
//                                 assert(offset_cells.size() == 2);
//                                 auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
//                                 auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
//                                 T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
//                                 T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
//
//                                 test_inner_cell->add_data(curv_var, val_skeleton0);
//                                 test_inner_cell->add_data(curv_var, val_skeleton1);
//                                 if( pos_index_bis+1 < index_inner_cls.size() )
//                                     pos_index_bis++;
//                             }
//
//                            test_curv_var_divergence0->add_data(curv_var, val0);
//                            if(*interface_point == *(cl.user_data.interface.end() -1))
//                                distance_pts +=  0.0 ;
//                            else
//                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                            // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
//                            pos_index++;
//                        }
//                        first_cut_cell_found = TRUE;
//                        first_point = *cl.user_data.interface.begin() ;
//                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                    }
//                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
//                    {
//                        for(auto& cl : msh_i.cells)
//                        {
//                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
//                            {
//                                ls_cell.cell_assignment(cl);
//
//                                bool agglo_cl = cl.user_data.highlight ;
//                                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
//                                std::vector< size_t > index_inner_cls ;
//                                if( agglo_cl ){
//                                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
//                                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                                }
//                                size_t pos_index = 0;
//                                size_t pos_index_bis = 0;
//
//                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                                {
//
//                                    T val0 = ls_cell.divergence( *interface_point );
//
//                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
//                                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
//                                        test_curv_var_cell->add_data(curv_var, val0);
//
//                                    test_curv_var_divergence0->add_data(curv_var, val0);
//
//                                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
//                                    {
//                                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
//                                        assert(offset_cells.size() == 2);
//                                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
//                                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
//                                        T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
//                                        T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
//
//                                        test_inner_cell->add_data(curv_var, val_skeleton0);
//                                        test_inner_cell->add_data(curv_var, val_skeleton1);
//                                        if( pos_index_bis+1 < index_inner_cls.size() )
//                                            pos_index_bis++;
//                                    }
//
//
//                                    if(*interface_point == *(cl.user_data.interface.end() -1))
//                                        distance_pts += 0.0 ;
//                                    else
//                                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                                     pos_index++;
//                                }
//                                cell_end_point = *(cl.user_data.interface.end() -1) ;
//                            }
//
//                        }
//
//                    }
//                    else
//                        break;
//
//                }
//
//
//            }
//
//
//    }


    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }
            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM)
    {
        size_t counter_FEM = 0 ;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if(!file_FEM.is_open()) {
            exit(10);
        }

        while(!file_FEM.eof())
        {
            if( counter_FEM < sol_FEM.size() )
            {
                T val;
                file_FEM >> val ;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
                //std::cout<<val <<" , " ;
            }
            else
                break;

        }
        std::cout<<std::endl ;
        file_FEM.close();

        // Uploading also sol_HHO
        for(size_t counter_HHO = 0 ; counter_HHO < n_cls ; counter_HHO++)
        {
            for (size_t i = 0; i < local_dim; i++)
            {
                size_t asm_map =  connectivity_matrix[counter_HHO][i].first ;
                sol_HHO(i,counter_HHO) = sol_FEM( asm_map ) ;
            }
        }



    }




};





template< typename Mesh  >
struct Interface_parametrisation
{
    typedef typename Mesh::cell_type       cell_type;
    typedef typename Mesh::coordinate_type       T;
    Mesh msh_orig ;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh msh_agglo;
    size_t degree_det ;
    size_t basis_degree , basis_size;
    
   
    
    Interface_parametrisation( const Mesh & msh , size_t degree ):msh_orig(msh),basis_degree(degree),basis_size(degree+1),degree_det(2*degree){}

    
    
    Matrix<T, 2, 1>
    operator()( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
    {

       
        auto physical_pts = cl.user_data.interface ;
        
        cell_basis_Lagrange_1d_reference <Mesh,T> cb(msh, cl, basis_degree);
        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
                
        auto basis = cb.eval_basis_1d(pt) ;
                  
        auto size_pts = physical_pts.size() ;
        auto size_cls = (size_pts-1)/basis_degree ;
                  
                  
        if (size_cls == 1){
              
            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_degree].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_degree].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_degree].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_degree].y();
                                 
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_degree].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_degree].y();
            }
                      
            return ret;

       }
    }
    
    Matrix<T, 2, 1>
    operator()(const T& pt, int r = 0) const
    {

        return this->operator()(pt, msh_agglo, agglo_LS_cl,r) ;
      
    }
    
    
    
    Matrix<T, 2, 1>
    derivative( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
    {

       
        auto physical_pts = cl.user_data.interface ;
        
        cell_basis_Lagrange_1d_reference <Mesh,T> cb(msh, cl, basis_degree);
        Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
                
        auto basis = cb.eval_gradients_1d(pt) ;
                  
        auto size_pts = physical_pts.size() ;
        auto size_cls = (size_pts-1)/basis_degree ;
                  
                  
        if (size_cls == 1){
              
            ret(0) += basis(0)*physical_pts[0].x();
            ret(0) += basis(1)*physical_pts[basis_degree].x();
            ret(1) += basis(0)*physical_pts[0].y();
            ret(1) += basis(1)*physical_pts[basis_degree].y();
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i-1].x();
                ret(1) += basis(i)*physical_pts[i-1].y();
            }
            return ret;
        }
        else
        {
            ret(0) += basis(0)*physical_pts[0+ r * basis_degree].x();
            ret(0) += basis(1)*physical_pts[basis_degree+ r * basis_degree].x();
            ret(1) += basis(0)*physical_pts[0+ r * basis_degree].y();
            ret(1) += basis(1)*physical_pts[basis_degree+ r * basis_degree].y();
                                 
            for(size_t i = 2 ; i < basis_size ; i++)
            {
                ret(0) += basis(i)*physical_pts[i -1 + r * basis_degree].x();
                ret(1) += basis(i)*physical_pts[i -1 + r * basis_degree].y();
            }
                      
            return ret;

       }
    }
    
    
    T
    jacobian( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
    {
        return (this->derivative(pt, msh, cl,r)).norm();
    }
    
    
    
    Matrix<T, 2, 1>
    tangent( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
    {

        auto der = (this->derivative(pt, msh, cl,r)) ;
        return der/der.norm();
       
        
    }
    
    Matrix<T, 2, 1>
    normal_old( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
       {

           
            auto physical_pts = cl.user_data.interface ;
            
            cell_basis_Lagrange_1d_reference <Mesh,T> cb(msh, cl, basis_degree);
            Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
            Matrix<T, 2, 1> curv_double_der = Matrix<T, 2, 1>::Zero(2, 1);
            auto basis = cb.eval_double_derivative_1d(pt) ;
                      
            auto size_pts = physical_pts.size() ;
            auto size_cls = (size_pts-1)/basis_degree ;
                      
            auto curv_der = (this->derivative(pt, msh, cl,r)) ;
            auto curv_der_norm = curv_der.norm() ;
           
            if (size_cls == 1){
                  
                curv_double_der(0) += basis(0)*physical_pts[0].x();
                curv_double_der(0) += basis(1)*physical_pts[basis_degree].x();
                curv_double_der(1) += basis(0)*physical_pts[0].y();
                curv_double_der(1) += basis(1)*physical_pts[basis_degree].y();
                for(size_t i = 2 ; i < basis_size ; i++)
                {
                    curv_double_der(0) += basis(i)*physical_pts[i-1].x();
                    curv_double_der(1) += basis(i)*physical_pts[i-1].y();
                }
                //return ret;
            }
            else
            {
                curv_double_der(0) += basis(0)*physical_pts[0+ r * basis_degree].x();
                curv_double_der(0) += basis(1)*physical_pts[basis_degree+ r * basis_degree].x();
                curv_double_der(1) += basis(0)*physical_pts[0+ r * basis_degree].y();
                curv_double_der(1) += basis(1)*physical_pts[basis_degree+ r * basis_degree].y();
                                     
                for(size_t i = 2 ; i < basis_size ; i++)
                {
                    curv_double_der(0) += basis(i)*physical_pts[i -1 + r * basis_degree].x();
                    curv_double_der(1) += basis(i)*physical_pts[i -1 + r * basis_degree].y();
                }
                          
                //return ret;

           }
           T coeff = curv_der(0)*curv_double_der(0) + curv_der(1)*curv_double_der(1) ;
           ret(0) = curv_double_der(0)/curv_der_norm - curv_der(0)/pow(curv_der_norm,3)*coeff;
           ret(1) = curv_double_der(1)/curv_der_norm - curv_der(1)/pow(curv_der_norm,3)*coeff;
           
          
            return -ret/ret.norm() ;
           
       }
    Matrix<T, 2, 1>
    normal( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
       {

           Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
           auto tan_pt = (this->tangent(pt, msh, cl,r)) ;
           ret(0) = tan_pt(1);
           ret(1) = -tan_pt(0);
           return ret;
           
       }
    
    T
    curvature( const T& pt, const Mesh & msh,  cell_type& cl, int r = 0 ) const
    {
        auto physical_pts = cl.user_data.interface ;
         
         cell_basis_Lagrange_1d_reference <Mesh,T> cb(msh, cl, basis_degree);
         Matrix<T, 2, 1> ret = Matrix<T, 2, 1>::Zero(2, 1);
         Matrix<T, 2, 1> curv_double_der = Matrix<T, 2, 1>::Zero(2, 1);
         auto basis = cb.eval_double_derivative_1d(pt) ;
                   
         auto size_pts = physical_pts.size() ;
        auto size_cls = (size_pts-1)/basis_degree ;
                   
         auto curv_der = (this->derivative(pt, msh, cl,r)) ;
         auto curv_der_norm = curv_der.norm() ;
        
         if (size_cls == 1){
               
             curv_double_der(0) += basis(0)*physical_pts[0].x();
             curv_double_der(0) += basis(1)*physical_pts[basis_degree].x();
             curv_double_der(1) += basis(0)*physical_pts[0].y();
             curv_double_der(1) += basis(1)*physical_pts[basis_degree].y();
             for(size_t i = 2 ; i < basis_size ; i++)
             {
                 curv_double_der(0) += basis(i)*physical_pts[i-1].x();
                 curv_double_der(1) += basis(i)*physical_pts[i-1].y();
             }
             //return ret;
         }
         else
         {
             curv_double_der(0) += basis(0)*physical_pts[0+ r * basis_degree].x();
             curv_double_der(0) += basis(1)*physical_pts[basis_degree+ r * basis_degree].x();
             curv_double_der(1) += basis(0)*physical_pts[0+ r * basis_degree].y();
             curv_double_der(1) += basis(1)*physical_pts[basis_degree+ r * basis_degree].y();
                                  
             for(size_t i = 2 ; i < basis_size ; i++)
             {
                 curv_double_der(0) += basis(i)*physical_pts[i -1 + r * basis_degree].x();
                 curv_double_der(1) += basis(i)*physical_pts[i -1 + r * basis_degree].y();
             }
                       
             //return ret;

        }
        T coeff = curv_der(0)*curv_double_der(0) + curv_der(1)*curv_double_der(1) ;
        ret(0) = curv_double_der(0)/curv_der_norm - curv_der(0)/pow(curv_der_norm,3)*coeff;
        ret(1) = curv_double_der(1)/curv_der_norm - curv_der(1)/pow(curv_der_norm,3)*coeff;
        //return -ret/ret.norm() ;

        //std::cout<<"curv = "<< ret.norm()/curv_der_norm<<std::endl ;
        
        return ret.norm()/curv_der_norm ;
           
    }
    
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( msh_orig.cells[offset_subcells] );

            }
        }

    }
    
    void mesh_assignment(const Mesh& msh)
    {
        msh_agglo = msh ;

    }
};












template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Level_set_berstein: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    //std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;




    //Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    //Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    //Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    //Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    //Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    //Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    //Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    //Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_low_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_low_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_1 ;



    Eigen::Matrix<T, Dynamic, Dynamic> divergence_c_HHO ;
    Eigen::Matrix<T, Dynamic, 1> divergence_c_FEM ;
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix_grad ;
    size_t ndof_FE_grad , local_dim_grad ;
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix_div ;
    size_t ndof_FE_div , local_dim_div ;
    size_t degree_grad , degree_div ;

    Level_set_berstein(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , const FiniteSpace & fe_data_gradient , const FiniteSpace & fe_data_divergence , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check) , ndof_FE_grad(fe_data_gradient.ndof_FE) , local_dim_grad(fe_data_gradient.local_ndof),connectivity_matrix_grad(fe_data_gradient.connectivity_matrix), ndof_FE_div(fe_data_divergence.ndof_FE) , local_dim_div(fe_data_divergence.local_ndof),connectivity_matrix_div(fe_data_divergence.connectivity_matrix), degree_grad(fe_data_gradient.order) , degree_div(fe_data_divergence.order)
    {

            timecounter tc_level_set;
            tc_level_set.tic();


            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);



            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            //normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            //normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            //normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            //normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            //gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            //gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            //gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            //gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_low_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim_grad, n_cls);
            gradient_c_HHO_low_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim_grad, n_cls);
            gradient_c_FEM_low_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE_grad , 1 );
            gradient_c_FEM_low_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE_grad , 1 );

            divergence_c_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim_div , n_cls );
            divergence_c_FEM = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE_div , 1 );




            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );

            //Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


            //std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }





                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {

                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop




            set_max_min();

            tc_level_set.toc();
            std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;



    }




    Level_set_berstein()=default;


    void
    coefficients_mapping( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        //std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void
    coefficients_sfasamento( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 0 ;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: sol_FEM has to be already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)."<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW

    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient_disc(pt,msh,cl);
        return ret/ret.norm();

    }

    T divergence_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient_disc( pt , msh , cl )).norm() ;
        auto grad_eval = cb.eval_gradients(pt) ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )  ) ;
        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }

    /*
    template< typename Transport_Method >
    void normal_continuous_setting(const Transport_Method& method )
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            //timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous setting, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    template<typename Transport_Method >
    void gradient_continuous_setting_k( const Transport_Method& method)
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }
    */

    template<typename Transport_Method >
    void gradient_continuous_setting( const Transport_Method& method)
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad );
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_grad)+1); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_grad; i++)
            {

                size_t asm_map =  connectivity_matrix_grad[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_low_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_low_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim_grad ; i++){
                size_t asm_map =  connectivity_matrix_grad[counter_bis][i].first ;
                gradient_c_HHO_low_0(i,counter_bis) = gradient_c_FEM_low_0( asm_map ) ;
                gradient_c_HHO_low_1(i,counter_bis) = gradient_c_FEM_low_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }
    /*
    Eigen::Matrix<T,2,1> gradient_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }
    */
    Eigen::Matrix<T,2,1> gradient_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad );
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }

    /*
    Eigen::Matrix<T,2,1> normal_grad_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }
    */
    Eigen::Matrix<T,2,1> normal_grad_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }

    /*
    T divergence_grad_cont_k( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM );
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->gradient_cont_k( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }
    */
    T divergence_grad_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad );
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->gradient_cont( pt , msh , cl )).norm() ;


        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }

    template<typename Transport_Method >
    void divergence_continuous_setting( const Transport_Method& method )
    {



        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"check integration order"<<std::endl;
        for(auto& cl : msh.cells)
        {
            //std::cout<<"cl = "<<offset(msh,cl)<<std::endl;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_div );
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;


            auto qps = integrate(msh, cl, 2*(degree_div ) + 1  ); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_grad_cont( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc += qp.second * disc_divergence * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            /*
            auto qps_prova = integrate(msh, cl, 2*(degree_FEM)+2); // integration of order 2k
            Matrix<T, Dynamic, 1> ret_loc_prova = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc_prova += qp.second * disc_divergence * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            std::cout<<ret_loc-ret_loc_prova<<std::endl;

*/            //std::cout<<ret_loc_prova<<std::endl;

            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_div; i++)
            {

                size_t asm_map =  connectivity_matrix_div[cell_offset][i].first ;

                ret( asm_map ) += ret_loc(i) ;




            }



        }
        //std::cout<<"FINE integration order"<<std::endl;
        divergence_c_FEM = solver_global_mass.solve(ret);

        //std::cout<<"local_dim_grad = "<<local_dim_grad<<" , ndof_FE_grad = "<<ndof_FE_grad<<std::endl;

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim_div ; i++){
                size_t asm_map =  connectivity_matrix_div[counter_bis][i].first ;
                //std::cout<<"counter_bis = "<<counter_bis<<" , i = "<<i<<" , asm_map = "<<asm_map<<std::endl;
                divergence_c_HHO(i,counter_bis) = divergence_c_FEM( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }


    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

       size_t counter = offset(msh,cl);
       cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_div);
       //auto values_cell = divergence_c_HHO.col(counter);
       return (divergence_c_HHO.col(counter)).dot( cb.eval_basis(pt) );
    }



    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }
            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM)
    {
        size_t counter_FEM = 0 ;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if(!file_FEM.is_open()) {
            exit(10);
        }

        while(!file_FEM.eof())
        {
            if( counter_FEM < sol_FEM.size() )
            {
                T val;
                file_FEM >> val ;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
                //std::cout<<val <<" , " ;
            }
            else
                break;

        }
        std::cout<<std::endl ;
        file_FEM.close();

        // Uploading also sol_HHO
        for(size_t counter_HHO = 0 ; counter_HHO < n_cls ; counter_HHO++)
        {
            for (size_t i = 0; i < local_dim; i++)
            {
                size_t asm_map =  connectivity_matrix[counter_HHO][i].first ;
                sol_HHO(i,counter_HHO) = sol_FEM( asm_map ) ;
            }
        }



    }




};


template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Level_set_berstein_curvature2: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    //std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;




    //Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    //Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    //Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    //Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    //Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    //Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    //Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    //Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_low_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_low_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_low_1 ;



    Eigen::Matrix<T, Dynamic, Dynamic> divergence_c_HHO ;
    Eigen::Matrix<T, Dynamic, 1> divergence_c_FEM ;
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix_grad ;
    size_t ndof_FE_grad , local_dim_grad ;
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix_div ;
    size_t ndof_FE_div , local_dim_div ;
    size_t degree_grad , degree_div ;

    Level_set_berstein_curvature2(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , const FiniteSpace & fe_data_gradient , const FiniteSpace & fe_data_divergence , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check) , ndof_FE_grad(fe_data_gradient.ndof_FE) , local_dim_grad(fe_data_gradient.local_ndof),connectivity_matrix_grad(fe_data_gradient.connectivity_matrix), ndof_FE_div(fe_data_divergence.ndof_FE) , local_dim_div(fe_data_divergence.local_ndof),connectivity_matrix_div(fe_data_divergence.connectivity_matrix), degree_grad(fe_data_gradient.order) , degree_div(fe_data_divergence.order)
    {

            timecounter tc_level_set;
            tc_level_set.tic();


            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);



            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            //normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            //normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            //normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            //normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            //gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            //gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            //gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            //gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_low_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim_grad, n_cls);
            gradient_c_HHO_low_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim_grad, n_cls);
            gradient_c_FEM_low_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE_grad , 1 );
            gradient_c_FEM_low_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE_grad , 1 );

            divergence_c_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim_div , n_cls );
            divergence_c_FEM = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE_div , 1 );




            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );

            //Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


            //std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }





                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {

                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop




            set_max_min();

            tc_level_set.toc();
            std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;



    }




    Level_set_berstein_curvature2()=default;


    void
    coefficients_mapping( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        //std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void
    coefficients_sfasamento( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 0 ;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: sol_FEM has to be already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)."<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW

    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient_disc(pt,msh,cl);
        return ret/ret.norm();

    }

    T divergence_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient_disc( pt , msh , cl )).norm() ;
        auto grad_eval = cb.eval_gradients(pt) ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )
                                                             ) ;
        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }


    template<typename Transport_Method >
    void gradient_continuous_setting( const Transport_Method& method)
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE_grad, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad );
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_grad)+1); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_grad; i++)
            {

                size_t asm_map =  connectivity_matrix_grad[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_low_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_low_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim_grad ; i++){
                size_t asm_map =  connectivity_matrix_grad[counter_bis][i].first ;
                gradient_c_HHO_low_0(i,counter_bis) = gradient_c_FEM_low_0( asm_map ) ;
                gradient_c_HHO_low_1(i,counter_bis) = gradient_c_FEM_low_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> gradient_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad );
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    Eigen::Matrix<T,2,1> normal_grad_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_grad);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_low_0.col(counter);
        auto values_cell1 = gradient_c_HHO_low_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }




    template<typename Transport_Method >
    void divergence_continuous_setting( const Transport_Method& method )
    {



        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(ndof_FE_div, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"check integration order"<<std::endl;
        for(auto& cl : msh.cells)
        {
            //std::cout<<"cl = "<<offset(msh,cl)<<std::endl;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_div );
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;


            auto qps = integrate(msh, cl, 2*(degree_div ) + 1  ); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_divergence = (this->divergence_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret_loc += qp.second * disc_divergence * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }

            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim_div; i++)
            {

                size_t asm_map =  connectivity_matrix_div[cell_offset][i].first ;

                ret( asm_map ) += ret_loc(i) ;




            }



        }
        //std::cout<<"FINE integration order"<<std::endl;
        divergence_c_FEM = solver_global_mass.solve(ret);

        //std::cout<<"local_dim_grad = "<<local_dim_grad<<" , ndof_FE_grad = "<<ndof_FE_grad<<std::endl;

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim_div ; i++){
                size_t asm_map =  connectivity_matrix_div[counter_bis][i].first ;
                //std::cout<<"counter_bis = "<<counter_bis<<" , i = "<<i<<" , asm_map = "<<asm_map<<std::endl;
                divergence_c_HHO(i,counter_bis) = divergence_c_FEM( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }


    void divergence_continuous_setting_avg()
    {



        Array<T,Dynamic,1> counting_avg = Array<T,Dynamic,1>::Zero(ndof_FE_div) ;
        Array<T,Dynamic,1> sum = Array<T,Dynamic,1>::Zero(ndof_FE_div) ;


        size_t counter_cl = 0 ;
        for(auto& cl : msh.cells)
        {
            size_t i = 0;
            auto qps = equidistriduted_nodes_ordered_bis<T>(msh, cl, degree_div );
            for(auto& qp : qps )
            {
                size_t asm_map =  connectivity_matrix_div[counter_cl][i].first ;
                sum( asm_map ) += (this->divergence_disc( qp , msh , cl )) ;
                counting_avg(asm_map)++;
            }
        }

        divergence_c_FEM = (sum.array()).cwiseQuotient(counting_avg);


        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                divergence_c_HHO(i,counter_bis) = divergence_c_FEM( asm_map );
            }

        }

    }



    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

       size_t counter = offset(msh,cl);
       cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_div);
       //auto values_cell = divergence_c_HHO.col(counter);
       return (divergence_c_HHO.col(counter)).dot( cb.eval_basis(pt) );
    }



    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }
            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM)
    {
        size_t counter_FEM = 0 ;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if(!file_FEM.is_open()) {
            exit(10);
        }

        while(!file_FEM.eof())
        {
            if( counter_FEM < sol_FEM.size() )
            {
                T val;
                file_FEM >> val ;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
                //std::cout<<val <<" , " ;
            }
            else
                break;

        }
        std::cout<<std::endl ;
        file_FEM.close();

        // Uploading also sol_HHO
        for(size_t counter_HHO = 0 ; counter_HHO < n_cls ; counter_HHO++)
        {
            for (size_t i = 0; i < local_dim; i++)
            {
                size_t asm_map =  connectivity_matrix[counter_HHO][i].first ;
                sol_HHO(i,counter_HHO) = sol_FEM( asm_map ) ;
            }
        }



    }




};






template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct Level_set_berstein_high_order_interpolation_grad_cont_fast: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    //std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping


    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;




    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    Level_set_berstein_high_order_interpolation_grad_cont_fast(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check)
    {

            timecounter tc_level_set;
            tc_level_set.tic();


            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);



            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );




            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );

            //Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


            //std::cout<<"----> In 'Level_set_berstein_high_order_interpolation': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }





                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {

                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop




            set_max_min();

            tc_level_set.toc();
            std::cout << "Initialisation level set : t = " << tc_level_set << " seconds" << std::endl;



    }




    Level_set_berstein_high_order_interpolation_grad_cont_fast()=default;


    void
    coefficients_mapping( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_mapping_MAX_MAX( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        //std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void
    coefficients_sfasamento( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER DISPLACEMENT: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {


        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        //std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE QUADRATIC MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 0 ;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }



    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: sol_FEM has to be already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }
        std::cout<<" --> converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" (SI PUO TOGLIERE)."<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient_disc(pt,msh,cl);
        return ret/ret.norm();

    }

    T divergence_disc( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient_disc( pt , msh , cl )).norm() ;
        auto grad_eval = cb.eval_gradients(pt) ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )
                                                             ) ;
        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }

    template< typename Transport_Method >
    void normal_continuous_setting(const Transport_Method& method )
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        timecounter tc ;
        tc.tic();

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //tc.toc();
        //std::cout<<"----> TIME: In normal_continuous_setting INVERSIONE MATRIX, time = "<<tc<<std::endl;
        //std::cout<<"sono qua 0"<<std::endl;

        //tc.tic();
        for(auto& cl : msh.cells)
        {
            //timecounter tc2 ;
            //tc2.tic();
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 1, time = "<<tc2<<std::endl;
            //tc2.tic();
            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += (qp.second * disc_normal(0) * phi.transpose() );
                ret1_loc += (qp.second * disc_normal(1) * phi.transpose() );
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //tc2.toc();
            //std::cout<<"----> TIME: QPS, time = "<<tc2<<std::endl;
            //std::cout<<"sono qua 1"<<std::endl;
            //tc2.tic();
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;
            //tc2.toc();
            //std::cout<<"----> TIME: pezzo 3, time = "<<tc2<<std::endl;

        }
        //tc.toc();
        //std::cout<<"----> TIME: FEM CREATION, time = "<<tc<<std::endl;
        //tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        //tc.toc();
        //std::cout<<"----> TIME: FEM RESOLUTION, time = "<<tc<<std::endl;
        //tc.tic();
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }
        tc.toc();

        std::cout<<"----> TIME: normal continuous setting, time = "<<tc<<std::endl;
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    template<typename Transport_Method >
    void gradient_continuous_setting( const Transport_Method& method)
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);
        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient_disc( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }



    Eigen::Matrix<T,2,1> normal( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"values_cell"<<'\n'<<ret<<std::endl;
        //std::cout<<"values_cell.norm()"<<'\n'<<ret.norm()<<std::endl;
        //std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }


    T divergence( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) +
                                                             ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }


    



    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }
            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                sol_FEM(asm_map) = sol_loc(i) ;
            }

            if(!analytic_check)
            {
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }


    void upload_level_set(const std::string &filename_FEM)
    {
        size_t counter_FEM = 0 ;

        std::ifstream file_FEM;
        file_FEM.open(filename_FEM, std::ios::in | std::ios::out);
        if(!file_FEM.is_open()) {
            exit(10);
        }

        while(!file_FEM.eof())
        {
            if( counter_FEM < sol_FEM.size() )
            {
                T val;
                file_FEM >> val ;
                sol_FEM(counter_FEM) = val;

                counter_FEM++;
                //std::cout<<val <<" , " ;
            }
            else
                break;

        }
        std::cout<<std::endl ;
        file_FEM.close();

        // Uploading also sol_HHO
        for(size_t counter_HHO = 0 ; counter_HHO < n_cls ; counter_HHO++)
        {
            for (size_t i = 0; i < local_dim; i++)
            {
                size_t asm_map =  connectivity_matrix[counter_HHO][i].first ;
                sol_HHO(i,counter_HHO) = sol_FEM( asm_map ) ;
            }
        }



    }




};




template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct L2projected_level_set_high_order_parallelize: public level_set<T>
{

    bool analytic_check = FALSE ;

    T phi_max , phi_min ;
    size_t  last_row_init, last_row_end, number_faces_one_row;

    T iso_val_interface = 0.0 ;
    Mesh msh; // Original mesh, NOT agglomerated.
    mesh_init_params<T> params; // mesh parameter

    size_t degree_FEM ; // FEM degree
    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices
    size_t      Nx, Ny ; // Number of cells in x and y direciton

    // connectivity matrix : for each cell, it stores the global numbering
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
    std::vector<std::set<size_t>> S_i;
    //std::vector<std::vector<size_t>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes

    int mapped = 0 ; // = 0 not mapped ; = 1 mapped ; = 2 inverse mapping

    SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem

    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    // Local Vandermonde Matrix for interpolation
    Matrix<T, Dynamic, Dynamic> local_vandermonde ;


    // Assembling into global matrix
    SparseMatrix<T>                 Global_c_term_x; // Global mass, saved for FEM problem
    SparseMatrix<T>                 Global_c_term_y; // Global mass, saved for FEM problem

    Matrix<T, Dynamic, 1>      Global_Mass_Lumped; // Global mass, saved for FEM problem
    //SparseMatrix<T>                 Global_Mass_Lumped_sparse;

    SparseMatrix<T>         cij_norm , nij0 , nij1 ;
    SparseMatrix<T>         cji_norm , nji0 , nji1 ;


    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> normal_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> normal_c_FEM_1 ;

    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_0 ;
    Eigen::Matrix<T, Dynamic, Dynamic> gradient_c_HHO_1 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_0 ;
    Eigen::Matrix<T, Dynamic, 1> gradient_c_FEM_1 ;

    L2projected_level_set_high_order_parallelize(const FiniteSpace& fe_data , const Fonction & level_set, const Mesh & msh , bool analytic_check = FALSE )
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE) , analytic_check(analytic_check)
    {
        if(!analytic_check)
        {
            timecounter tc_level_set;
            tc_level_set.tic();
            Matrix<T, Dynamic, 1>           RHS;    // Known term



            last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
            last_row_end = last_row_init + Nx-1;
            number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);

            Global_Mass = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE ); // Known term (f,b_i)_i , b_i Lagrange basis fx

            Global_c_term_x = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            Global_c_term_y = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx

            Global_Mass_Lumped = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            //Global_Mass_Lumped_sparse = SparseMatrix<T>( ndof_FE, ndof_FE ); //(b_i,b_j)_ij , b_i Lagrange basis fx
            //Global_Mass_Lumped_sparse.reserve(ndof_FE);

            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );

            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );



            cij_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
            cji_norm = SparseMatrix<T>( ndof_FE, ndof_FE );
            nij0 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nij1 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nji0 = SparseMatrix<T>( ndof_FE, ndof_FE );
            nji1 = SparseMatrix<T>( ndof_FE, ndof_FE );
            /*
            std::vector< Triplet<T> >       triplets_norm;
            std::vector< Triplet<T> >       triplets_norm_adj;
            std::vector< Triplet<T> >       triplets_nij0;
            std::vector< Triplet<T> >       triplets_nij1;
            std::vector< Triplet<T> >       triplets_nji0;
            std::vector< Triplet<T> >       triplets_nji1;
            */

            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
            vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );

            //Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO_vandermonde =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ;


            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;
            //FullPivLU<Matrix<T, Dynamic, Dynamic > > cod_2;


            std::cout<<"----> In 'L2projected_level_set_high_order_parallelize': Vandermonde interpolation of the level set with BERNSTEIN basis."<<std::endl;

            //std::cout<<"CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;
            timecounter tc_prova ;
            /*
#ifdef HAVE_INTEL_TBB
            //tc_prova.tic();
            //tbb::task_scheduler_init init(1);
            tbb::task_scheduler_init init(tbb::task_scheduler_init::default_num_threads());
            auto first_cl = msh.cells[0] ;
            auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, first_cl , degree_FEM);
            cell_basis_Bernstein<Mesh,T> cb(msh, first_cl , degree_FEM);
            for (size_t ind = 0; ind < local_dim; ind++)
            {
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //               [ & ] (size_t & ind){
                local_vandermonde.block(ind,0,1,local_dim) = (cb.eval_basis(pts[ind])).transpose() ;


            }
              //  );

            cod.compute(local_vandermonde);
            //tc_prova.toc();
            //std::cout << bold << yellow << "--> local_vandermonde: t = " << tc_prova << " seconds" << reset << std::endl;

            tc_prova.tic();

            std::vector< Triplet<T> >       triplets_loc; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_x_loc; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_y_loc; // Position elements: Sparse Matrix Notation
            //std::vector< Triplet<T> >       triplets_lumped_loc; // Position elements: Sparse Matrix Notation
            Matrix<T, Dynamic, 1> RHS_vandermonde_loc = Matrix<T, Dynamic, 1>::Zero(local_dim);

            size_t n_cells = msh.cells.size();
            //std::cout<<" I m in parallel zone"<<std::endl;
            timecounter tc_prova2;
            //for( const auto& cl : msh.cells )
            //{
            tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
                //tc_prova2.tic();
                //size_t cell_ind = offset(msh, cl) ;
                //std::cout<<"----> Pos 0"<<std::endl;
                auto &cl = msh.cells[cell_ind];
                //std::cout<<"---> CELL = "<<cell_ind<<std::endl;
                //std::cout<<"----> Pos 1"<<std::endl;
                //size_t cell_offset = offset(msh, cl) ;
                //std::cout<<"----> Pos 2"<<std::endl;
                auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );
                //std::cout<<"----> Pos 3"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> local_mass : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                auto local_cij = make_bernstein_local_cij_matrix(msh, cl, degree_FEM);
                //std::cout<<"----> Pos 4"<<std::endl;
                //tc_prova2.toc();

                //std::cout << "----> TIME --> local_cij : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;
                //std::cout<<"----> Pos 5"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> local_lumped_mass : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
                //std::cout<<"-----> Pos 7"<<std::endl;
                //tc_prova2.toc();
                //std::cout << "----> TIME --> qps points : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                for (size_t i = 0; i < local_dim; i++)
                {

                    //std::cout<<"----> Pos 6"<<std::endl;
                    size_t asm_map_i = connectivity_matrix[cell_ind][i].first ;
                    for (size_t j = 0; j < local_dim; j++)
                    {
                        size_t asm_map_j = connectivity_matrix[cell_ind][j].first ;
                        //std::cout<<"i = "<<i <<" , j = "<< j <<std::endl;
                        //std::cout<<"asm_map_i = "<<asm_map_i <<" , asm_map_j = "<< asm_map_j <<std::endl;
                        //std::cout<<"-----> Pos 8.0"<<std::endl;
                        //Global_Mass.coeffRef( asm_map_i, asm_map_j ) += local_mass(i,j) ;
                        //std::cout<<"-----> Pos 8.1"<<std::endl;
                        //Global_c_term_x.coeffRef( asm_map_i, asm_map_j ) += local_cij.first(i,j);
                        //std::cout<<"-----> Pos 8.2"<<std::endl;
                        //Global_c_term_y.coeffRef( asm_map_i, asm_map_j ) += local_cij.second(i,j)  ;
                        //std::cout<<"-----> Pos 8.3"<<std::endl;

                      triplets_loc.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                      triplets_c_term_x_loc.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                      triplets_c_term_y_loc.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );

                    }

                    //std::cout<<"---------> Pos 8.4"<<std::endl;
                    //triplets_lumped_loc.push_back( Triplet<T>( asm_map_i , asm_map_i , local_mass_lumped(i) ) );

                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
                    RHS_vandermonde_loc(i) = level_set( qps[i]) ;
                    //std::cout<<"----> Pos 8"<<std::endl;
                }
                //tc_prova2.toc();
                //std::cout << "----> TIME --> Double loop : t = " << tc_prova2 << " seconds" << std::endl;
                //tc_prova2.tic();
                //std::cout<<"-----> Pos 9"<<std::endl;
                auto sol_tmp = cod.solve(RHS_vandermonde_loc) ;

                sol_HHO.col(cell_ind) = sol_tmp ;
                for (size_t ind2 = 0; ind2 < local_dim; ind2++)
                {
                    size_t asm_map =  connectivity_matrix[cell_ind][ind2].first ;
                    sol_FEM( asm_map ) = sol_HHO(ind2,cell_ind) ;

                }


                size_t i_vertex = cell_ind+floor(cell_ind/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_ind) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_ind) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_ind) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_ind) ;

                //tc_prova2.toc();
                //std::cout << "----> TIME --> RESOLUTION : t = " << tc_prova2 << " seconds" << std::endl;
            }
            );
            //std::cout<<"----------------------> Pos 10"<<std::endl;
            // Finalisation global assembling
            Global_Mass.setFromTriplets( triplets_loc.begin(), triplets_loc.end() );
            triplets_loc.clear();


            // Finalisation global assembling
            Global_c_term_x.setFromTriplets( triplets_c_term_x_loc.begin(), triplets_c_term_x_loc.end() );
            triplets_c_term_x_loc.clear();
            Global_c_term_y.setFromTriplets( triplets_c_term_y_loc.begin(), triplets_c_term_y_loc.end() );
            triplets_c_term_y_loc.clear();
            //Global_Mass_Lumped_sparse.setFromTriplets( triplets_lumped_loc.begin(), triplets_lumped_loc.end() );
            //triplets_lumped_loc.clear();

            tc_prova.toc();
            std::cout << bold << yellow << "--> COSTRUCTION PROJECTION : t = " << tc_prova << " seconds" << reset << std::endl;

#else
     */
            std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_x; // Position elements: Sparse Matrix Notation
            std::vector< Triplet<T> >       triplets_c_term_y; // Position elements: Sparse Matrix Notation

            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                    //cod_2.compute(local_vandermonde);
                }


                auto local_mass = make_bernstein_local_mass_matrix( msh, cl , degree_FEM );

                //auto local_RHS = make_bernstein_local_RHS( msh , cl , degree_FEM , level_set );
                // Local c_ij = b_i nabla(b_j) -> USEFUL FOR TRANSPORT PROBLEM
                auto local_cij = make_bernstein_local_cij_matrix (msh, cl, degree_FEM);

                auto local_mass_lumped = make_bernstein_local_mass_matrix_lumped( msh , cl , degree_FEM ) ;


                // Costruction of the coefficients of the Bernstein basis
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                // Assembling triplets for global problem
                for (size_t i = 0; i < local_dim; i++)
                {
                    size_t asm_map_i = connectivity_matrix[cell_offset][i].first ;
                    for (size_t j = 0; j < local_dim; j++)
                    {

                        size_t asm_map_j = connectivity_matrix[cell_offset][j].first ;

                        triplets.push_back(Triplet<T>(asm_map_i,asm_map_j, local_mass(i,j)));
                        triplets_c_term_x.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij.first(i,j) ) );
                        triplets_c_term_y.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij.second(i,j) ) );

                        /*
                        T val_norm = sqrt( c_ij0*c_ij0 + c_ij1*c_ij1 );
                        T val_norm_adj = sqrt( c_ji0 *c_ji0 + c_ji1*c_ji1 );
                        T val_nij0 = c_ij0/val_norm ;
                        T val_nij1 = c_ij1/val_norm ;
                        T val_nji0 = c_ji0/val_norm_adj ;
                        T val_nji1 = c_ji1/val_norm_adj ;

                        triplets_norm.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm));
                        triplets_norm_adj.push_back(Triplet<T>(asm_map_i,asm_map_j, val_norm_adj));
                        triplets_nij0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij0));
                        triplets_nij1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nij1));
                        triplets_nji0.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji0));
                        triplets_nji1.push_back(Triplet<T>(asm_map_i,asm_map_j, val_nji1));
                        */
                    }
                    Global_Mass_Lumped(asm_map_i) += local_mass_lumped(i);
                    //Global_Mass_Lumped(asm_map[i].first) += local_mass_lumped(i);
                    //RHS(asm_map[i].first) += local_RHS(i) ;
                    RHS_vandermonde(i) = level_set( qps[i]) ;
                }


                auto sol_tmp = cod.solve(RHS_vandermonde) ;

                //auto sol_tmp_2 = cod_2.solve(RHS_vandermonde) ;

                sol_HHO.col(cell_offset) = sol_tmp ;
                for (size_t i = 0; i < local_dim; i++)
                {

                    size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                    sol_FEM( asm_map ) = sol_HHO(i,cell_offset) ;

                    //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                    //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;


            } // end of cl loop

            // Finalisation global assembling
            Global_Mass.setFromTriplets( triplets.begin(), triplets.end() );
            triplets.clear();


            // Finalisation global assembling
            Global_c_term_x.setFromTriplets( triplets_c_term_x.begin(), triplets_c_term_x.end() );
            triplets_c_term_x.clear();
            Global_c_term_y.setFromTriplets( triplets_c_term_y.begin(), triplets_c_term_y.end() );
            triplets_c_term_y.clear();



//#endif

            //std::cout<<"FINE CHECK INVERSION LOCAL VANDERMONDE"<<std::endl;

            /*
            cij_norm.setFromTriplets( triplets_norm.begin(), triplets_norm.end() );
            triplets_norm.clear();
            cji_norm.setFromTriplets( triplets_norm_adj.begin(), triplets_norm_adj.end() );
            triplets_norm_adj.clear();

            nij0.setFromTriplets( triplets_nij0.begin(), triplets_nij0.end() );
            triplets_nij0.clear();
            nij1.setFromTriplets( triplets_nij1.begin(), triplets_nij1.end() );
            triplets_nij1.clear();

            nji0.setFromTriplets( triplets_nji0.begin(), triplets_nji0.end() );
            triplets_nji0.clear();
            nji1.setFromTriplets( triplets_nji1.begin(), triplets_nji1.end() );
            triplets_nji1.clear();
            */

            // NORM of c_ij

            cij_norm = ( Global_c_term_x.cwiseProduct(Global_c_term_x) + Global_c_term_y.cwiseProduct(Global_c_term_y) ).cwiseSqrt() ;
            //std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

            // MATRIX n_ij
            nij0 = Global_c_term_x.cwiseQuotient( cij_norm );
            nij1 = Global_c_term_y.cwiseQuotient( cij_norm );

            //std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


            // MATRIX c_ji
            SparseMatrix<T> cji_x = Global_c_term_x.adjoint() ;
            SparseMatrix<T> cji_y = Global_c_term_y.adjoint() ;

            // NORM of c_ji -> i.e. c_ij transposed
            cji_norm = (cji_x.cwiseProduct(cji_x)+cji_y.cwiseProduct(cji_y)).cwiseSqrt();

            // MATRIX n_ij (TRANSPOSED)
            nji0 = cji_x.cwiseQuotient( cji_norm );
            nji1 = cji_y.cwiseQuotient( cji_norm );




            //std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;


              // CALCULATION OF THE SIZE + PLOTTING
              /*
              size_t size_supp_nodes = 0;
              std::cout<<"Supporting nodes IN L2:"<<std::endl;
              size_t jjjj = 0;
              for (auto& i: S_i) {
                  size_supp_nodes+=i.size();
                  std::cout <<"Node "<<jjjj<<":";
                  for (auto it=i.begin(); it != i.end(); ++it)
                      std::cout << ' ' << *it;
                      // std::cout<<ii;
                  std::cout<<'\n';
                  jjjj++;
              }
              std::cout<<std::endl;
              std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
              */




              //Matrix<T, Dynamic, 1> sol_FEM_vandermonde  = Matrix<T, Dynamic, 1>::Zero(RHS.rows()); ;

            std::cout<<"sol_FEM size "<<sol_FEM.size()<<std::endl;
            std::cout<<"local_dim size "<<local_dim<<std::endl;
            std::cout<<"n_cls "<<n_cls<<std::endl;

              // Global solution saved as discontinuous HHO approach
              // Also saved min & max coefficients + position in HHO notation

              /*
              ConjugateGradient<SparseMatrix<T> > solver_global_mass;
              //SparseLU<SparseMatrix<T>, COLAMDOrdering<int> >solver_global_mass;
              //Notice: for this step the numerical values of A are not used
              //solver_global_mass.analyzePattern(Global_Mass);
              //solver_global_mass.factorize(Global_Mass);

              solver_global_mass.compute(Global_Mass); // SAVE INVERSE OF GLOBAL MASS
              if(solver_global_mass.info()!=Success) {
                  std::cout<<"FAILED SOLVER 0"<<std::endl;
                  return;
              }

              sol_FEM = solver_global_mass.solve(RHS);
              */

              /*
              for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
              {
                  for (size_t i = 0; i < local_dim; i++)
                  {
                      size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                      //sol_HHO(i,counter_bis) = sol_FEM( asm_map ) ;
                      sol_FEM( asm_map ) = sol_HHO(i,counter_bis) ;
                  }
              }
              */


              //std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;


              //sol_FEM = sol_FEM_vandermonde ;
              //sol_HHO = sol_HHO_vandermonde ;
              //std::cout<<"CHECK L2 proj vs Vandermonde interpolation for phi^0"<<'\n'<<sol_FEM-sol_FEM_vandermonde<<std::endl;
              // Set of maximum and minimum
            timecounter tcbis ;
            tcbis.tic();
            set_max_min();
            tcbis.toc();
            std::cout << bold << yellow << "--> set_max_min: t = " << tcbis << " seconds" << reset << std::endl;


              /*
              for( size_t i_global = 0; i_global < n_cls; i_global++)
              {
                  size_t i_vertex = i_global+floor(i_global/Nx);
                  vertices(i_vertex) = sol_HHO(0,i_global) ;
                  vertices(i_vertex+1) = sol_HHO(1,i_global) ;
                  vertices(i_vertex+Nx+2) = sol_HHO(2,i_global) ;
                  vertices(i_vertex+Nx+1) = sol_HHO(3,i_global) ;
              }
              */

            tc_level_set.toc();
            std::cout << bold << yellow << "INITIALISATION LEVEL SET: t = " << tc_level_set << " seconds" << reset << std::endl;

        }
        else
        {
            timecounter tc_level_set;
            tc_level_set.tic();

            Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero(local_dim);
            local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_dim,local_dim );


            // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
            sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
            normal_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            normal_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            gradient_c_HHO_0 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_HHO_1 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls);
            gradient_c_FEM_0 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
            gradient_c_FEM_1 = Eigen::Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );

            CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod;

            std::cout<<"----> FOR ANALYTIC CHECK 'L2projected_level_set_high_order_parallelize': Vandermonde interpolation of the level set with BERNSTEIN basis. JUST HHO FORMULATION IMPLEMENTED"<<std::endl;


           /*

            // I TOOK AWAY BECAUSE I DO NOT HAVE TBB
#ifdef HAVE_INTEL_TBB
            auto first_cl = msh.cells[0] ;
            auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, first_cl , degree_FEM);
            cell_basis_Bernstein<Mesh,T> cb(msh, first_cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                                      [&] (size_t & i){
                           local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;


                           }
                           );

            cod.compute(local_vandermonde);


            size_t n_cells = msh.cells.size();
            std::cout<<" I m in parallel zone"<<std::endl;
            tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
                auto& cl = msh.cells[cell_ind];
                size_t cell_offset = offset(msh, cl) ;
                // Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);


                tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                        [&] (size_t & i){
                        RHS_vandermonde(i) = level_set( qps[i]) ;
                    }
                    );

                auto sol_tmp = cod.solve(RHS_vandermonde) ;
                sol_HHO.col(cell_offset) = sol_tmp ;


            }
            );

#else
            */
            for( const auto& cl : msh.cells )
            {
                size_t cell_offset = offset(msh, cl) ;

                if(cell_offset == 0)
                {
                    auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree_FEM);
                    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                    for (size_t i = 0; i < local_dim; i++)
                    {
                        // Local vandermonde matrix
                        local_vandermonde.block(i,0,1,local_dim) = (cb.eval_basis(pts[i])).transpose() ;
                    }

                    cod.compute(local_vandermonde);
                }



                // Assembling triplets for global problem
                auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
                for (size_t i = 0; i < local_dim; i++)
                    RHS_vandermonde(i) = level_set( qps[i]) ;


                auto sol_tmp = cod.solve(RHS_vandermonde) ;
                sol_HHO.col(cell_offset) = sol_tmp ;



            } // end of cl loop

//#endif
            tc_level_set.toc();
            std::cout << bold << yellow << "INITIALISATION LEVEL SET: t = " << tc_level_set << " seconds" << reset << std::endl;

        }


    }




    L2projected_level_set_high_order_parallelize()=default;


    void
    coefficients_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

/*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                RHS_vandermonde(i) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );

                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );
#else
*/

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl ) - phi_min )/( phi_max - phi_min );
                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop


        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

//#endif

         std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;


    }


    void
    coefficients_inverse_mapping( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        /*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                RHS_vandermonde(i) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

        }
        );

#else */
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }


//#endif
        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }






    void
    coefficients_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
      /*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(i) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(i) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;
        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );


#else */

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )+ phi_max) /( 2.0*phi_max );
                else
                    RHS_vandermonde(ct) =  ( (*this)(pt , msh , cl )-phi_min ) /( -2.0*phi_min );

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;

        std::cout<<"IN COEFFICIENT_MAPPING MAX MAX, CHECKING phi = 0, after mappin becomes --> "<< ( 0.0 +phi_max )/( 2.0*phi_max )<<std::endl;
        std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 + phi_max )/( 2.0*phi_max  ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }


//#endif

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;


    }

    void
    coefficients_inverse_mapping_MAX_MAX( )
    {

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        /*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                auto pt =  nodes[i] ;
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(i) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(i) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );


                }
                );



            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                    auto asm_map = connectivity_matrix[cell_offset][i].first ;
                    mapped_phi(asm_map) = sol_vandermonde(i) ;


                }
                );



        }
        );
        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;

        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            [&] (size_t & i){
                auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_offset,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);

            }
            );

            }
            );



#else */
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                if( std::abs(phi_max) >= std::abs(phi_min))
                    RHS_vandermonde(ct) = -phi_max + (*this)(pt , msh , cl )* ( 2.0 * phi_max );
                else
                    RHS_vandermonde(ct) = phi_min - (*this)(pt , msh , cl )* ( 2.0 * phi_min );

                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }


//#endif
        std::cout<<"LEVEL_SET: CHECK VALUES AFTER INVERSE_MAPPING_MAX_MAX: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }


    void
    coefficients_sfasamento( )
    {

        std::cout<<"---> coefficients_sfasamento is not parallelize for the moment."<<std::endl;
        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );


        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) =   (*this)(pt , msh , cl ) + 0.5 ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);
            //std::cout<<"--------------->>>>>>>> RHS_vandermonde"<<'\n'<<RHS_vandermonde<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }





    void
    coefficients_mapping_quadratic( )
    {
        std::cout<<"---> coefficients_mapping_quadratic is not parallelize for the moment."<<std::endl;

        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        T a1 = (-1.0/2.0 - phi_min/(phi_max-phi_min))/(pow(phi_min,2));
        T b = 1.0/(phi_max-phi_min);
        T c = 1.0/2.0;
        T a2 = (1.0/2.0 - phi_max/(phi_max-phi_min))/(pow(phi_max,2));

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                auto val = (*this)(pt , msh , cl ) ;
                if( val <= 0 )
                    RHS_vandermonde(ct) =   a1 * val * val + b * val + c ;
                else
                    RHS_vandermonde(ct) =   a2 * val * val + b * val + c ;

                ct++;
            }

            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map = connectivity_matrix[cell_offset][i].first ;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }

        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );
        iso_val_interface = 1.0/2.0 ;
        std::cout<<"Isovalue of the interface = "<<iso_val_interface<<std::endl;
        //std::cout<<"IN COEFFICIENT_MAPPING, CHECKING phi = 0, after mappin becomes --> "<< (0.0 - phi_min )/( phi_max - phi_min )<<std::endl;

        //std::cout<<"It should be close to 1/2, error = "<< 1./2. - ( 0.0 - phi_min )/( phi_max - phi_min ) <<std::endl;

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }

    void
    coefficients_inverse_mapping_quadratic( )
    {
        std::cout<<"---> coefficients_mapping_quadratic is not parallelize for the moment."<<std::endl;
        Matrix<T, Dynamic, 1> mapped_phi = Matrix<T, Dynamic, 1>::Zero( ndof_FE );

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );
        Matrix<T, Dynamic, 1> RHS_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );
        Matrix<T, Dynamic, 1> sol_vandermonde = Matrix<T, Dynamic, 1>::Zero( local_dim );

        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh , cl , degree_FEM);
            size_t ct = 0;
            for (auto& pt : nodes )
            {
                RHS_vandermonde(ct) = phi_min + (*this)(pt , msh , cl )*( phi_max - phi_min );
                ct++;
            }
            sol_vandermonde = vandermonde_interpolant.solve(RHS_vandermonde);

            for (size_t i = 0; i < local_dim; i++)
            {
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                mapped_phi(asm_map) = sol_vandermonde(i) ;
            }


        } // end of cl loop

        sol_FEM = mapped_phi ;
        converting_into_HHO_formulation( sol_FEM );

        // CHECK MAX AND MIN AFTER OPERATIONS
        T ret0 = -10.0;
        T ret1 = 10.0;
        size_t counter_ret0 = 0;

        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        std::cout<<"LEVEL_SET: CHECK VALUES AFTER MAPPING: MAX = "<<ret0<< " , MIN = "<<ret1<<std::endl;

    }









    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" --> set_discrete_points: check that sol_FEM already uploaded!"<<std::endl;

    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        // SAVE BOTH SOL_HHO AND VERTICES
       /*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                            [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                sol_HHO(i,cell_ind) = values_new( asm_map );
            }
            );
            size_t i_vertex = cell_ind+floor(cell_ind/Nx);
            vertices(i_vertex) = sol_HHO(0,cell_ind) ;
            vertices(i_vertex+1) = sol_HHO(1,cell_ind) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,cell_ind) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,cell_ind) ;

        }
        );

#else */
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );

            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;

        }
//#endif

        std::cout<<" --> converting_into_HHO_formulation. TO BE CHECKED that sol_FEM already uploaded!"<<std::endl;

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {
          /*
#ifdef HAVE_INTEL_TBB


        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                            [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                sol_FEM( asm_map ) = values_new(i,cell_ind) ;
            }
            );
            size_t i_vertex = cell_ind+floor(cell_ind/Nx);
            vertices(i_vertex) = values_new(0,cell_ind) ;
            vertices(i_vertex+1) = values_new(1,cell_ind) ;
            vertices(i_vertex+Nx+2) = values_new(2,cell_ind) ;
            vertices(i_vertex+Nx+1) = values_new(3,cell_ind) ;
        }
        );

#else */
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = values_new(0,counter_bis) ;
            vertices(i_vertex+1) = values_new(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = values_new(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = values_new(3,counter_bis) ;

        }

//#endif
        std::cout<<" --> converting_into_FE_formulation. TO BE CHECKED that sol_HHO already uploaded!"<<std::endl;

    }




    void set_max_min()
    {

        T ret0 = -10.0;
        T ret1 = 10.0;
      /*
#ifdef HAVE_INTEL_TBB
        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];

            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);
            for(auto& nd : nodes ){
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //    [&] (size_t & i){
            //    auto nd =  nodes[i] ;
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,cell_ind,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
           // );
        }
        );
        phi_max = ret0;
        phi_min = ret1;

#else */
        size_t counter_ret0 = 0;
        for(auto& cl:msh.cells)
        {
            cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
            auto nodes = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl , degree_FEM);

            for(auto& nd : nodes ){
                auto phi_tmp = cb.eval_basis(nd);
                auto values_cell = (sol_HHO.block(0,counter_ret0,local_dim,1)).col(0);
                auto new_ret = values_cell.dot(phi_tmp) ;
                ret0 = std::max( new_ret , ret0 ) ;
                ret1 = std::min( new_ret , ret1);
            }
            counter_ret0++;
        }

        phi_max = ret0;
        phi_min = ret1;
//#endif
        std::cout<<" --> set_max_min: LEVEL_SET: MAX IS "<<phi_max<< " , MIN IS "<<phi_min<<" . SI PUO TOGLIERE."<<std::endl;
    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    // It should work also for Bernstein Basis
    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES -> BUT SLOW
    T operator()(const point<T,2>& pt) const
    {
        /*
#ifdef HAVE_INTEL_TBB
        size_t n_cells = msh.cells.size();
        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree_FEM);
                auto values_cell = (sol_HHO.block(0,cell_ind,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );
            }
        }
        );

        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator() PARALLEL!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop

#else
        */
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

                return values_cell.dot( cb.eval_basis(pt) );

            }
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop

//#endif

    }


    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );

        return tmp;

    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES --> FAST
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
    {
        auto counter_face = offset(msh,fc);
        size_t counter_cell;
        // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

        // Check if I am in the last row, upper faces (ordered differently)
        if(counter_face>=last_row_init && counter_face<=last_row_end)
        {
            counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
        }
        else
        {
            // Find in what row the face is
            auto  num_cell_row = floor(counter_face/(number_faces_one_row));
            if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
            {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                counter_cell = floor( (counter_face-num_cell_row)/2.0 );
            }
            else
            {
                // Face on the right boudary,
                counter_cell = ( num_cell_row+1 )*Nx -1;
            }

        }
        //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
        auto cl = msh.cells.at(counter_cell);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter_cell,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;


    }


    // IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }


    // IT WORKS FOR ALL THE MESHES --> SLOW
    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

         Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
       /*
#ifdef HAVE_INTEL_TBB

        size_t n_cells = msh.cells.size();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
           if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(cell_ind);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
        }
        );
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;

        return ret; //to check if doesn't enter in the loop


#else
        */
        size_t counter=0;
        //std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        for( const auto& cl:msh.cells)
        {
            if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
                //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = sol_HHO.col(counter);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
            counter+=1;

        }
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;
        return ret; //to check if doesn't enter in the loop
//#endif

    }


        // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = sol_HHO.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient(pt,msh,cl);
        return ret/ret.norm();

    }
    /*
    T divergence_disc_old( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }
    */

    T divergence( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);

        T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        auto grad_eval = cb.eval_gradients(pt) ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell.dot(grad_eval.col(0)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_x(pt)) ) + (pow( ( values_cell.dot(grad_eval.col(1)) ) , 2)) * ( values_cell.dot(cb.eval_double_derivative_y(pt)) ) + 2.0* ( values_cell.dot(grad_eval.col(0)) )  * ( values_cell.dot(grad_eval.col(1)) ) * ( values_cell.dot(cb.eval_derivative_xy(pt)) )
                                                             ) ;
        //std::cout<<"CHECK divergence AND double derivative: in pt = "<< pt <<" error = "<< ( cb.eval_double_derivative_x(pt) + cb.eval_double_derivative_y(pt) - cb.eval_divergence(pt) ) <<std::endl;
        //T divergence_correction = values_cell.dot(cb.eval_gradients(pt).col(0))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_x(pt)) + values_cell.dot(cb.eval_gradients(pt).col(1))/pow(grad_norm,3)*values_cell.dot(cb.eval_double_derivative_y(pt)) ;

        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell.dot(cb.eval_divergence(pt)) ) / (grad_norm) + divergence_correction );

    }


    void normal_continuous_setting()
    {


        timecounter tc ;
        tc.tic();
        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(Global_Mass);


        tc.toc();
        std::cout<<"----> TIME: In normal_continuous_setting PARALLEL INVERSIONE MATRIX, time = "<<tc<<std::endl;
        /*
#ifdef HAVE_INTEL_TBB
        tbb::task_scheduler_init init(1);
        size_t n_cells = msh.cells.size();

        tc.tic();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){

            //timecounter tc2 ;
            //tc2.tic();
            auto& cl = msh.cells[cell_ind];
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            //size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1));
            for (auto& qp : qps)
            {
            //size_t qps_size = qps.size();
            //tbb::parallel_for(size_t(0), size_t(qps_size), size_t(1),
            //    [&] (size_t & j){
            //    auto qp =  qps[j] ;
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_normal(0) * phi.transpose();
                ret1_loc += qp.second * disc_normal(1) * phi.transpose();

            }
           // );
            //tc2.toc();
            //std::cout<<"----> TIME: PARALLEL QPS = "<<tc2<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {
            //tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
            //    [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

            }
            //);
        }
        );
        tc.toc();

        std::cout<<"----> TIME: PARALLEL FEM CONSTRUCTION, time = "<<tc<<std::endl;
        tc.tic();
        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);
        tc.toc();

        std::cout<<"----> TIME: FEM SOLVER, time = "<<tc<<std::endl;

        tc.tic();
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
        [&] (size_t & cell_ind){
        //    tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
        //    [&] (size_t & i){
             for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                normal_c_HHO_0(i,cell_ind) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,cell_ind) = normal_c_FEM_1( asm_map ) ;
            }
         //   );

        }
        );

        tc.toc();

        std::cout<<"----> TIME: PARALLEL HHO, time = "<<tc<<std::endl;

#else */


        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_normal(0) * phi.transpose();
                ret1_loc += qp.second * disc_normal(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        normal_c_FEM_0 = solver_global_mass.solve(ret0);
        normal_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                normal_c_HHO_0(i,counter_bis) = normal_c_FEM_0( asm_map ) ;
                normal_c_HHO_1(i,counter_bis) = normal_c_FEM_1( asm_map ) ;
            }

        }

//#endif
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> normal_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }


    T divergence_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = normal_c_HHO_0.col(counter);
        auto values_cell1 = normal_c_HHO_1.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        //T grad_norm = (this->gradient( pt , msh , cl )).norm() ;
        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;
        //std::cout<<"CURVATURE( "<< pt <<" ) = "<< values_cell0.dot( grad_eval.col(0)) + values_cell1.dot( grad_eval.col(1))<<std::endl;
        return -(values_cell0.dot( grad_eval.col(0) ) + values_cell1.dot( grad_eval.col(1) ) );
        //  return -( values_cell.dot(cb.eval_divergence(pt)) ) / (2 * grad_norm) ;

    }

    void gradient_continuous_setting()
    {




        Matrix<T, Dynamic, 1> ret0 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;
        Matrix<T, Dynamic, 1> ret1 = Matrix<T, Dynamic, 1>::Zero(ndof_FE, 1) ;

        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(Global_Mass);




  /*
#ifdef HAVE_INTEL_TBB

        size_t n_cells = msh.cells.size();

        std::cout<<" I m in parallel zone"<<std::endl;
        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){

            auto& cl = msh.cells[cell_ind];
            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            //size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1));
            size_t qps_size = qps.size();
            tbb::parallel_for(size_t(0), size_t(qps_size), size_t(1),
            [&] (size_t & j){

                auto qp =  qps[j] ;
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
            }
            );


            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

            }
            );
        }
        );


        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
            [&] (size_t & cell_ind){
            tbb::parallel_for(size_t(0), size_t(local_dim), size_t(1),
                [&] (size_t & i){
                size_t asm_map =  connectivity_matrix[cell_ind][i].first ;
                gradient_c_HHO_0(i,cell_ind) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,cell_ind) = gradient_c_FEM_1( asm_map ) ;
            }
            );

        }
        );


#else  */

        //std::cout<<"sono qua 0"<<std::endl;
        for(auto& cl : msh.cells)
        {

            cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
            auto cbs = cb.size();
            size_t cell_offset = offset(msh,cl);
            Matrix<T, Dynamic, 1> ret0_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;
            Matrix<T, Dynamic, 1> ret1_loc = Matrix<T, Dynamic, 1>::Zero(cbs, 1) ;

            auto qps = integrate(msh, cl, 2*(degree_FEM+1)); // integration of order 2k

            for (auto& qp : qps)
            {
                auto phi = cb.eval_basis(qp.first);
                auto disc_gradient = (this->gradient( qp.first , msh , cl )) ;
                //auto disc_normal = (this->normal( qp.first , msh , cl )) ;
                ret0_loc += qp.second * disc_gradient(0) * phi.transpose();
                ret1_loc += qp.second * disc_gradient(1) * phi.transpose();
                // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
            }
            //std::cout<<"sono qua 1"<<std::endl;
            for (size_t i = 0; i < local_dim; i++)
            {

                size_t asm_map =  connectivity_matrix[cell_offset][i].first ;
                //std::cout<<"i = "<<i<<" , asm_map = "<<asm_map<<" , cell_offset = "<<cell_offset<<" , ret0.size() = "<<ret0.size()<<" , ret1.size() = "<<ret1.size()<<" , ret0_loc.size() = "<<ret0_loc.size()<<" , ret1_loc.size() = "<<ret1_loc.size()<<std::endl;
                ret0( asm_map ) += ret0_loc(i) ;
                ret1( asm_map ) += ret1_loc(i) ;

                //if( std::abs( sol_tmp(i) - sol_tmp_2(i) )>1e-14 )
                //    std::cout<< std::abs(sol_tmp(i) - sol_tmp_2(i) ) <<std::endl;

            }
            //std::cout<<"sono qua 2"<<std::endl;


        }

        gradient_c_FEM_0 = solver_global_mass.solve(ret0);
        gradient_c_FEM_1 = solver_global_mass.solve(ret1);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                gradient_c_HHO_0(i,counter_bis) = gradient_c_FEM_0( asm_map ) ;
                gradient_c_HHO_1(i,counter_bis) = gradient_c_FEM_1( asm_map ) ;
            }

        }

//#endif
        //std::cout<<"normal_c_HHO_0"<<'\n'<<normal_c_HHO_0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<normal_c_HHO_1<<std::endl;

    }

    Eigen::Matrix<T,2,1> grad_cont( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);
        //std::cout<<"normal_c_HHO_0"<<'\n'<<values_cell0<<std::endl;
        //std::cout<<"normal_c_HHO_1"<<'\n'<<values_cell1<<std::endl;
        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        //std::cout<<"CONTINUOS NORMAL =( "<<ret(0)<<" , "<<ret(1)<<" )  in pt = "<<pt<<std::endl;
        //values_cell.dot( grad_eval.col(1) );
        // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

    }



    Eigen::Matrix<T,2,1> normal_cont_normalised( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        // Continuous normal noramlised -> obtained via the L2 projection of the discontinuos gradient over the basis B_k.
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);



        auto basis_eval =  cb.eval_basis(pt);
        ret(0) = values_cell0.dot( basis_eval );
        ret(1) = values_cell1.dot( basis_eval );
        std::cout<<"gradient_c_HHO"<<'\n'<<ret/ret.norm()<<std::endl;

        return ret/ret.norm();

    }


    T divergence_cont_grad( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell0 = gradient_c_HHO_0.col(counter);
        auto values_cell1 = gradient_c_HHO_1.col(counter);

        auto grad_eval = cb.eval_gradients(pt) ;
        auto b_eval = cb.eval_basis(pt) ;
        T grad_norm = (this->grad_cont( pt , msh , cl )).norm() ;

        //std::cout<<"grad norm is "<<grad_norm<<std::endl;
        //std::cout<<"values_cell is "<<'\n'<<values_cell<<std::endl;
        //std::cout<<"cb.eval_divergence(pt) is "<<'\n'<<cb.eval_divergence(pt)<<std::endl;
        //std::cout<<"( values_cell.dot(cb.eval_divergence(pt)) ) is "<<( values_cell.dot(cb.eval_divergence(pt)) )<<std::endl;

        T divergence_correction = -1.0/( pow(grad_norm,3) )*( (pow( ( values_cell0.dot(b_eval) ) , 2)) * ( values_cell0.dot(grad_eval.col(0)) ) +  ( values_cell0.dot(b_eval) ) * ( values_cell1.dot(b_eval) ) * ( values_cell1.dot(grad_eval.col(0)) ) + ( values_cell1.dot(b_eval) ) * ( values_cell0.dot(b_eval) ) * ( values_cell0.dot(grad_eval.col(1)) ) +  (pow( ( values_cell1.dot(b_eval) ) , 2)) * ( values_cell1.dot(grad_eval.col(1)) ) );


        //std::cout<<"Res 0 = "<< values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction ;
        //std::cout<<"Res 1 = "<< - (values_cell.dot(cb.eval_divergence(pt)) / (grad_norm) + divergence_correction  );

        return -( (values_cell0.dot(grad_eval.col(0)) + values_cell1.dot(grad_eval.col(1)) ) / (grad_norm) + divergence_correction );

    }





    void smooth_cut_off( T C , T r0 , T delta , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        /*
        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;
        */





        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde

            if(!analytic_check)
            {
                for (size_t i = 0; i < local_dim; i++)
                {
                    auto asm_map =  connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i) ;
                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


        /*
        postprocess_output<double> postoutput00;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
        {
            alfa_values->add_data(pt,alfa(pt));
        }
        postoutput00.add_object(alfa_values);
        postoutput00.write();

        */
    }

    void smooth_cut_off( T C , T x_centre , T y_centre , T radius , T radius_a , T radius_b )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        //Matrix<T, Dynamic, 1> RHS = Matrix<T, Dynamic, 1>::Zero( ndof_FE , 1 );
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );



        T hx = params.hx();
        T hy = params.hy();
        T pos_r0 = 0.5; //std::min(x_centre , 1 - x_centre );
        T r_max = std::max( radius_a , radius_b ) ;
        T h = std::max( hx , hy ) ;
        T r0 = r_max + 2*h*sqrt(2.0);
        C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
         //T dist = pos_r0 - radius + 2.0*0.0625;
         //T dist = pos_r0 - radius + 2.0*0.07;
         //T r0 = radius + dist/2.0;

         T delta = r0/8.0; // FIRST CHOICE
        //T delta = r0/20.0;





        std::cout<<"r_max = "<<r_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;

        // Lambda function to define smooth function
        auto alfa = [=](const point<T,2>& pt)
        { // sol
            return (1 - tanh( (sqrt( pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2) ) - r0 ) / delta ))/2;};




        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;
                local_RHS(i) =  ( 1.0 - alfa(pt)  ) * C + alfa(pt) * (*this)(pt,msh,cl) ;
            }
            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde

            if(!analytic_check)
            {
                for (size_t i = 0; i < local_dim; i++)
                {
                    auto asm_map =  connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i) ;
                }
                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }

        } // end of cl loop



        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();

    }


    void cut_off( T d )
    {

        Matrix<T, Dynamic,1> local_RHS = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);
        Matrix<T, Dynamic,1> sol_loc = Matrix<T, Dynamic, 1>::Zero( local_dim , 1);

        CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > vandermonde_interpolant( local_vandermonde );


        // Known term (f,b_i)_i , b_i Bernstein basis fx
        for( const auto& cl : msh.cells )
        {
            size_t cell_offset = offset(msh, cl) ;

            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            for(size_t i = 0 ; i<local_dim ; i++)
            {
                auto pt = qps[i];
                auto asm_map =  connectivity_matrix[cell_offset][i].first;

                if( (*this)(pt,msh,cl)>= d )
                    local_RHS(i) =  d ;
                else if( (*this)(pt,msh,cl)<= -d )
                    local_RHS(i) =  -d ;
                else
                    local_RHS(i) =  (*this)(pt,msh,cl) ;

            }

            sol_loc = vandermonde_interpolant.solve(local_RHS); // SAVE Vandermonde interpolation
            sol_HHO.col(cell_offset) = sol_loc ; // SAVE Vandermonde
            if(!analytic_check)
            {
                for (size_t i = 0; i < local_dim; i++)
                {
                    auto asm_map =  connectivity_matrix[cell_offset][i].first;
                    sol_FEM(asm_map) = sol_loc(i) ;
                }

                size_t i_vertex = cell_offset+floor(cell_offset/Nx);
                vertices(i_vertex) = sol_HHO(0,cell_offset) ;
                vertices(i_vertex+1) = sol_HHO(1,cell_offset) ;
                vertices(i_vertex+Nx+2) = sol_HHO(2,cell_offset) ;
                vertices(i_vertex+Nx+1) = sol_HHO(3,cell_offset) ;
            }
        } // end of cl loop




        //converting_into_HHO_formulation(sol_FEM);
        if(!analytic_check)
            set_max_min();


    }



};



template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_Bernstein_high_order: public Level_set_berstein_high_order_interpolation< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;
    //LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
   // : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
    // I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_Bernstein_high_order(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_Bernstein_high_order()=default;


    LS_cell_Bernstein_high_order(const LS_cell_Bernstein_high_order& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }


    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            /// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , subcl );
        }
    }


    Eigen::Matrix<T,2,1> normal_cont(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> normal_cont_normalised(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont_normalised( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont_normalised( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
           //std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient( pt , level_set.msh , subcl );
        }

    }

    /*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence( pt , level_set.msh , subcl );
        }
    }

    T divergence_cont( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    T divergence_cont_grad( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont_grad( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont_grad( pt , level_set.msh , subcl );
        }
    }


    /*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
    // STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()( pt );
    }


};


template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_cont: public Level_set_berstein_high_order_interpolation_grad_cont< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;
    //LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
   // : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
    // I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_grad_cont(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_cont()=default;

    LS_cell_high_order_grad_cont(const LS_cell_high_order_grad_cont& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
//        std::cout<<"LEVEL SET NORMAL. TO BE SUBSTITUTED WITH PARAMETRIC ONE!"<<std::endl;
        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            /// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , subcl );
        }
    }


    Eigen::Matrix<T,2,1> normal_cont(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
           //std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient( pt , level_set.msh , subcl );
        }

    }
    
    Eigen::Matrix<T,2,1> gradient_disc(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
           //std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc( pt , level_set.msh , subcl );
        }

    }

    /*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence( pt , level_set.msh , subcl );
        }
    }

    T divergence_cont( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    T divergence_disc( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }


    /*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
    // STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }

//    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
//    {
//        //agglo_LS_cl = cl;
//        cell_assignment(cl);
//        std::cout<<"If here, check the code, this function it could be wrong! Idea is use such as function divergence(pt,cl)."<<std::endl;
//        exit(9);
//        return normal( pt );
//    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"If here, check the code, this function it could be wrong! Idea is use such as function divergence(pt,cl)."<<std::endl;
        exit(9);
        return operator()( pt );
    }
    
    T divergence(const point<T,2>& pt,const cell_type& cl )
    {
        // cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence( pt , level_set.msh , cl );
    }
    
    T divergence_disc(const point<T,2>& pt,const cell_type& cl )
    {
        // cl is a subset of the agglo_cl. Direct choise of the sub_cell
        return level_set.divergence_disc( pt , level_set.msh , cl );
    }
    
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        return level_set.normal( pt , level_set.msh , cl );
    }
    
    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt , const cell_type& cl)
    {
        return level_set.normal_disc( pt , level_set.msh , cl );
    }


};


template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_cont_div_cont2: public Level_set_berstein_curvature2< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_grad_cont_div_cont2(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_cont_div_cont2()=default;

    LS_cell_high_order_grad_cont_div_cont2(const LS_cell_high_order_grad_cont_div_cont2& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_grad_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_grad_cont( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};

template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_disc_div_cont2: public Level_set_berstein_curvature2< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_grad_disc_div_cont2(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_disc_div_cont2()=default;

    LS_cell_high_order_grad_disc_div_cont2(const LS_cell_high_order_grad_disc_div_cont2& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};


template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_curvature_cont: public Level_set_berstein< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;
    //LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
   // : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
    // I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_curvature_cont(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_curvature_cont()=default;

    LS_cell_high_order_curvature_cont(const LS_cell_high_order_curvature_cont& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            /// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal_grad_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal_grad_cont( pt , level_set.msh , subcl );
        }
    }

    /*
    Eigen::Matrix<T,2,1> normal_cont(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }
    */

    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
           //std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont( pt , level_set.msh , subcl );
        }

    }

    /*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }
    /*
    T divergence_cont( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    T divergence_disc( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    */
    /*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
    // STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    /*
    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()( pt );
    }
    */

};





template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_div_disc_grad_n_cont: public Level_set_berstein< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_div_disc_grad_n_cont(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_div_disc_grad_n_cont()=default;

    LS_cell_high_order_div_disc_grad_n_cont(const LS_cell_high_order_div_disc_grad_n_cont& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_grad_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_grad_cont( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};









template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_cont_div_disc: public Level_set_berstein< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_grad_cont_div_disc(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_cont_div_disc()=default;

    LS_cell_high_order_grad_cont_div_disc(const LS_cell_high_order_grad_cont_div_disc& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_grad_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_grad_cont( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_cont( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_grad_cont( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_grad_cont( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};


template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_disc_div_disc: public Level_set_berstein< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_grad_disc_div_disc(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_disc_div_disc()=default;

    LS_cell_high_order_grad_disc_div_disc(const LS_cell_high_order_grad_disc_div_disc& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};

/*
template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_disc_div_cont: public Level_set_berstein< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;

    LS_cell_high_order_grad_disc_div_cont(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_disc_div_cont()=default;

    LS_cell_high_order_grad_disc_div_cont(const LS_cell_high_order_grad_disc_div_cont& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }




    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient_disc( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {

            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }



};
*/


template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_grad_cont_fast: public Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;
    //LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
   // : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
    // I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_grad_cont_fast(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_grad_cont_fast()=default;

    LS_cell_high_order_grad_cont_fast(const LS_cell_high_order_grad_cont_fast& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            /// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , subcl );
        }
    }


    Eigen::Matrix<T,2,1> normal_cont(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_cont( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> normal_disc(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal anzichè normal_continuous!"<<std::endl;
            return level_set.normal_disc( pt , level_set.msh , subcl );
        }
    }

    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
           //std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient( pt , level_set.msh , subcl );
        }

    }

    /*
    T divergence_disc_old( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc_old( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc_old( pt , level_set.msh , subcl );
        }
    }
    */

    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence( pt , level_set.msh , subcl );
        }
    }

    T divergence_cont( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_cont( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_cont( pt , level_set.msh , subcl );
        }
    }

    T divergence_disc( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence_disc( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence_disc( pt , level_set.msh , subcl );
        }
    }


    /*
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1 )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }
    */
    // STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()( pt );
    }


};


template< typename T , typename Mesh ,typename Level_Set,typename Fonction,typename FiniteSpace >
struct LS_cell_high_order_fast: public Level_set_berstein_high_order_interpolation_fast< Mesh,Fonction,FiniteSpace , T >
{

    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    T iso_val_interface ;
    T radius ;
    //LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
   // : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
    // I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell_high_order_fast(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_), iso_val_interface(level_set_.iso_val_interface ){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    LS_cell_high_order_fast()=default;

    LS_cell_high_order_fast(const LS_cell_high_order_fast& other ){
        agglo_msh = other.agglo_msh;
        level_set = other.level_set;
        iso_val_interface  = other.iso_val_interface;
        radius  = other.radius;

    }

    T operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"OPERATOR(): In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set( pt , level_set.msh , subcl );
        }

    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"NORMAL: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            /// QUI HO MODIFICATO!!!! METTERE NORMAL SE NON USO LA CONTINUA
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            //std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
            return level_set.normal( pt , level_set.msh , subcl );
        }
    }



    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {
           //std::cout<<"GRADIENT: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.gradient( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.gradient( pt , level_set.msh , subcl );
        }

    }



    T divergence( const point<T,2>& pt )const
    {

        if (subcells.size()<1)
        {
            //std::cout<<"DIVERGENCE: In subcells.size()=0 -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1]<<std::endl;
            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );

            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = level_set.msh.cells[offset_old];
            return level_set.divergence( pt , level_set.msh , cl_old );
        }
        else
        {
            //std::cout<<"OPERATOR(): In subcell AGGLO -----> OFFSET AGGLO[0] = "<<agglo_LS_cl.user_data.offset_subcells[0]<<" , OFFSET AGGLO[1] = " << agglo_LS_cl.user_data.offset_subcells[1] <<std::endl;
            auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
            auto subcl = level_set.msh.cells[offset];
            return level_set.divergence( pt , level_set.msh , subcl );
        }
    }



    // STARE ATTENTI QUA TORNAREEEE
    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        std::cout<<"Ho messo normal_disc anzichè normal!"<<std::endl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        //agglo_LS_cl = cl;
        cell_assignment(cl);
        return operator()( pt );
    }


};




template<typename T, typename Mesh ,typename Fonction >
struct projected_level_set: public level_set<T>
{
    std::vector< T > values;
    Eigen::Matrix<T, Dynamic, Dynamic> values_bis; // MATRIX NOTATION
    //Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh
    std::vector< size_t > boundary_cells;
    // In the case in which I use FEM with Qk , k>1 I need another vector for all the values in each node

    size_t degree_FEM;
    size_t number_elements;
    Mesh msh;
    size_t      Nx, Ny ;
    mesh_init_params<T> params;
    size_t  last_row_init, last_row_end, number_faces_one_row;
  //  size_t counter_cell , counter_face, num_cell_row;

    T phi_max , phi_min ;
    T cut_level;


    projected_level_set(const Fonction & level_set, const Mesh & msh, size_t degree_k , const mesh_init_params<T>& params)
        : number_elements((degree_k+1)*(degree_k+1)), msh(msh),degree_FEM(degree_k),Nx(params.Nx),Ny(params.Ny), params(params)
    {

        last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
        last_row_end = last_row_init + Nx-1;
        number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 );

    //#ifdef NODES
        // MATRIX NOTATION
        values_bis= Eigen::Matrix<T, Dynamic, Dynamic>::Zero(number_elements, msh.cells.size());
        // VECTOR NOTATION
        //values_bis1= Eigen::Matrix<T, Dynamic, 1>::Zero(number_elements*msh.cells.size(), 1 );

        //std::cout<<"Number of cells "<<msh.cells.size()<<std::endl;

        // MATRIX NOTATION
        // std::cout<<"Dimension of the basis "<<values_bis.size()<<std::endl;
        // VECTOR NOTATION
        // std::cout<<"Dimension of the basis "<<values_bis1.size()<<std::endl;
        size_t i_global = 0 , i_local=0 , i_vertex=0;
        for(auto& cl:msh.cells)
        {
            /*
            bool boundary_bool = FALSE;
            for (auto& fc:faces(msh,cl)) {
                if (boundary_bool)
                    break;

                if(fc.is_boundary && !boundary_bool){
                    boundary_cells.push_back(offset(msh,cl));
                    boundary_bool = TRUE;
                }
            }
            */

            auto qps = equidistriduted_nodes<T,Mesh>(msh, cl, degree_FEM);
            i_local = 0;
            for ( const auto & qp : qps)
            {

                values.push_back( level_set(qp) ); // I DONT KNOW IF IT IS USEFUL

               // if (boundary_bool) {
               //      values_bis(i_local,i_global) = 1 ;  // MATRIX NOTATION
               // }
                values_bis(i_local,i_global) = level_set(qp) ;  // MATRIX NOTATION
                //values_bis1(i_local+i_global) = level_set(qp) ; // VECTOR NOTATION
                i_vertex = i_global+floor(i_global/Nx);
                if( i_local==0 )
                    vertices(i_vertex) = level_set(qp) ;

                if( i_local==1 )
                    vertices(i_vertex+1) = level_set(qp) ;

                if( i_local==(degree_FEM+2) )
                    vertices(i_vertex+Nx+2) = level_set(qp) ;

                if( i_local==(degree_FEM+1) )
                    vertices(i_vertex+Nx+1) = level_set(qp) ;
                i_local++;
            }
             i_global++;  // MATRIX NOTATION
           //  i_global+=number_elements;       // VECTOR NOTATION
        }
    //#endif


    }

    projected_level_set()=default;


    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        values_bis=values_new;
    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& vertices )
    {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols() ; j++)
        {

            for (size_t i = 0; i < values_bis.rows() ; i++)
            {
                auto i_vertex = j + floor(j/Nx);
                if ( i == 0 )
                    values_bis(i,j) = vertices(i_vertex);

                if( i ==1 )
                    values_bis(i,j) = vertices(i_vertex+1) ;

                if( i ==(degree_FEM+2) )
                    values_bis(i,j) = vertices(i_vertex+Nx+2) ;

                if( i ==(degree_FEM+1) )
                    values_bis(i,j) = vertices(i_vertex+Nx+1) ;
            }
        }

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values )
    {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols() ; j++)
        {

            for (size_t i = 0; i < values_bis.rows() ; i++)
            {
                auto i_vertex = j + floor(j/Nx);
                if ( i == 0 )
                    vertices(i_vertex) = values(i,j) ;

                if( i ==1 )
                    vertices(i_vertex+1) = values(i,j) ;

                if( i ==(degree_FEM+2) )
                    vertices(i_vertex+Nx+2) = values(i,j) ;

                if( i ==(degree_FEM+1) )
                    vertices(i_vertex+Nx+1) = values(i,j) ;
            }
        }

    }



    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    T operator()( const typename Mesh::node_type& node ) const
    {
        // Optimised to check the value of the level set only in the vertices
        // std::cout<<"Value in vertices "<<vertices(node.ptid)<<", at position "<<node.ptid<<std::endl;
        return vertices(node.ptid);

    }


    // OK FINE, IT WORKS ALSO FOR AGGLOMERATED MESHES
    T operator()(const point<T,2>& pt) const
    {
        //std::cout<<"I AM IN OPERATOR() SLOW !!!!"<<std::endl;
        size_t counter=0;

        // It looks for in what cell the point is
        for( const auto& cl:msh.cells)
        {
            //std::cout<<"pt_in_cell operator in slow levelset"<<std::endl;
            if( pt_in_cell<T,Mesh>(msh,pt,cl) )
            {
                //cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = (values_bis.block(0,counter,number_elements,1)).col(0);
                return values_cell.dot( cb.eval_basis(pt) );

               // T tmp=0;
               // for(auto i = 0; i<number_elements ; i++)
               // {
               //     tmp += (values.at(i+counter))*(cb.eval_basis(pt))[i];
               // }
               // return tmp;
            }
            //counter+=number_elements; // OLD VERSION OF THE CODE
            counter+=1;
        }
        std::cout<<"IF HERE, THERE IS A PROBLEM IN projected_level_set::operator()!!!"<<std::endl;
        return 1e10; //to check if doesn't enter in the loop
    }

    // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        // Checking if cell is agglomerated or not
        /*
        size_t cell_points = (points(msh,cl)).size();
        size_t cells_number = msh.cells.size();
        bool agglomeration=FALSE;
        if ( cells_number < (Nx*Ny-1) ) {
            agglomeration = TRUE;
        }
        if ( cells_number > (Nx*Ny-1) ) {
                  // throw std::logic_error("shouldn't have arrived here...");
               }
        */

        //if(cell_points<5)
        //{
            // MATRIX NOTATION
         //   if (!agglomeration) {
         //       counter = offset(msh,cl);
         //    }
         //   else{
         //       counter = 1;//cells_counter(msh_origin,msh,cl);
         //   }

            //std::cout<<"Value of offset "<<counter<<std::endl;
            //cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
        cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (values_bis.block(0,counter,number_elements,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;

            // VECTOR NOTATION

            //size_t counter = offset(msh,cl)*number_elements;
            //cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
            //auto values_cell = (values_bis1.segment(counter,number_elements));
            //T tmp = values_cell.dot( cb.eval_basis(pt) );
            //return tmp;
       // }
        /*
        else
        {
            std::vector<size_t> indices = subcell_finder<T,Mesh>(msh, pt , cl , params);
            cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM,indices);
            size_t counter = 1; // DA TROVAREEE!!!!!!!!!!!!!!!
            auto values_cell = (values_bis.block(0,counter,number_elements,1)).col(0);
            T tmp = values_cell.dot( cb.eval_basis(pt) );
            return tmp;
        }
        */


    }

 // IT WORKS ONLY FOR NOT-AGGLOMERATED MESHES
    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::face_type& fc ) const
       {
           // MATRIX NOTATION
           auto counter_face = offset(msh,fc);
           size_t counter_cell;
           // da fc devo trovare la cella in cui sono per la base
           //std::cout<<"Face number "<<counter_face<<std::endl;

           // ATTENTION, ALL THIS WORKS IN STRUCTURED QUADRANGULAR MESHES

           // Check if I am in the last row, upper faces (ordered differently)
           if(counter_face>=last_row_init && counter_face<=last_row_end)
           {
               counter_cell = (Ny-1)*Nx + counter_face%(last_row_init);
           }
           else
           {
            // Find in what row the face is
             auto  num_cell_row = floor(counter_face/(number_faces_one_row));
               if ( counter_face!= ( (2*Nx)*(num_cell_row+1)+num_cell_row ) )
               {
                // Faces not on the right boudary, to know in what cell are, it is sufficient to analyse the low and left face of each quadrangular cell.
                   counter_cell = floor( (counter_face-num_cell_row)/2.0 );
               }
               else
               {
                // Face on the right boudary,
                   counter_cell = ( num_cell_row+1 )*Nx -1;
               }

           }
           //std::cout<<"Face->Cell number "<<counter_cell<<std::endl;
           auto cl = msh.cells.at(counter_cell);
           //cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
           cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
           auto values_cell = (values_bis.block(0,counter_cell,number_elements,1)).col(0);
           T tmp = values_cell.dot( cb.eval_basis(pt) );
           return tmp;


       }



    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }


    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        size_t counter=0;
        //std::cout<<"I AM IN GRADIENT SLOW !!!!"<<std::endl;
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        for( const auto& cl:msh.cells)
        {
            // std::cout<<"pt_in_cell gradient in slow levelset"<<std::endl;
            if(pt_in_cell<T,Mesh>(msh,pt,cl))
            {
                //cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
                cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);

                auto values_cell = values_bis.col(counter);
                auto grad_eval =  cb.eval_gradients(pt);
                ret(0) = values_cell.dot( grad_eval.col(0) );
                // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
                ret(1) = values_cell.dot( grad_eval.col(1) );

                return ret;
            }
            //counter+=number_elements; // OLD VERSION OF THE CODE
            counter+=1;

        }
        std::cout<<"Se compare questo problema in gradient()"<<std::endl;
        ret(0)+=1e10;
        ret(1)+=1e10;
        return ret; //to check if doesn't enter in the loop

    }


    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        // MATRIX NOTATION
        size_t counter = offset(msh,cl);
        //std::cout<<"the cell in NEW is the number "<<counter<<std::endl;
        //std::cout<<"Value of offset "<<counter<<std::endl;
        //cell_basis_Qk<Mesh,T> cb(msh, cl, degree_FEM);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = values_bis.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
       // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
        ret(1) = values_cell.dot( grad_eval.col(1) );
        //values_cell.dot( grad_eval.col(1) );
       // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
        return ret;

        // VECTOR NOTATION

        //size_t counter = offset(msh,cl)*number_elements;
        //cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        //auto values_cell = (values_bis1.segment(counter,number_elements));
        //T tmp = values_cell.dot( cb.eval_basis(pt) );
        //return tmp;


    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient(pt,msh,cl);
        return ret/ret.norm();

    }





    // template<typename T , typename MATRIX , typename VECTOR >
    void smooth_cut_off( T C , T x_centre , T y_centre , T radius )
    {
        T hx = params.hx();
        T hy = params.hy();
        cut_level = C;
        // T r0 = radius + 2*sqrt(pow(hx,2) + pow(hy,2)); // check value
        //T r0 = radius + 2.5*std::max(hx , hy ); // check value
        //T r0 = radius + 2.5*0.0625; // check value
        T pos_r0 = 0.45; //std::min(x_centre , 1 - x_centre );
        // IF I wanna define like that I need to pass the value all'inizio, sennò cambia per valure le exact solution (cambiando x_centre).

        //T max_r0 = pos_r0-(pos_r0 - 2*0.0625); //2.5*std::max(hx,hy); // if mesh too much coarse
        //r0 = std::max(r0 , max_r0);
        //r0 = 0.25*max_r0 + 0.75*r0 ;
        //if(r0<radius)
          //  r0 += 0.0625 ;
        T dist = pos_r0 - radius + 2*0.0625;
        T r0 = radius + dist/2;
        T delta = r0/8;
        //T delta = 0.0625 ; // r0/20.0; // or better std::max(hx,hy) ??
        //T delta = sqrt(pow(hx,2) + pow(hy,2));
        //if(std::abs(r0-delta-radius)<2*std::max(hx,hy) )
         //   delta = delta/2;

        std::cout<<"radius = "<<radius<<" , r0 = "<<r0<<" , delta = "<<delta<<" , hx = hy = "<<hx<<std::endl;
        std::cout<<"value in alfa in r_int = "<<(radius-r0)/delta<<std::endl;
        std::cout<<"value in alfa in R = "<<(pos_r0-r0)/delta<<std::endl;
        auto alfa = [x_centre , y_centre , delta , r0](const typename Mesh::point_type& pt) { // sol
            return (1 - tanh( (sqrt(pow((pt.x()-x_centre),2) + pow((pt.y()-y_centre),2)) - r0 ) / delta ))/2;};

        size_t counter = 0;
       // Eigen::Matrix<T, Dynamic, 1> tmp_vert = Matrix<T, Dynamic, 1>::Zero(vertices.rows(), 1); ;
        for(auto& pt:msh.points )
        {
           // std::cout<<"the point is "<< pt<<" alfa is "<<alfa(pt)<<std::endl;
            vertices(counter) = ( 1 - alfa(pt)  )*C + alfa(pt)*vertices(counter);
            counter++;
        }

        converting_into_HHO_formulation(vertices);
        phi_max = vertices.maxCoeff();
        phi_min = vertices.minCoeff(); // DEVO CAMBIARLO O VA BENE COSI?

        postprocess_output<double> postoutput00;
        //typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto alfa_values = std::make_shared< gnuplot_output_object<double> >("alfa.dat");
        //auto interface_pos = std::make_shared< gnuplot_output_object<double> >("interface_alfa.dat");
        for(auto& pt:msh.points )
               {
                  alfa_values->add_data(pt,alfa(pt));
               }
        postoutput00.add_object(alfa_values);
        postoutput00.write();
    }




   // template<typename T , typename MATRIX , typename VECTOR >
    void cut_off( T d )
    {
        //auto vertices_abs = vertices.cwiseAbs();
        //auto phi_max_abs = d*vertices_abs.maxCoeff();
        //std::cout<<"MAX VALUE OF PHI ABS"<<phi_max_abs<<std::endl;

        cut_level = d ;
        //std::cout<<"CUTTING AT d = "<<d<<std::endl;
        T level_set_max = vertices.maxCoeff();
        //std::cout<<"MAX VALUE OF PHI BEFORE CUTTING = "<<level_set_max<<std::endl;
        //assert(degree_FEM == 1)

        Eigen::Matrix<T, Dynamic, Dynamic> One_mat = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(values_bis.rows(), values_bis.cols() ); // MATRIX NOTATION
           //Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
        Eigen::Matrix<T, Dynamic, 1> One_vec = Eigen::Matrix<T, Dynamic, 1>::Ones( vertices.rows(), 1 ); // saving level_set on vertices mesh


       auto cut_off_level_vec = d*One_vec ;
       auto cut_off_level_mat = d*One_mat ;

        vertices/=(level_set_max);
        values_bis/=(level_set_max);
       // std::cout<<"MAX VALUE OF NORMALISED PHI = "<<vertices.maxCoeff()<<std::endl;
        auto vertices_prova = vertices;
        auto values_bis_prova = values_bis ;

        vertices = vertices.cwiseMin(cut_off_level_vec);
        values_bis = values_bis.cwiseMin(cut_off_level_mat);
        // Cut off also in inner domain
        vertices = vertices.cwiseMax(-cut_off_level_vec);
        values_bis = values_bis.cwiseMax(-cut_off_level_mat);

        // NOT NORMALISED CUT
        //vertices = vertices.cwiseMin(cut_off_level_vec*level_set_max);
        //values_bis = values_bis.cwiseMin(cut_off_level_mat*level_set_max);


        phi_max = vertices.maxCoeff();
        phi_min = vertices.minCoeff(); // DEVO CAMBIARLO O VA BENE COSI?
        //std::cout<<"MAX VALUE OF PHI_CUT AND NORMALISED = "<<phi_max<<std::endl;
        std::cout<<"Cut at "<<phi_max<<" , MIN VALUE OF PHI_CUT AND NORMALISED = "<<phi_min<<" (NEGATIVE cut off ACTIVED)."<<std::endl;

        /*
        postprocess_output<double> postoutput2;
        typedef typename Mesh::point_type       point_type;
        point<double,2> node;
        auto test_activated_nodes = std::make_shared< gnuplot_output_object<double> >("test_activated_nodes.dat");
        auto test_before_cut_off = std::make_shared< gnuplot_output_object<double> >("test_before_cut_off.dat");

        for (size_t i = 0; i<vertices_prova.rows(); i++) {
            node = msh.points.at(i);
            test_before_cut_off->add_data(node,vertices_prova(i));

            if( std::abs(vertices_prova(i) - vertices(i))>1e-10 )
                vertices_prova(i) = 1;
            else
                vertices_prova(i) = 0;
            test_activated_nodes->add_data(node,vertices_prova(i));


        }


        for (size_t j = 0; j<values_bis.cols(); j++)
        {
            bool active_cell= FALSE;
            size_t i = 0;
            while (i<values_bis.rows() && !active_cell ) {
                if( values_bis_prova(i,j)!= values_bis(i,j) ){
                    active_cell = TRUE;
                //std::cout<<"values_bis_prova(i,j)= "<<values_bis_prova(i,j)<<" , values_bis(i,j)= "<<values_bis(i,j)<<std::endl;
              //  std::cout<<" the cell num "<<j<<" is active."<<std::endl;
                }
                i++;
            }
        }



        postoutput2.add_object(test_before_cut_off);
        postoutput2.add_object(test_activated_nodes);
        postoutput2.write();
        */
        /*
        for (size_t i = 0 ; i<values_bis.rows() ; i++ ) {
            for (size_t j = 0 ; j<values_bis.cols() ; j++ ) {

            }

        }
            */

    }

    void boundary_con( T d )
    {
        T level_set_max = vertices.maxCoeff();
        std::cout<<"MAX VALUE OF PHI"<<level_set_max<<std::endl;
        //assert(degree_FEM == 1)

        Eigen::Matrix<T, Dynamic, Dynamic> One_mat = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(values_bis.rows(), values_bis.cols() ); // MATRIX NOTATION
           //Eigen::Matrix<T, Dynamic, 1> values_bis1; // VECTOR NOTATION
        Eigen::Matrix<T, Dynamic, 1> One_vec = Eigen::Matrix<T, Dynamic, 1>::Ones( vertices.rows(), 1 ); // saving level_set on vertices mesh


       auto cut_off_level_vec = d*One_vec ;
       auto cut_off_level_mat = d*One_mat ;

        vertices/=(level_set_max);
        values_bis/=(level_set_max);
        vertices = vertices.cwiseMin(cut_off_level_vec);
        values_bis = values_bis.cwiseMin(cut_off_level_mat);
        /*
        for (size_t i = 0 ; i<values_bis.rows() ; i++ ) {
            for (size_t j = 0 ; j<values_bis.cols() ; j++ ) {

            }

        }
            */

    }




};


template<typename T>
class velocity_field
{
   public:
    virtual Eigen::Matrix<T,2,1> operator()(const point<T,2>& pt) const
    {
    }

    /*
     virtual Eigen::Matrix<T,2,1> flux(const point<T,2>& pt) const
    {
    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        ret = gradient(pt);
        return ret/ret.norm();
    }
    */

};



template<typename T>
struct rotational_velocity_field: public velocity_field<T>
{
    T u1, xc , yc;

    rotational_velocity_field(T u1 )
    : u1(u1){}

    rotational_velocity_field(T xc , T yc , T u1 )
    : u1(u1) , xc(xc) , yc(yc)
    {}

    Eigen::Matrix<T,2,1> operator()(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret(0) = (  u1*pt.y() -xc )/xc ;
        ret(1) = (- u1*pt.x() + yc ) / yc ;

        return ret;
    }


};

template<typename T>
struct linear_velocity_field: public velocity_field<T>
{
    T u1, u2 , u3 , u4;

    linear_velocity_field(T u1 , T u2 , T u3 , T u4 )
        : u1(u1), u2(u2) , u3(u3) , u4(u4)
    {}

    Eigen::Matrix<T,2,1> operator()(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret(0) = u1*pt.x() + u2;
        ret(1) = u3*pt.y() + u4;

        return ret;
    }
/*
    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret(0) = 2*pt.x() - 2*alpha;
        ret(1) = 2*pt.y() - 2*beta;
        return ret;
    }
    */
};



template<typename T>
struct taylor_green_vortex: public velocity_field<T>
{
    T viscosity = 2.0 ;
    T time = 0.0 ;
    T F = std::exp( -2*viscosity * time ) ;
    bool old_tgv = true;

    taylor_green_vortex(T a , bool old_tgv): viscosity(a), old_tgv(old_tgv){};
    taylor_green_vortex(){};
    taylor_green_vortex(T a ): viscosity(a){};

    Eigen::Matrix<T,2,1> operator()(const point<T,2>& pt) const
    {
        Eigen::Matrix<T,2,1> ret;

        if( old_tgv )
        {
            ret(0) =  std::cos( 2*M_PI*pt.x() ) * std::sin( 2*M_PI*pt.y() ) * F ;
            ret(1) = -std::sin( 2*M_PI*pt.x() ) * std::cos( 2*M_PI*pt.y() ) * F ;
        }
        else
        {
            ret(0) =  std::sin( 2*M_PI*pt.x() ) * std::cos( 2*M_PI*pt.y() ) * F ;
            ret(1) = -std::cos( 2*M_PI*pt.x() ) * std::sin( 2*M_PI*pt.y() ) * F ;
        }
        return ret;
    }

    void
    set_time( T new_time )
    {
        time = new_time ;
        F = std::exp( -2*viscosity * time ) ;

    }


};




template< typename Mesh , typename Fonction , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct projection_velocity_high_order: public velocity_field<T>
{

     size_t  last_row_init, last_row_end, number_faces_one_row;


     // NEW IMPLEMENTATION STUFF
     Mesh msh; // Original mesh, NOT agglomerated.
     mesh_init_params<T> params; // mesh parameter

     size_t degree_FEM ; // FEM degree
     size_t n_cls ; // #cells
     size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
     size_t n_vertices ; // #vertices
      size_t      Nx, Ny ; // Number of cells in x and y direciton
     // connectivity matrix : for each cell, it stores the global numbering
     std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
     //std::vector<std::vector<size_t>> connectivity_matrix ;

     size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
     size_t ndof_FE; // Global dimension FE continuous = #nodes

     T u_max0 , u_max1 ;


     //SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
     //Matrix<T, Dynamic, 1>           RHS0;    // Known term 1
     //Matrix<T, Dynamic, 1>           RHS1;    // Known term 1
     //std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

     std::pair<Eigen::Matrix<T, Dynamic, Dynamic> , Eigen::Matrix<T, Dynamic, Dynamic>> sol_HHO ; // projection saved in HHO format: cell by cell
     std::pair<Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> sol_FEM ; // projection saved in Continuos FE format: global nodes
     //std::pair<Eigen::Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> vertices; // saving level_set on vertices mesh



     projection_velocity_high_order(const FiniteSpace& fe_data , const Mesh & msh )
           : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE)
       {
           std::cout<<"STO USANDO: equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree)"<<std::endl;
           //last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
           //last_row_end = last_row_init + Nx-1;
           //number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary


           //vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( ( (Nx+1)*(Ny+1) ), 1 ) , Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 ) );


           //vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
           sol_FEM = std::make_pair( Matrix<T, Dynamic, 1>::Zero(ndof_FE) , Matrix<T, Dynamic, 1>::Zero(ndof_FE) );

           sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) , Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ) ;


       }

    projection_velocity_high_order(const FiniteSpace& fe_data , const Fonction & u, const Mesh & msh)
        : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE)
    {
        //last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
        //last_row_end = last_row_init + Nx-1;
        //number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary

        // Saving the projection in HHO discontinuous format (MATRIX NOTATION)
         //vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
         sol_FEM = std::make_pair( Matrix<T, Dynamic, 1>::Zero(ndof_FE) , Matrix<T, Dynamic, 1>::Zero(ndof_FE) );

         sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) , Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ) ;


        size_t i_global = 0 , i_local=0 ; //, i_vertex=0;
        for(auto& cl:msh.cells)
        {
            auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree_FEM);
            i_local = 0;
            for ( const auto & qp : qps)
            {
                auto asm_map = connectivity_matrix[i_global][i_local].first ;
                auto u0 = (u(qp))(0) ;
                auto u1 = (u(qp))(1) ;

                sol_HHO.first(i_local,i_global) = u0 ;
                sol_HHO.second(i_local,i_global) = u1 ;
                sol_FEM.first(asm_map) = u0 ;
                sol_FEM.second(asm_map) = u1 ;
           /*
                i_vertex = i_global+floor(i_global/Nx);
                if( i_local==0 ){
                    vertices.first(i_vertex) = u0 ;
                    vertices.second(i_vertex) = u1 ;
                }

                if( i_local==1 ){
                    vertices.first(i_vertex+1) = u0 ;
                    vertices.second(i_vertex+1) = u1 ;
                }

                if( i_local==(degree_FEM+2) ){
                    vertices.first(i_vertex+Nx+2) = u0 ;
                    vertices.second(i_vertex+Nx+2) = u1 ;
                }

                if( i_local==(degree_FEM+1) ){
                    vertices.first(i_vertex+Nx+1) = u0 ;
                    vertices.second(i_vertex+Nx+1) = u1 ;
                }
            */

                i_local++;


            }
            i_global++;


        }

    }


    template< typename MATRIX >
    void  set_discrete_points( MATRIX& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" Using set_discrete_points check that sol_FEM already uploaded!"<<std::endl;

    }

    template< typename VECTOR >
    void converting_into_HHO_formulation( const VECTOR& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO.first(i,counter_bis) = values_new.first( asm_map );
                sol_HHO.second(i,counter_bis) = values_new.second( asm_map );
            }
            //  size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            //  vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            //  vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            // vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            //  vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        std::cout<<" Using converting_into_HHO_formulation check that sol_FEM already uploaded!"<<std::endl;
        //set_max_min();
        //phi_min = sol_HHO.minCoeff() ;
        //phi_max = sol_HHO.maxCoeff() ;

    }

    template< typename MATRIX >
    void converting_into_FE_formulation( const MATRIX& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM.first( asm_map ) = values_new.first(i,counter_bis) ;
                sol_FEM.second( asm_map ) = values_new.second(i,counter_bis) ;
            }
            //  size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            //  vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            //  vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            // vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            //  vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        std::cout<<" Using converting_into_FE_formulation check that sol_HHO already uploaded!"<<std::endl;
        //set_max_min();
        //phi_min = sol_FEM.minCoeff() ;
        //phi_max = sol_FEM.maxCoeff() ;

    }



    std::pair<T,T> operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl) const
    {
        size_t counter = offset(msh,cl) ;
        cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        //std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
        auto values_cell_first = (sol_HHO.first.block(0,counter,local_dim,1)).col(0);
        auto values_cell_second = (sol_HHO.second.block(0,counter,local_dim,1)).col(0);
        //std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
        //std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
        T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
        T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );
        //std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

        return std::make_pair(tmp1,tmp2);
    }



};


template< typename Mesh , typename FiniteSpace , typename T = typename Mesh::coordinate_type  >
struct velocity_high_order
{

     size_t  last_row_init, last_row_end, number_faces_one_row;


     // NEW IMPLEMENTATION STUFF
     Mesh msh; // Original mesh, NOT agglomerated.
     mesh_init_params<T> params; // mesh parameter

     size_t degree_FEM ; // FEM degree
     size_t n_cls ; // #cells
     size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
     size_t n_vertices ; // #vertices
      size_t      Nx, Ny ; // Number of cells in x and y direciton
     // connectivity matrix : for each cell, it stores the global numbering
     std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;
     //std::vector<std::vector<size_t>> connectivity_matrix ;

     size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
     size_t ndof_FE; // Global dimension FE continuous = #nodes

     T u_max0 , u_max1 ;


     //SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
     //Matrix<T, Dynamic, 1>           RHS0;    // Known term 1
     //Matrix<T, Dynamic, 1>           RHS1;    // Known term 1
     //std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

     std::pair<Eigen::Matrix<T, Dynamic, Dynamic> , Eigen::Matrix<T, Dynamic, Dynamic>> sol_HHO ; // projection saved in HHO format: cell by cell
     std::pair<Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> sol_FEM ; // projection saved in Continuos FE format: global nodes
     //std::pair<Eigen::Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1>> vertices; // saving level_set on vertices mesh


    // AGGLOMERATED MESHES DATA:
    typedef typename Mesh::cell_type       cell_type;
    Mesh agglo_msh;
    std::vector<cell_type> subcells;
    cell_type agglo_LS_cl;

    
     velocity_high_order(const FiniteSpace& fe_data , const Mesh & msh  )
           : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE)
       {
           //std::cout<<"velocity_high_order: -> implemented with equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree)"<<std::endl;
           //last_row_init = Ny*(2*Nx+1); // There are 2 faces for each row of cells + Ny
           //last_row_end = last_row_init + Nx-1;
           //number_faces_one_row = 2*Nx+1; // for each cell I count only the low and sx faces, respectevely 0-1 2-3 4-5 6-7 8 + the last on the right boundary


           //vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( ( (Nx+1)*(Ny+1) ), 1 ) , Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 ) );


           //vertices = std::make_pair( Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ),Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 ) );
           sol_FEM = std::make_pair( Matrix<T, Dynamic, 1>::Zero(ndof_FE) , Matrix<T, Dynamic, 1>::Zero(ndof_FE) );

           sol_HHO = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) , Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls ) ) ;


       }

    void set_agglo_mesh( Mesh & m_agglo_msh )
    {
        agglo_msh = m_agglo_msh;
    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;

        if( (agglo_LS_cl.user_data.offset_subcells.size()>1) &&  (agglo_LS_cl.user_data.offset_subcells[0] != agglo_LS_cl.user_data.offset_subcells[1] ) )
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( msh.cells[offset_subcells] );

            }
        }

    }


    template< typename MATRIX >
    void  set_discrete_points( MATRIX& values_new)
    {
        sol_HHO = values_new ;
        std::cout<<" Using set_discrete_points: sol_FEM has to be already uploaded!"<<std::endl;

    }

    template< typename VECTOR >
    void converting_into_HHO_formulation( const VECTOR& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO.first(i,counter_bis) = values_new.first( asm_map );
                sol_HHO.second(i,counter_bis) = values_new.second( asm_map );
            }
            //size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            //vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            //vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            //vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            //vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        std::cout<<" Using converting_into_HHO_formulation: sol_FEM has to be already uploaded!"<<std::endl;
        //set_max_min();
        //phi_min = sol_HHO.minCoeff() ;
        //phi_max = sol_HHO.maxCoeff() ;

    }

    template< typename MATRIX >
    void converting_into_FE_formulation( const MATRIX& values_new )
    {

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM.first( asm_map ) = values_new.first(i,counter_bis) ;
                sol_FEM.second( asm_map ) = values_new.second(i,counter_bis) ;
            }
           //size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            //vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            //vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            //vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            //vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO.first(i,counter_bis) = sol_FEM.first( asm_map );
                sol_HHO.second(i,counter_bis) = sol_FEM.second( asm_map );
            }

        }

        //std::cout<<"Using converting_into_FE_formulation: sol_FEM has to be already uploaded!"<<std::endl;
        //set_max_min();
        //phi_min = sol_FEM.minCoeff() ;
        //phi_max = sol_FEM.maxCoeff() ;

    }

    template< typename LEVEL_SET , typename TRANSPORT_METHOD >
    void L2_proj_into_FE_formulation( LEVEL_SET& level_set , const Mesh & msh , const TRANSPORT_METHOD& method )
    {
        std::cout<<"L2 projection to have CONTINUOUS FE: SimplicialLLT to invert global Mass Matrix."<<std::endl;
        timecounter tc_vel ;
        tc_vel.tic();
        Matrix<T, Dynamic, 1> RHS1 =  Matrix<T, Dynamic, 1>::Zero( ndof_FE );
        Matrix<T, Dynamic, 1> RHS2 =  Matrix<T, Dynamic, 1>::Zero( ndof_FE );
        SimplicialLLT<SparseMatrix<T> >solver_global_mass;
        solver_global_mass.compute(method.Global_Mass);

        for(auto cl : msh.cells )
        {
            auto local_RHS = make_bernstein_local_RHS_VEC( msh , cl , degree_FEM , *this );
            size_t cell_offset = offset(msh,cl);
            for (size_t i = 0; i < local_dim; i++)
            {
                size_t asm_map_i = connectivity_matrix[cell_offset][i].first ;
                RHS1(asm_map_i) += local_RHS.first(i) ;
                RHS2(asm_map_i) += local_RHS.second(i) ;
            }

        }
        sol_FEM.first = solver_global_mass.solve(RHS1);
        sol_FEM.second = solver_global_mass.solve(RHS2);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO.first(i,counter_bis) = sol_FEM.first( asm_map );
                sol_HHO.second(i,counter_bis) = sol_FEM.second( asm_map );
            }

        }

        tc_vel.toc();
        //std::cout<<"Time to L2 project velocity field : "<<tc_vel<<std::endl;
    }

    template< typename MATRIX >
    void smooth_converting_into_FE_formulation( const MATRIX& values_new )
    {
        std::cout<<"SMOOTH CONVERTING INTO CONTINUOUS FE: --> For each point a geometrical average implemented."<<std::endl;
        Array<T,Dynamic,1> counting_avg = Array<T,Dynamic,1>::Zero(ndof_FE) ;
        Array<T,Dynamic,1> sum_first = Array<T,Dynamic,1>::Zero(ndof_FE) ;
        Array<T,Dynamic,1> sum_second = Array<T,Dynamic,1>::Zero(ndof_FE) ;
        //std::array<T, ndof_FE > counting_avg;
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sum_first( asm_map ) += values_new.first(i,counter_bis) ;
                sum_second( asm_map ) += values_new.second(i,counter_bis);
                counting_avg(asm_map)++;
            }
           //size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            //vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            //vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            //vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            //vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }
        sol_FEM.first = (sum_first.array()).cwiseQuotient(counting_avg);
        sol_FEM.second = (sum_second.array()).cwiseQuotient(counting_avg);

        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO.first(i,counter_bis) = sol_FEM.first( asm_map );
                sol_HHO.second(i,counter_bis) = sol_FEM.second( asm_map );
            }

        }
        //std::cout<<"counting_avg"<<'\n'<<counting_avg<<std::endl;
        std::cout<<"In CONVERTING FE SMOOTH -> Using converting_into_FE_formulation: sol_HHO has to be already uploaded!"<<std::endl;

        //set_max_min();
        //phi_min = sol_FEM.minCoeff() ;
        //phi_max = sol_FEM.maxCoeff() ;

    }


    std::pair<T,T> operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl) const
    {
        size_t counter = offset(msh,cl) ;
        cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl, degree_FEM);
        //std::cout<<"cb u proj high order"<<'\n'<<cb.eval_basis(pt)<<'\n'<<std::endl;
        auto values_cell_first = (sol_HHO.first.block(0,counter,local_dim,1)).col(0);
        auto values_cell_second = (sol_HHO.second.block(0,counter,local_dim,1)).col(0);
        //std::cout<<"values_cell_first"<<'\n'<<values_cell_first<<'\n'<<std::endl;
        //std::cout<<"values_cell_second"<<'\n'<<values_cell_second<<'\n'<<std::endl;
        T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
        T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );
        //std::cout<<"tmp1"<<" "<<tmp1<<'\n'<<"tmp2"<<" "<<tmp2<<std::endl;

        return std::make_pair(tmp1,tmp2);
    }


    //  OPERATOR for MESH AGGLOMERATED
    std::pair<T,T> operator()(const point<T,2>& pt) const
    {

        if (subcells.size()<1)
        {

            assert(agglo_LS_cl.user_data.offset_subcells.size()==2);
            assert( agglo_LS_cl.user_data.offset_subcells[0] == agglo_LS_cl.user_data.offset_subcells[1] );
            auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
            auto cl_old = msh.cells[offset_old];

            cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, cl_old , degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0,offset_old,local_dim,1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0,offset_old,local_dim,1)).col(0);

            T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
            T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );

            return std::make_pair(tmp1,tmp2);

        }
        else
        {
            auto offset = pt_in_subcell(msh,pt,agglo_LS_cl);
            auto subcl = msh.cells[offset];

            cell_basis_Lagrangian_ordered<Mesh,T> cb(msh, subcl , degree_FEM);

            auto values_cell_first = (sol_HHO.first.block(0,offset,local_dim,1)).col(0);
            auto values_cell_second = (sol_HHO.second.block(0,offset,local_dim,1)).col(0);

            T tmp1 = values_cell_first.dot( cb.eval_basis(pt) );
            T tmp2 = values_cell_second.dot( cb.eval_basis(pt) );

            return std::make_pair(tmp1,tmp2);

        }

    }


};




template< typename Mesh>
struct Current_Mesh
{
    Mesh current_mesh ;
    Current_Mesh(const Mesh& msh):current_mesh(msh){}

    void set_current_mesh(const Mesh& msh)
    {
        current_mesh = msh;
    }


};



template< typename T , typename Mesh ,typename Level_Set,typename Fonction >
struct LS_cell: public projected_level_set< T,  Mesh , Fonction>
{
    typedef typename Mesh::cell_type       cell_type;
    cell_type agglo_LS_cl;
    std::vector<cell_type> subcells;
    Mesh agglo_msh;
    Level_Set level_set;
    //LS_cell(const Level_Set & level_set, const Mesh & msh, const typename Mesh::cell_type& cl)
   // : agglo_cl(cl), agglo_msh(msh), level_set(level_set){}
    // I don't know if I have to define a copyconstructor for level_set.. TO BE CHECKED!
    LS_cell(const Level_Set & level_set_, const Mesh & msh)
    : agglo_msh(msh), level_set(level_set_){}
    //LS_cell(const Level_Set & level_set )
    //: level_set(level_set){}

    //LS_cell()=default;

    T operator()(const point<T,2>& pt) const
       {
           if (subcells.size()<1)
           {
               assert(agglo_LS_cl.user_data.offset_subcells.size()==1);
               auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
               auto cl_old = level_set.msh.cells[offset_old];
               return level_set( pt , level_set.msh , cl_old );
           }

           else
           {
               //std::cout<<"Ls operator"<<std::endl;
               auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
               auto subcl = level_set.msh.cells[offset];
               return level_set( pt , level_set.msh , subcl );
           }

       }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt) const
    {
        if (subcells.size()<1)
            {
                assert(agglo_LS_cl.user_data.offset_subcells.size()==1);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.normal( pt , level_set.msh , cl_old );
            }

            else
            {

                auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.normal( pt , level_set.msh , subcl );
            }
    }

    Eigen::Matrix<T,2,1> gradient(const point<T,2>& pt) const
    {
        if (subcells.size()<1)
            {
                std::cout<<"I m here 2.5 and size is "<<agglo_LS_cl.user_data.offset_subcells.size()<<std::endl;
                assert(agglo_LS_cl.user_data.offset_subcells.size()==1);
                auto offset_old = agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = level_set.msh.cells[offset_old];
                return level_set.gradient( pt , level_set.msh , cl_old );
            }

            else
            {
                std::cout<<"Ls gradient"<<std::endl;
                auto offset = pt_in_subcell(level_set.msh,pt,agglo_LS_cl);
                auto subcl = level_set.msh.cells[offset];
                return level_set.gradient( pt , level_set.msh , subcl );
            }

    }

    void cell_assignment(const cell_type& cl)
    {
        subcells.clear();
        agglo_LS_cl = cl;
        if (agglo_LS_cl.user_data.offset_subcells.size()>1)
        {

            for (auto& offset_subcells:agglo_LS_cl.user_data.offset_subcells)
            {
                subcells.push_back( level_set.msh.cells[offset_subcells] );

            }
        }

    }

    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt , const cell_type& cl)
    {
        agglo_LS_cl = cl;
        return normal( pt );
    }

    T operator()(const point<T,2>& pt,const cell_type& cl )
    {
        agglo_LS_cl = cl;
        return operator()( pt );
    }


  //  void get_cell()
  //  {
  //      auto crr_cl = download_current_cell();
  //      std::cout<<"IN get_cell.. size cell "<<crr_cl.user_data.offset_subcells.size()<<std::endl;
  //      this->cell_assignment(crr_cl);
 //   }

};





/**************MOVING INTERFACE: LEVEL SET METHOD  **************/

template<typename T, typename Mesh >
struct projection
{
    Eigen::Matrix<T, Dynamic, Dynamic> values_bis;
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh

    size_t degree_FEM;
    size_t number_elements;
    Mesh msh;
    size_t      Nx, Ny ;
    mesh_init_params<T> params;
    //size_t  last_row_init, last_row_end, number_faces_one_row;

    projection( const Mesh & msh, size_t degree_k , const mesh_init_params<T>& params)
        : number_elements((degree_k+1)*(degree_k+1)), msh(msh),degree_FEM(degree_k),Nx(params.Nx),Ny(params.Ny), params(params)
    {
        vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( ((Nx+1)*(Ny+1)), 1 );
        values_bis= Eigen::Matrix<T, Dynamic, Dynamic>::Zero(number_elements, msh.cells.size());
    }

    projection()=default;


    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        values_bis=values_new;
    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& vertices )
    {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols() ; j++)
        {

            for (size_t i = 0; i < values_bis.rows() ; i++)
            {
                auto i_vertex = j + floor(j/Nx);
                if ( i == 0 )
                    values_bis(i,j) = vertices(i_vertex);

                if( i ==1 )
                    values_bis(i,j) = vertices(i_vertex+1) ;

                if( i ==(degree_FEM+2) )
                    values_bis(i,j) = vertices(i_vertex+Nx+2) ;

                if( i ==(degree_FEM+1) )
                    values_bis(i,j) = vertices(i_vertex+Nx+1) ;
            }
        }

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values )
    {
        assert(degree_FEM == 1);
        for (size_t j = 0; j < values_bis.cols() ; j++)
        {

            for (size_t i = 0; i < values_bis.rows() ; i++)
            {
                auto i_vertex = j + floor(j/Nx);
                if ( i == 0 )
                    vertices(i_vertex) = values(i,j) ;

                if( i ==1 )
                    vertices(i_vertex+1) = values(i,j) ;

                if( i ==(degree_FEM+2) )
                    vertices(i_vertex+Nx+2) = values(i,j) ;

                if( i ==(degree_FEM+1) )
                    vertices(i_vertex+Nx+1) = values(i,j) ;
            }
        }

    }




    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);
    }

    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl) ;
        cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (values_bis.block(0,counter,number_elements,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;
    }

    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {
        size_t counter = offset(msh,cl);
        Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
        cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = values_bis.col(counter);
        auto grad_eval =  cb.eval_gradients(pt);
        ret(0) = values_cell.dot( grad_eval.col(0) );
        ret(1) = values_cell.dot( grad_eval.col(1) );
        return ret;
    }


    Eigen::Matrix<T,2,1> normal(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
    {
        Eigen::Matrix<T,2,1> ret;
        ret = gradient(pt,msh,cl);
        return ret/ret.norm();

    }

};




template <typename T>
void positive_part( Eigen::Matrix<T, Dynamic, Dynamic>& mat) {
    for (size_t i = 0; i<mat.rows();i++) {
        for (size_t j = 0; j<mat.cols();j++) {
            if( mat(i,j) < 0 )
                mat(i,j) = 0.;
        }
    }

}





/*

template <typename T>
Eigen::Matrix<T, Dynamic, Dynamic> positive_part(const Eigen::Matrix<T, Dynamic, Dynamic>& mat) {
    //Eigen::Matrix<T, Dynamic, Dynamic> ret =mat;
    Eigen::Matrix<T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(mat.rows(), mat.cols());
    auto positive = mat.cwiseSign();
    std::cout<<"positive: "<<'\n'<<positive<<std::endl;
    for (size_t i = 0; i<mat.rows();i++) {
        for (size_t j = 0; j<mat.cols();j++) {
            if (positive(i,j)==-1) {
                ret(i,j) = 0;
            }
            //if( mat(i,j) < 0 )
            //    ret(i,j) = 0;
        }
    }
    return ret;
}
*/


//template <typename T> int sgn(T val) {
//    return (T(0) < val) - (val < T(0));
//}

template<typename T, typename Mesh>
class entropy
{
public:
    virtual T operator()(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
    }

    virtual T derivative(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
    }

};



template<typename Entropy_func , typename Fonction , typename Mesh , typename Vel_Field,  typename T = typename Mesh::coordinate_type >
struct entropy_flux
{
    T eps;
    Fonction phi;
    Mesh msh;
    Vel_Field u ;
    Entropy_func E ;

    Eigen::Matrix<T, Dynamic, 1 > values0 , values1 ;

    entropy_flux(Entropy_func& E_entropy , const Fonction& phi , const Vel_Field& u , const Mesh& msh): E(E_entropy), phi(phi) , u(u) , msh(msh){
        eps = E.eps;
        values0 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
        values1 =  Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
        Eigen::Matrix<T, Dynamic, 1 > One = Matrix<T, Dynamic, 1 >::Ones(phi.ndof_FE , 1 );
        auto ret = E.E_values + std::log10(eps)*One ;
        values0 = u.sol_FEM.first.cwiseProduct(ret);
        values1 = u.sol_FEM.second.cwiseProduct(ret);
    }

    std::pair<T,T> operator()(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
       {
           T ret = E(pt,cl) + std::log10(eps) ;
           return make_pair(u.first(msh,pt,cl)*ret , u.second(msh,pt,cl)*ret );
       }
};

template<typename T , typename Fonction , typename Mesh>
struct non_linear_entropy_new: public entropy<T,Mesh>
{
    T eps;
    Fonction phi;
    T phi_max , phi_min ;
    Mesh msh;
    Eigen::Matrix<T, Dynamic, 1 > E_values , E_der ;

    non_linear_entropy_new(T eps , const Fonction& phi ,const Mesh& msh): eps(eps),phi(phi),msh(msh)
    {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;
        E_values = Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
        Eigen::Matrix<T, Dynamic, 1 > One = Matrix<T, Dynamic, 1 >::Ones(phi.ndof_FE , 1 );
        E_values = -(( ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).cwiseAbs() + eps*One ).array().log10() );

        E_der = Matrix<T, Dynamic, 1 >::Zero(phi.ndof_FE , 1 );
        E_der = ((-One.cwiseQuotient( ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).cwiseAbs() + eps*One ) ) ) ;//.cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )).cwiseProduct( One -2*phi.sol_FEM ) ;
        E_der = (E_der.array().cwiseProduct(  ( (phi.sol_FEM).cwiseProduct( One - phi.sol_FEM ) ).array().sign() )) ;
        E_der = (E_der.cwiseProduct(  One -2*phi.sol_FEM)) ;
        //E_der = -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;

    }

    T operator()(const Fonction& f, const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( f(pt,msh,cl)*(1-f(pt,msh,cl)) ) + eps );
    }

    T operator()(const point<T,2>& pt , const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( phi(pt,msh,cl)*(1-phi(pt,msh,cl)) ) + eps );
    }

    T derivative(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
       // std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;
    }

};




template<typename T , typename Fonction , typename Mesh>
struct non_linear_entropy: public entropy<T,Mesh>
{
    const T eps;
    Fonction phi;
    T phi_max , phi_min ;
    Mesh msh;

    non_linear_entropy(const T eps , const Fonction& phi ,const Mesh& msh): eps(eps),phi(phi),msh(msh)
    {
        phi_max = phi.phi_max;
        phi_min = phi.phi_min;

    }

    /// THIS WAS FOR A GENERAL PHI, RE-WRITTEN FOR PHI BETWEEN 0 AND 1
    /*
    T operator()(const Fonction& f, const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( (phi_max-f(pt,msh,cl))*(f(pt,msh,cl)-phi_min) ) + eps );
    }

    T operator()(const point<T,2>& pt , const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min) ) + eps );
    }

    T derivative(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
       // std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1./(( std::abs( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) ) +eps)*std::log(10)) * sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) ) * ( phi_max - 2*phi(pt,msh,cl) + phi_min ) ;
    }
    */

    T operator()(const Fonction& f, const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( f(pt,msh,cl)*(1-f(pt,msh,cl)) ) + eps );
    }

    T operator()(const point<T,2>& pt , const typename Mesh::cell_type& cl) const
    {
        return -std::log10( std::abs( phi(pt,msh,cl)*(1-phi(pt,msh,cl)) ) + eps );
    }

    T derivative(const point<T,2>& pt, const typename Mesh::cell_type& cl) const
    {
       // std::cout<<"il segno di "<<((phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ))<<" is "<< sgn( (phi_max-phi(pt,msh,cl))*(phi(pt,msh,cl)-phi_min ) )<<std::endl;
        return -1./( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;
    }

};




template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix<T, Dynamic, Dynamic>
make_lagrange_local_mass_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 0)
{

    //auto f_neigh = cl.user_data.f_neighbors;
    //auto d_neigh = cl.user_data.d_neighbors;

    cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    //Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi * phi.transpose();
        // phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar
    }
    //ret2  =  ret.rowwise().sum(); // sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3

    return ret;
}

template<typename Mesh, typename T = typename Mesh::coordinate_type>
Matrix<T, Dynamic, Dynamic>
make_lagrange_lumped_mass_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 0)
{
    cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs, 1);

    auto qps = integrate(msh, cl, 2*(degree+di));

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);
        ret += qp.second * phi;
    }

    return ret;
}

template<typename Mesh, typename T = typename Mesh::coordinate_type>
std::pair< Matrix<T, Dynamic, Dynamic> , Matrix<T, Dynamic, Dynamic> >
make_local_cij_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 0)
{
    cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree);
    auto cbs = cb.size();

    Matrix<T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);
    Matrix<T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);

    // for Q1 , degree = 1-> integration of order 2
    auto qps = integrate(msh, cl, 2*(degree+di)); // integration of order 2k

    for (auto& qp : qps)
    {
        auto phi = cb.eval_basis(qp.first);

        auto phi_grad = cb.eval_gradients(qp.first);

        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();

        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();
    }

    return std::make_pair(ret0,ret1);
}





template < typename VECTOR, typename Mesh, typename MATRIX , typename T = typename Mesh::coordinate_type >
Matrix<T, Dynamic, 1>  make_dij_vector(const Mesh & msh, const MATRIX& dij, const VECTOR& phi_old )
{
    Matrix<T, Dynamic, 1> ret = Eigen::Matrix<T, Dynamic, 1>::Zero(dij.rows(), 1);


    for(size_t i = 0 ; i<dij.rows() ; i++ )
    {
        auto tmp = (dij.row(i)).adjoint();
        ret(i) = tmp.dot( phi_old ) - tmp(i)*( phi_old(i) );
    }
    return ret;
}

template < typename VECTOR, typename T >
Matrix<T, Dynamic, 1> solveFEM( const VECTOR& lumped_mass , const VECTOR& conv , const VECTOR& last_term, const VECTOR& phi_old , T dt , const std::vector<size_t>& bdry_nodes)
{
    /*
    Matrix<T, Dynamic, 1> sol =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    size_t j = 0;
    for (size_t i = 0 ; i < phi_old.rows() ; i++ ) {
        if( i == bdry_nodes.at(j) ){
            sol(i) = phi_old(i);
            j++; // I can do since bdry_nodes is ordered
        }
        else
           sol(i) = phi_old(i) - dt * conv(i)/( lumped_mass(i) ) + dt * last_term(i)/( lumped_mass(i) );
    }
    return sol;
    */
    // if I dont consider boundary condition here, but just solve for all


    return phi_old - dt * conv.cwiseQuotient(lumped_mass) + dt * last_term.cwiseQuotient(lumped_mass);

}






template < typename Fonction, typename VECTOR, typename MATRIX , typename T >
Matrix<T, Dynamic, 1> solveFEM_Entropic( const MATRIX& mass,const VECTOR& conv, const VECTOR& last_term, const Fonction& phi_old , T dt )
{
    // if I dont consider boundary condition here, but just solve for all-> look to solveFEM
    auto b = phi_old - dt * conv + dt * last_term;

    return mass.completeOrthogonalDecomposition().solve(b);


}

template < typename Fonction, typename VECTOR, typename MATRIX , typename T >
Matrix<T, Dynamic, 1> solveFEM_Entropic_FAST( const MATRIX& llt,const VECTOR& conv, const VECTOR& last_term, const Fonction& phi_old , T dt )
{
    // if I dont consider boundary condition here, but just solve for all-> look to solveFEM
    auto b = phi_old - dt * conv + dt * last_term;

    return llt.solve(b);


}



/*

std::vector< size_t > find_neighbors(  const typename Mesh::node_type& node )
{
    size_t row = floor( node/(M+1) ) ;
    size_t col = n % (M+1) ;

    size_t central_cell = col + row*M ;

}
*/



template<typename T , typename Mesh >
class Finite_Element
{
public:
    Mesh msh; // Original mesh, not agglomerated
    // number of degree of freedom (HHO setting) , #vertices , #cells
    size_t ndof_disc , n_vertices , n_cls  ;
    size_t ndof_FE ; // number of degree of freedom (Continuous FEM setting)
    size_t num_faces = 4 ; // #faces
    mesh_init_params<T> params; // parameters mesh
    size_t order; // FE order of polynomial B^k
    size_t local_ndof ; // local degree of freedom


    size_t Nx , Ny ; // number of cells in x and y direction
    T hx; // step size along x direction
    T hy; // step size along y direction

    std::vector<std::set<size_t>> S_i;
    typedef typename Mesh::point_type point_type ;
    typedef typename Mesh::cell_type cell_type ;
    std::vector< std::pair< std::pair<point_type,cell_type> , std::map<size_t,  std::pair<point_type,cell_type>> > > S_pt_cell;


    //std::map<size_t , std::pair<typename Mesh::point_type , typename Mesh::cell_type > >>
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;

    std::vector< bool > Dirichlet_boundary; //(ndof_FE , FALSE );
    std::vector< bool > Dirichlet_boundary_inlet; //(ndof_FE , FALSE );

    Finite_Element( Mesh & msh , size_t order , const mesh_init_params<T>& params ): msh(msh) , n_vertices(msh.nodes.size()) , n_cls(msh.cells.size()) ,  order(order) , local_ndof((order+1)*(order+1)), hx(params.hx() ) , hy(params.hy() ) , connectivity_matrix( n_cls , std::vector<std::pair<size_t,bool>>(local_ndof) ) , Nx(params.Nx),Ny(params.Ny) , params(params)
    {
        ndof_disc =  n_vertices*n_cls ;

        //std::cout<<"n_vertices "<<n_vertices<<" , n_cls "<<n_cls<<" , ndof_disc "<<ndof_disc<<std::endl;
        if(order == 0)
           ndof_FE = msh.cells.size();

        size_t counter = 0 , i_global = 0 ;
        for(const auto& cl : msh.cells)
        {

            if(order == 0)
            {
                ndof_FE = msh.cells.size();
                connectivity_matrix[counter][0].first = counter;
                connectivity_matrix[counter][0].second = false;

            }
            else
            {



            std::vector<size_t> loc_bdry_nodes;
            auto fcs = faces(msh,cl);
            for(size_t face_i = 0; face_i < num_faces; face_i++)
            {
                auto fc = fcs[face_i];
                //std::cout<<"fc is "<<fc<<std::endl;
                // In HHO flow problem I can have different types of boundary;
                // For level set evolution, I just focus on Dirichelet boundary
                // The indication of the type of boundary in fc is relative to HHO problem, so useless now
                if( fc.is_boundary )
                {
                    if(face_i == 0){
                        loc_bdry_nodes.push_back(0);
                        loc_bdry_nodes.push_back(1);

                        if(order > 1){
                            for(size_t j = 0 ; j <= order - 2 ; j++)
                                loc_bdry_nodes.push_back(4+j);
                        }

                    }
                    else if(face_i == 1){
                        loc_bdry_nodes.push_back(1);
                        loc_bdry_nodes.push_back(2);
                        if(order > 1){
                        for(size_t j = 0 ; j <= order - 2 ; j++)
                            loc_bdry_nodes.push_back(order+3+j);
                        }
                    }
                    else if(face_i == 2){
                        loc_bdry_nodes.push_back(2);
                        loc_bdry_nodes.push_back(3);
                        if(order > 1){
                        for(size_t j = 0 ; j <= order - 2 ; j++)
                            loc_bdry_nodes.push_back(2*order+2+j);
                        }
                    }
                    else if(face_i == 3){
                        loc_bdry_nodes.push_back(0);
                        loc_bdry_nodes.push_back(3);
                        if(order > 1){
                        for(size_t j = 0 ; j <= order - 2 ; j++)
                            loc_bdry_nodes.push_back(3*order+1+j);
                        }

                    }
                    else
                        exit(1);

                }

            }

            size_t offset_curr = offset(msh,cl);
            sort(loc_bdry_nodes.begin(), loc_bdry_nodes.end());
            loc_bdry_nodes.erase( unique( loc_bdry_nodes.begin(), loc_bdry_nodes.end() ), loc_bdry_nodes.end() );





            //std::cout<<"loc_bdry_nodes "<<std::endl;
            //for(auto i : loc_bdry_nodes)
            //    std::cout<<i<<" , ";
            //std::cout<<std::endl;

            for( size_t i_local = 0 ; i_local < local_ndof ; i_local++)
            {
                // if boundary = TRUE is node on the boudnary , else not
                bool boundary =  binary_search(loc_bdry_nodes.begin(), loc_bdry_nodes.end(), i_local) ;

                // Case: first cell
                if( offset_curr == 0 ){
                connectivity_matrix[counter][i_local].first = i_global;
                connectivity_matrix[counter][i_local].second = boundary;
                i_global++;
                }

                // Case: First row of cells, a part of cell[0]
                // Left face enumeration for cell i = Right face enumeration for cell i-1
                else if( offset_curr > 0 && offset_curr < Nx )
                {
                    if( i_local == 0  ){ // vertex 1 of cell[counter-1] = vertex 0 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-1][1].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if(  i_local == 3  ){ // vertex 2 of cell[counter-1] = vertex 3 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-1][2].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if(  i_local >= 3*order + 1 && i_local <= 4*order - 1   ) // nodes in face 3
                    {
                        // how many points i_local is distant from v3 vertices
                        // Idea is f1 of cell[counter-1] = f2 of cell[counter] (i.e. = means same ordering). It means:
                        //    face 1             face 3
                        // 2*ordering + 1 ---- 3*ordering + 1
                        //    |                      |
                        //    |                      |
                        //    |                      |
                        //  ordering + 3  ---- 4*ordering - 1

                        size_t dist_v3 = i_local - (3*order + 1) ;
                        size_t j = 2*order + 1 - dist_v3 ;
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-1][j].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else
                    {
                        connectivity_matrix[counter][i_local].first = i_global;
                        connectivity_matrix[counter][i_local].second = boundary;
                        i_global++;
                    }

                }

                // Case: Left Boundary cells
                // Bottom face enumeration for cell i = Top face enumeration for cell i-Nx
                else if( offset_curr % Nx == 0 && offset_curr > 0 )
                {
                    if( i_local == 0  ){ // vertex 3 of cell[counter-Nx] = vertex 0 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-Nx][3].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if(  i_local == 1   ){ // vertex 2 of cell[counter-Nx]=vertex 1 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-Nx][2].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if( i_local >= 4 && i_local <= order + 2  ) // nodes in face 0
                    {
                        // how many points i_local is distant from v0 vertices
                        // Idea is f2 of cell[counter-Nx] = f0 of cell[counter] (i.e. = means same ordering). It means:
                        //         face 0 ; cell[counter]
                        //     4        ----     ordering + 2
                        //     |                      |
                        //         face 2 ; cell[counter-Nx]
                        //     |                      |
                        //  3*ordering  ----    2*ordering +2

                        size_t dist_v0 = i_local - 4 ;
                        size_t j = 3*order - dist_v0 ;
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-Nx][j].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }

                    else
                    {
                        connectivity_matrix[counter][i_local].first = i_global;
                        connectivity_matrix[counter][i_local].second = boundary;
                        i_global++;
                    }
                }

                // All the other cells ( i.e. internal and right boundary cells ) are both 2 the cases
                else
                {
                    if( i_local == 0  ){ // vertex 1 of cell[counter-1] = vertex 0 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-1][1].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if(  i_local == 3  ){ // vertex 2 of cell[counter-1] = vertex 3 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-1][2].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if(  i_local == 1   ){ // vertex 2 of cell[counter-Nx]=vertex 1 of cell[counter]
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-Nx][2].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if(  i_local >= 3*order + 1 && i_local <= 4*order - 1   ) // nodes in face 3
                    {
                        size_t dist_v3 = i_local - (3*order + 1) ;
                        size_t j = 2*order + 1 - dist_v3 ;
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-1][j].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else if( i_local >= 4 && i_local <= order + 2  ) // nodes in face 0
                    {
                        size_t dist_v0 = i_local - 4 ;
                        size_t j = 3*order - dist_v0 ;
                        connectivity_matrix[counter][i_local].first = connectivity_matrix[counter-Nx][j].first ;
                        connectivity_matrix[counter][i_local].second = boundary;
                    }
                    else
                    {
                        connectivity_matrix[counter][i_local].first = i_global;
                        connectivity_matrix[counter][i_local].second = boundary;
                        i_global++;
                    }
                }

            } // End of local loop for each cell
            }
        counter++;

        } // End of loop over the cells.


        if(order == 0)
            ndof_FE = msh.cells.size();
        else
            ndof_FE = i_global ;

        S_i.resize(ndof_FE);
        Dirichlet_boundary.resize(ndof_FE);
        Dirichlet_boundary_inlet.resize(ndof_FE);

        S_pt_cell.resize(ndof_FE) ;

        for(auto&cl : msh.cells)
        {
            auto offset_cl = offset(msh,cl);
            auto qps = equidistriduted_nodes_ordered_bis<T>(msh, cl, order);
            for (size_t i = 0; i < local_ndof; i++)
            {
                auto asm_map_i = connectivity_matrix[offset_cl][i].first;
                S_pt_cell[asm_map_i].first = std::make_pair(qps[i],cl) ;
                for (size_t j = 0; j < local_ndof; j++)
                {
                    auto asm_map_j = connectivity_matrix[offset_cl][j].first;
                    S_i[asm_map_i].insert( asm_map_j );

                    S_pt_cell[asm_map_i].second.insert( std::make_pair(asm_map_j , std::make_pair(qps[j], cl) ) ) ;
                    //( std::make_pair(qps(i),cl) , std::make_pair(qps(j),cl) ) ;

                }
            }
        }


       /*
        size_t size_supp_nodes = 0;
        std::cout<<"Supporting nodes IN FE METHOD:"<<std::endl;
        size_t jjjj = 0;
        for (auto& i: S_i) {
            size_supp_nodes+=i.size();
            std::cout <<"Node "<<jjjj<<":";
            for (auto it=i.begin(); it != i.end(); ++it)
                std::cout << ' ' << *it;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
        std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;


        jjjj = 0;
        for (auto& i: S_pt_cell) {

            std::cout <<"Node "<<jjjj<<" = ( "<<S_pt_cell[jjjj].first.first<<" , "<< offset(msh,S_pt_cell[jjjj].first.second)<<" ) "<<std::endl;
            for (auto it=i.second.begin(); it != i.second.end(); ++it)
                std::cout << '\t'<<" j = "<< it->first << " -> ( " << it->second.first<<" , "<< offset(msh, it->second.second)<<" ) "<<std::endl;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
         */
//        std::cout<<"Beginning of connectivity matrix"<<std::endl;



        // Dirichlet boundary vector
        for(size_t i = 0 ; i< n_cls ; i++)
        {
            for(size_t j = 0 ; j< local_ndof ; j++)
            {
//                std::cout<<"( "<<connectivity_matrix[i][j].first<<" , "<<connectivity_matrix[i][j].second<<" ) , ";
                auto asmap = connectivity_matrix[i][j] ;
                Dirichlet_boundary[asmap.first] = asmap.second ;
                //std::cout<<"Node "<<asmap.first << " is Dirichlet "<<asmap.second<< "  ,  ";
            }
//            std::cout<<std::endl;
        }
//        std::cout<<std::endl;
//        std::cout<<"End of connectivity matrix"<<std::endl;






    }


    //void
    //assembling(SparseMatrix<T>& Global_Mass ,SparseMatrix<T>& Global_c_term_x ,SparseMatrix<T>& Global_c_term_y, DiagonalMatrix<T, Dynamic>& Global_Mass_Lumped , Matrix<T, Dynamic, 1>& RHS){


   // }

    /*
    size_t get_order() const { return order; }
    size_t get_n_nodes() const { return n_nodes; }
    size_t get_n_cells() const { return n_cls; }
    size_t get_hx() const { return hx; }
    size_t get_hy() const { return hy; }
    size_t get_Nx() const { return Nx; }
    size_t get_Ny() const { return Ny; }
    size_t get_local_ndof() const { return local_ndof; }
    size_t get_ndof() const { return ndof; }
    */
};




template< typename VECTOR_LOC , typename VECTOR_GLOB , typename NODES>
void global_update_vector( const VECTOR_LOC& local , VECTOR_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;
   // std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for(auto & k : nodes_position)
    {
        size_t kk = k.ptid;
        //std::cout<<"riga "<<kk<<std::endl;
        // std::cout<<"i "<<i<<std::endl;
        global( kk ) += local ( i ) ;
        i++;
    }

}


template< typename VECTOR_LOC , typename VECTOR_GLOB , typename NODES>
void global_update_vector_NOSUM( const VECTOR_LOC& local , VECTOR_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;
   // std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for(auto & k : nodes_position)
    {
        size_t kk = k.ptid;
        //std::cout<<"riga "<<kk<<std::endl;
        // std::cout<<"i "<<i<<std::endl;
        global( kk ) = local ( i ) ;
        i++;
    }

}


template< typename VECTOR_LOC , typename VECTOR_GLOB , typename NODES>
void global_update_vector_MAX( const VECTOR_LOC& local , VECTOR_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;
   // std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for(auto & k : nodes_position)
    {
        size_t kk = k.ptid;
        //std::cout<<"riga "<<kk<<std::endl;
        // std::cout<<"i "<<i<<std::endl;
        auto max_glob = global( kk );
        global( kk ) = std::max( local ( i ) , max_glob ) ;
        i++;
    }

}

template< typename VECTOR_LOC , typename VECTOR_GLOB , typename NODES>
void global_update_vector_MIN( const VECTOR_LOC& local , VECTOR_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;
   // std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for(auto & k : nodes_position)
    {
        size_t kk = k.ptid;
        //std::cout<<"riga "<<kk<<std::endl;
        // std::cout<<"i "<<i<<std::endl;
        auto min_glob = global( kk );
        global( kk ) = std::min( local ( i ) , min_glob ) ;
        i++;
    }

}




template< typename MATRIX_LOC , typename MATRIX_GLOB , typename NODES>
void global_update_NOSUM( const MATRIX_LOC& local , MATRIX_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;
   // std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for(auto & k : nodes_position)
    {
        size_t j = 0;
        size_t kk = k.ptid;
        //std::cout<<"riga "<<kk<<std::endl;
       // std::cout<<"i "<<i<<std::endl;

        for(auto & l : nodes_position)
        {
            size_t ll = l.ptid;

            //std::cout<<"colonna "<<ll<<std::endl;
            //std::cout<<"j "<<j<<std::endl;
            global( kk  , ll  ) = local ( i , j ) ;
            j++;
        }
        i++;

    }

}



template< typename MATRIX_LOC , typename MATRIX_GLOB , typename NODES>
void global_update( const MATRIX_LOC& local , MATRIX_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;
   // std::cout<<"numero nodi "<<nodes_position.size()<<std::endl;
    for(auto & k : nodes_position)
    {
        size_t j = 0;
        size_t kk = k.ptid;
        //std::cout<<"riga "<<kk<<std::endl;
       // std::cout<<"i "<<i<<std::endl;

        for(auto & l : nodes_position)
        {
            size_t ll = l.ptid;

            //std::cout<<"colonna "<<ll<<std::endl;
            //std::cout<<"j "<<j<<std::endl;
            global( kk  , ll  ) += local ( i , j ) ;
            j++;
        }
        i++;

    }

}



/*

// OLD IMPLEMENTATION
template< typename MATRIX_LOC , typename MATRIX_GLOB , typename NODES>
void global_update2( const MATRIX_LOC& local , MATRIX_GLOB& global , const NODES& nodes_position )
{
    size_t i = 0 ;

   std::cout<<"LOCAL "<<std::endl;
   std::cout<<local<<std::endl;


    for(auto & k : nodes_position)
    {
        size_t j = 0;
        //size_t kk = k.ptid;
        std::cout<<"riga "<<k<<std::endl;
        std::cout<<"i "<<i<<std::endl;

        for(auto & l : nodes_position)
        {
            //size_t ll = l.ptid;

            std::cout<<"colonna "<<l<<std::endl;
            std::cout<<"j "<<j<<std::endl;

            global( k  , l  ) += local ( i , j ) ;
            j++;
        }
        i++;

    }
    std::cout<<"GLOBAL "<<std::endl;
    std::cout<<global<<std::endl;

}
*/



std::vector<size_t> boundary_nodes_function( size_t Nx , size_t Ny )
{
    // IT WORKS ONLY FOR Q1!!!
    std::vector<size_t> bdry_nodes ;
    for (size_t j = 1 ; j<=Ny ; j++) {
        bdry_nodes.push_back( j*(Nx+1) -1 ) ;
        bdry_nodes.push_back( j*(Nx+1) ) ;
    }
    for( size_t j = 1 ; j< Nx ; j++){
        bdry_nodes.push_back( j ) ;
        bdry_nodes.push_back( Ny*(Nx+1)+j ) ;
    }
    bdry_nodes.push_back( 0 ) ;
    bdry_nodes.push_back( (Ny+1)*(Nx+1)-1 ) ;
    std::sort(bdry_nodes.begin(), bdry_nodes.end() );

    return bdry_nodes;
}


template<typename Node , typename SUPP_NODES>
void supporting_nodes( SUPP_NODES& ret ,  const Node& nodes_position )
{

    for( auto & i : nodes_position)
    {
        for( auto & j : nodes_position)
        {
            (ret.at(i.ptid)).insert(j.ptid);
         //    std::cout<<"ret("<<i.ptid<<") is "<<j<<std::endl;
        }
         //std::sort(ret(i.ptid).begin(), ret(i.ptid).end() ); // set already increasing ordered
    }

}


template<typename Node , typename MATRIX >
void division_Si( const Node& S_i , const MATRIX& mat1 , const MATRIX& mat2 , MATRIX& sol )
{
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter,elem) = mat1(counter,elem)/mat2(counter,elem);
        }
        counter++;
    }
}

template<typename Node , typename MATRIX >
void division_Si_T( const Node& S_i , const MATRIX& mat1 , const MATRIX& mat2 , MATRIX& sol )
{
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(elem,counter) = mat1(elem,counter)/mat2(elem,counter);
        }
        counter++;
    }
}

template<typename Node , typename MATRIX >
void moltiplication_Si_T( const Node& S_i , const MATRIX& mat1 , const MATRIX& mat2 , MATRIX& sol )
{
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(elem,counter) += ( mat1(elem,counter) *mat2(elem,counter) );
        }
        counter++;
    }
}


template<typename Node , typename MATRIX >
void moltiplication_Si( const Node& S_i , const MATRIX& mat1 , const MATRIX& mat2 , MATRIX& sol )
{
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter,elem) += ( mat1(counter,elem)*mat2(counter,elem) );
        }
        counter++;
    }
}

template<typename Node , typename MATRIX , typename VECTOR>
void sum_Si( const Node& S_i , const MATRIX& mat , const VECTOR& vec , VECTOR& sol )
{
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter) += mat(counter,elem)*vec(elem);
        }
        counter++;
    }
}

template<typename Node , typename MATRIX , typename VECTOR>
void averaged_sum_Si( const Node& S_i , const MATRIX& mat , const VECTOR& vec , VECTOR& sol )
{
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter) += mat(counter,elem)*(vec(elem)-vec(counter));
        }
        counter++;
    }
}


/*
template < typename VECTOR, typename MATRIX , typename T , typename POS >
void checking_phi_l( const VECTOR& lumped_mass, const MATRIX& cij_x , const MATRIX& cij_y , const MATRIX& d_ij, const VECTOR& phi_old , const VECTOR& phi_l , T dt , const POS& S_i )
{


    VECTOR K_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    VECTOR Dl_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(lumped_mass.rows(), 1);
    // SBAGLIATO NON è PHI_OLD MA IL FLUSSO CHE SERVE QUI DENTRO!
    averaged_sum_Si( S_i , cij_x , phi_old , K_term );
    averaged_sum_Si( S_i , cij_y , phi_old , K_term );
    sum_Si( S_i , d_ij , phi_old , Dl_term );
    //std::cout<<'\n'<<"check Dij "<<'\n'<<Dl_term-d_ij*phi_old<<std::endl;
    VECTOR tmp =  lumped_mass.cwiseProduct( (phi_l - phi_old)/dt ) + K_term - Dl_term;
    std::cout<<'\n'<<"check phi_l vec is "<<'\n'<<tmp<<std::endl;
}
*/
template < typename VECTOR , typename T  >
void checking_phi_lBIS( const VECTOR& lumped_mass, const VECTOR& cij_term , const VECTOR& dij_term, const VECTOR& phi_old , const VECTOR& phi_l , T dt )
{

    VECTOR tmp =  lumped_mass.cwiseProduct( (phi_l - phi_old)/dt ) + cij_term - dij_term;
    std::cout<<'\n'<<"CHECK BIS phi_l vec is "<<'\n'<<tmp<<std::endl;
}


/*
template < typename VECTOR , typename MATRIX , typename T , typename POS >
void checking_phi_h( const MATRIX& mass, const MATRIX& cij_x , const MATRIX& cij_y , const MATRIX& dC_ij , const VECTOR& phi_old , const VECTOR& phi_h , T dt , const POS& S_i)
{

    VECTOR K_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Dc_term =  Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    // SBAGLIATO NON è PHI_OLD MA IL FLUSSO CHE SERVE QUI DENTRO!
    averaged_sum_Si( S_i , cij_x , phi_old , K_term );
    averaged_sum_Si( S_i , cij_y , phi_old , K_term );
    sum_Si( S_i , dC_ij , phi_old , Dc_term );
    VECTOR tmp =  mass*( (phi_h - phi_old)/dt ) + K_term  - dC_ij*phi_old;
   // std::cout<<'\n'<<"check DCij "<<'\n'<<Dc_term-dC_ij*phi_old<<std::endl;
    std::cout<<'\n'<<"check phi_h vec is "<<'\n'<<tmp<<std::endl;
}
*/
template < typename VECTOR , typename T , typename MATRIX  >
void checking_phi_hBIS( const MATRIX& mass, const VECTOR& cij_term , const VECTOR& dij_term, const VECTOR& phi_old , const VECTOR& phi_h , T dt )
{

    VECTOR tmp =  mass*( (phi_h - phi_old)/dt ) + cij_term - dij_term;
    std::cout<<'\n'<<"CHECK BIS phi_H vec is "<<'\n'<<tmp<<std::endl;
}




template < typename Entropy , typename Fonction, typename Fonction_TILDE , typename Mesh, typename Vel_Field , typename T , typename POSITION , typename VECTOR >
  void r_i_calculator(const Mesh& msh, const typename Mesh::cell_type& cl , const Entropy& E , const Fonction_TILDE& phi_tilde , const Fonction& phi , T dt , const Vel_Field& u , const POSITION& S_i , VECTOR& Emax_global , VECTOR& Emin_global , VECTOR& R_i  )
{
    size_t di = 0;
    cell_basis_Lagrangian<Mesh,T> cb(msh, cl, phi.degree_FEM);
    auto cbs = cb.size();
    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
    auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));


    auto nds = nodes(msh,cl);
    iter_swap(nds.end()-1 , nds.end()-2 );

    auto pts = points(msh,cl);
    iter_swap(pts.end()-1 , pts.end()-2 );



    size_t counter = 0;
    /// FARE FUNZIONE max_min_entropy PER RENDERE IL CODICE PULITO
    Eigen::Matrix<T, Dynamic, 1> Emax =  Eigen::Matrix<T, Dynamic, 1>::Ones(pts.size(), 1);
    Eigen::Matrix<T, Dynamic, 1> Emin =  Eigen::Matrix<T, Dynamic, 1>::Ones(pts.size(), 1);
    for(auto& nd : nds )
    {
        auto i = nd.ptid ;
        T max_loc = -1e20;
        T min_loc = 1e20;
        for(auto& pt_j : pts )
        {
            Emax(counter) = std::max ( E(pt_j , cl) , max_loc );
            Emin(counter) = std::min ( E(pt_j , cl) , min_loc );
            max_loc = std::max ( Emax(counter) , max_loc );
            min_loc = std::min ( Emin(counter) , min_loc );
        }

        counter++;
    }
    global_update_vector_MAX( Emax , Emax_global , nds );
    global_update_vector_MIN( Emin , Emin_global , nds );
    // std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //  std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;

    for (auto& qp : qps)
    {
        auto bi = cb.eval_basis(qp.first);
        auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
        auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

        auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first*phi_grad0 + u(qp.first,msh,cl).second*phi_grad1 ) *
                  E.derivative(qp.first,cl) ); //.cwiseQuotient( Emax - Emin ) ;
        ret += qp.second * bi * f;
    }
    global_update_vector( ret , R_i , nds );

}



template < typename T , typename MATRIX , typename VECTOR ,typename POSITION >
VECTOR alfaf_ij_creator( const VECTOR& lumped_mass , const MATRIX& mass , const VECTOR& delta_phi , const VECTOR& phi_L , T dt , const MATRIX& D_ij , const MATRIX& Dc_ij , const VECTOR& phi_old , const POSITION& S_i)
{

    MATRIX new_mass = - mass;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
    }

    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);

    MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );
    MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );

    VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero( mass.rows(), 1 );

    VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

    VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR phi_max = phi_old;
    VECTOR phi_min = phi_old;


    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            phi_max(counter) = std::max(phi_old(elem),phi_max(counter));
            phi_min(counter) = std::min(phi_old(elem),phi_min(counter));
        }
        counter++;
    }

    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            f_ij(i, j) = new_mass(i,j)*(delta_phi(j)-delta_phi(i)) +dt*new_D(i,j)*(phi_old(j)-phi_old(i)) ;
            T f_tmp = f_ij(i, j);
            P_plus(i) += std::max( 0. , f_tmp );
            P_minus(i) += std::min( 0. , f_tmp );
        }
        Q_plus(i) = lumped_mass(i)*(phi_max(i)-phi_L(i));
        Q_minus(i) = lumped_mass(i)*(phi_min(i)-phi_L(i));
        if( std::abs(P_plus(i)) > 1e-20 ){
            T Q_P_plus = Q_plus(i)/P_plus(i);
            R_plus(i) = std::min( 1. , Q_P_plus );
        }
        if( std::abs(P_minus(i)) > 1e-20 ){
            T Q_P_minus = Q_minus(i)/P_minus(i);
            R_minus(i) = std::min( 1. , Q_P_minus );
        }
    }

    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            if( f_ij(i, j) > 0 )
                alpha_ij(i,j) = std::min( R_plus(i) , R_minus(j) );
            else
                alpha_ij(i,j) = std::min( R_plus(j) , R_minus(i) );
        }

    }

    size_t counter2 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret(counter2) += ( alpha_ij(counter2,elem)*f_ij(counter2,elem) );
        }
        counter2++;
    }


    // CHECKING F and Alpha properties
    /*
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij(i,j)+f_ij(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */

    /*
    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij(i,j)-alpha_ij(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */

    /*
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij(counter3,elem)+f_ij(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij(counter3,elem)-alpha_ij(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */
    //  CHECKING F_IJ
    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    averaged_sum_Si( S_i , new_mass , delta_phi , ret0 );
    averaged_sum_Si( S_i , new_D , phi_old , ret1 );
    VECTOR f_i = (ret0 + dt*ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    sum_Si( S_i , f_ij , One_Vec , f_i_NEW );

    //std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;

    return  ret ;

}




template < typename T , typename MATRIX , typename VECTOR ,typename POSITION >
VECTOR f_ij_creator( const VECTOR& lumped_mass , const MATRIX& mass , const VECTOR& delta_phi , T dt , const MATRIX& D_ij , const MATRIX& Dc_ij , const VECTOR& phi_old , const POSITION& S_i)
{

    MATRIX new_mass = - mass;
    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
    }

    /*
    std::cout<<"new_mass sum check: "<<std::endl;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
        std::cout<<(new_mass.row(i)).sum()<<std::endl;
    }
    std::cout<<"new_D check: "<<std::endl;
    for(size_t i = 0 ; i < new_D.rows() ; i++){
       std::cout<<(new_D.row(i).sum() )<<std::endl;
    }
    */

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    averaged_sum_Si( S_i , new_mass , delta_phi , ret0 );
    averaged_sum_Si( S_i , new_D , phi_old , ret1 );
    /*
    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            sol(counter) += mat(counter,elem)*(vec(elem)-vec(counter));
        }
        counter++;
    }
    */
    //  std::cout<<'\n'<<"dt: "<<'\n'<<dt<<std::endl;

    //    std::cout<<'\n'<<"ret0: "<<'\n'<<ret0<<std::endl;
    //    std::cout<<'\n'<<"ret1: "<<'\n'<<dt*ret1<<std::endl;

    return (ret0 + dt*ret1) ;

}
template<typename FUNCTION, typename T>
void mapping_phi(FUNCTION& phi , T phi_max , T phi_min)
{
    Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones( phi.vertices.rows(), 1 );
    Matrix<T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones( phi.values_bis.rows(), phi.values_bis.cols() );
    // mapping between 0 and 1
    phi.vertices = (phi.vertices-phi_min*Vec_One)/( phi_max - phi_min );
    phi.values_bis = (phi.values_bis-phi_min*Mat_One)/( phi_max - phi_min );
}

template<typename FUNCTION, typename T>
void inverse_mapping_phi(FUNCTION& phi, T phi_max , T phi_min)
{
    Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones( phi.vertices.rows() , 1 );
    Matrix<T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones( phi.values_bis.rows(), phi.values_bis.cols() );
    phi.vertices = phi_min*Vec_One + phi.vertices*( phi_max - phi_min );
    phi.values_bis = phi_min*Mat_One + phi.values_bis*( phi_max - phi_min );
}



template<typename T, typename Mesh , typename FiniteSpace>
struct L2_projection
{
    SparseMatrix<T>                 Global_Mass; // Global mass, saved for FEM problem
    Matrix<T, Dynamic, 1>           RHS;    // Known term
    std::vector< Triplet<T> >       triplets; // Position elements: Sparse Matrix Notation

    Eigen::Matrix<T, Dynamic, Dynamic> sol_HHO ; // projection saved in HHO format: cell by cell
    Matrix<T, Dynamic, 1> sol_FEM ; // projection saved in Continuos FE format: global nodes
    Eigen::Matrix<T, Dynamic, 1> vertices; // saving level_set on vertices mesh


    size_t number_elements;

    size_t n_cls ; // #cells
    size_t local_dim; // Local Dimension (degree_FEM+1)*(degree_FEM+1)
    size_t n_vertices ; // #vertices

    size_t degree_FEM;
    Mesh msh;
    size_t      Nx, Ny ;
    mesh_init_params<T> params;

    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix ;

    size_t dim_HHO; // Global dimension Discontinuous framework = Local dimension * #cells
    size_t ndof_FE; // Global dimension FE continuous = #nodes


    L2_projection(const FiniteSpace& fe_data ,  const Mesh & msh)
           : degree_FEM(fe_data.order) , local_dim(fe_data.local_ndof), msh(msh), Nx(fe_data.Nx),Ny(fe_data.Ny), params(fe_data.params) , dim_HHO(fe_data.ndof_disc) , n_cls(fe_data.n_cls) ,n_vertices(fe_data.n_vertices) , connectivity_matrix(fe_data.connectivity_matrix) , ndof_FE(fe_data.ndof_FE)
       {
           sol_HHO = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( local_dim, n_cls );
           sol_FEM = Matrix<T, Dynamic, 1>::Zero(ndof_FE);
           vertices = Eigen::Matrix<T, Dynamic, 1>::Zero( n_vertices , 1 );
       }


    L2_projection()=default;


    void  set_discrete_points( Eigen::Matrix<T, Dynamic, Dynamic>& values_new)
    {
        std::cout<<"L2 projection for phi_tilde post-resolution."<<std::endl;
        sol_HHO = values_new;
    }


    void converting_into_HHO_formulation( const Eigen::Matrix<T, Dynamic, 1>& values_new )
    {
        std::cout<<"L2 projection for phi_tilde post-resolution."<<std::endl;
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_HHO(i,counter_bis) = values_new( asm_map );
            }
            size_t i_vertex = counter_bis+floor(counter_bis/Nx);
            vertices(i_vertex) = sol_HHO(0,counter_bis) ;
            vertices(i_vertex+1) = sol_HHO(1,counter_bis) ;
            vertices(i_vertex+Nx+2) = sol_HHO(2,counter_bis) ;
            vertices(i_vertex+Nx+1) = sol_HHO(3,counter_bis) ;
        }

    }

    void converting_into_FE_formulation( const Eigen::Matrix<T, Dynamic, Dynamic>& values_new )
    {
        std::cout<<"L2 projection for phi_tilde post-resolution."<<std::endl;
        for(size_t counter_bis = 0 ; counter_bis < n_cls ;counter_bis++)
        {
            for (size_t i = 0; i < local_dim; i++){
                size_t asm_map =  connectivity_matrix[counter_bis][i].first ;
                sol_FEM( asm_map ) = values_new(i,counter_bis) ;
            }
        }


    }



    T operator()( const typename Mesh::node_type& node ) const
    {
        return vertices(node.ptid);
    }

    T operator()( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
    {

        size_t counter = offset(msh,cl) ;
        cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
        //cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
        auto values_cell = (sol_HHO.block(0,counter,local_dim,1)).col(0);
        T tmp = values_cell.dot( cb.eval_basis(pt) );
        return tmp;
    }

    Eigen::Matrix<T,2,1> gradient( const point<T,2>& pt, const Mesh & msh,  const typename Mesh::cell_type& cl ) const
       {

           // MATRIX NOTATION
           size_t counter = offset(msh,cl);
           Eigen::Matrix<T,2,1> ret = Matrix<T, 2, 1>::Zero(2, 1);
           cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree_FEM);
           //cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree_FEM);
           auto values_cell = sol_HHO.col(counter);
           auto grad_eval =  cb.eval_gradients(pt);
           ret(0) = values_cell.dot( grad_eval.col(0) );
          // std::cout<<"Value of derivative new along x"<<ret(0)<<std::endl;
           ret(1) = values_cell.dot( grad_eval.col(1) );
           //values_cell.dot( grad_eval.col(1) );
          // std::cout<<"Value of derivative new along y"<<ret(1)<<std::endl;
           return ret;

       }


       // IT WORKS FOR NOT-AGGLOMERATED MESHES --> FAST
       Eigen::Matrix<T,2,1> normal(const point<T,2>& pt, const Mesh& msh, const typename Mesh::cell_type& cl) const
       {
           Eigen::Matrix<T,2,1> ret;
           ret = gradient(pt,msh,cl);
           return ret/ret.norm();

       }


};

template< typename VEC , typename DIAG , typename T >
T time_step_CFL_L2_velocity_NEW( const DIAG& dii , const VEC& lumped_mass , const std::vector< bool >& Dirichlet_boundary , T& dt )
{
    T eps = 0.0;
    T tau_min  = dt;
    T CFL_numb = 10.0;
    T CFL_numb_max = -100.0 ;
    size_t i = 0 ;
    for (const auto& dir_elem : Dirichlet_boundary )
    {
        if(!dir_elem){
            if( (1 + 2*tau_min*dii(i)/lumped_mass(i) ) < eps ){
                std::cout<<"tau_min PRE modification is "<<tau_min;
                tau_min = (eps-1.0)/2.0*lumped_mass(i)/dii(i);
                std::cout<<" and tau_min POST modification is "<<tau_min<<std::endl;
            }
            //std::cout<<"dii(i) =  "<<dii(i)<<" , lumped_mass(i) = "<< lumped_mass(i)<<" , tau_min = "<< tau_min <<", (1 + 2*tau_min*dii(i)/lumped_mass(i) ) = "<< (1 + 2*tau_min*dii(i)/lumped_mass(i) ) << " , ,(eps-1.0)/2.0*lumped_mass(i)/dii(i)  = " <<(eps-1.0)/2.0*lumped_mass(i)/dii(i)  <<std::endl;
            CFL_numb = std::min( CFL_numb ,(eps-1.0)/2.0*lumped_mass(i)/dii(i) );
            CFL_numb_max = std::max( CFL_numb_max ,(eps-1.0)/2.0*lumped_mass(i)/dii(i) );
        }
        i++ ;
    }
    std::cout<<"CFL_numb ---> "<<CFL_numb<<std::endl;
    //std::cout<<"CFL_numb_max ---> "<<CFL_numb_max<<std::endl;
    std::cout<<"dt is "<<dt<<" and tau min is "<<tau_min<<std::endl;
    dt = std::min(dt,tau_min);
    return CFL_numb;
}



template < typename Entropy , typename Fonction, typename Fonction_TILDE , typename Mesh, typename Vel_Field , typename T , typename VECTOR >
  void r_i_calculator_Bernstein(const Mesh& msh, const typename Mesh::cell_type& cl , const Entropy& E , const Fonction_TILDE& phi_tilde , const Fonction& phi , T dt , const Vel_Field& u , VECTOR& Emax_global , VECTOR& Emin_global , VECTOR& R_i  )
{
    size_t di = 1;
    cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
    auto cbs = cb.size();
    Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
    auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));

    auto nds = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, phi.degree_FEM );

    size_t offset_cell = offset( msh , cl ) ;

    T max_loc = -1e20;
    T min_loc = 1e20;

    for(auto& ndj : nds )
    {
        max_loc = std::max ( E(ndj , cl) , max_loc );
        min_loc = std::min ( E(ndj , cl) , min_loc );
    }

    for (size_t i = 0; i < phi.local_dim; i++)
    {
        size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
        Emax_global(asm_map) = std::max(Emax_global(asm_map) , max_loc );
        Emin_global(asm_map) = std::min(Emin_global(asm_map) , min_loc ) ;
    }

    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;


    for (auto& qp : qps)
    {
        auto bi = cb.eval_basis(qp.first);
        auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
        auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

        auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) *
                  E.derivative(qp.first,cl) ); //.cwiseQuotient( Emax - Emin ) ;
        ret += qp.second * bi * f;
    }

    for (size_t i = 0; i < phi.local_dim; i++)
    {
        size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
        R_i(asm_map) += ret(i) ;
    }


}


template <typename T>
void positive_part_SPARSE( SparseMatrix<T>& mat) {
    for (size_t i = 0; i<mat.rows();i++) {
        for (size_t j = 0; j<mat.cols();j++) {
            if( mat.coeff(i,j) < 0. )
                mat.coeffRef(i,j) = 0.;
        }
    }

}


template < typename T , typename MATRIX , typename VECTOR ,typename POSITION >
VECTOR alfaf_ij_creator_SPARSE( const VECTOR& lumped_mass , const MATRIX& mass , const VECTOR& delta_phi , const VECTOR& phi_L , T dt , const MATRIX& D_ij , const MATRIX& Dc_ij , const VECTOR& phi_old , const POSITION& S_i)
{

    MATRIX new_mass = - mass;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass.coeffRef(i,i) += lumped_mass(i);
    }

    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);

    SparseMatrix<T> f_ij =  SparseMatrix<T>( mass.rows() , mass.cols() );
    std::vector< Triplet<T> >   triplets0;
    SparseMatrix<T> alpha_ij =  SparseMatrix<T>( mass.rows() , mass.cols() );
    std::vector< Triplet<T> >   triplets1;


    //MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );
    //MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );

    VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero( mass.rows(), 1 );

    VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);
    VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);

    VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);
    VECTOR phi_max = phi_old;
    VECTOR phi_min = phi_old;


    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            phi_max(counter) = std::max(phi_old(elem),phi_max(counter));
            phi_min(counter) = std::min(phi_old(elem),phi_min(counter));
        }
        counter++;
    }

    counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            auto value = new_mass.coeff(counter,elem)*(delta_phi(elem)-delta_phi(counter)) + dt*new_D.coeff(counter,elem)*(phi_old(elem)-phi_old(counter)) ;

            triplets0.push_back( Triplet<T>(counter, elem , value ));
            P_plus(counter) += std::max( 0. , value );
            P_minus(counter) += std::min( 0. , value );

        }

        Q_plus(counter) = lumped_mass(counter)*(phi_max(counter)-phi_L(counter));
        Q_minus(counter) = lumped_mass(counter)*(phi_min(counter)-phi_L(counter));
        if( std::abs(P_plus(counter)) > 1e-20 ){
            T Q_P_plus = Q_plus(counter)/P_plus(counter);
            R_plus(counter) = std::min( 1.0 , Q_P_plus );
        }
        if( std::abs(P_minus(counter)) > 1e-20 ){
            T Q_P_minus = Q_minus(counter)/P_minus(counter);
            R_minus(counter) = std::min( 1.0 , Q_P_minus );
        }


        counter++;
    }


    f_ij.setFromTriplets( triplets0.begin(), triplets0.end() );
    triplets0.clear();

    size_t i = 0 ;
    for(auto& row_i:S_i)
    {
        for(auto& j:row_i)
        {
            if( f_ij.coeff(i, j) > 0 ){
                auto value = std::min( R_plus(i) , R_minus(j) );
                triplets1.push_back( Triplet<T>(i, j , value ));

            }
            else{
                auto value = std::min( R_plus(j) , R_minus(i) );
                triplets1.push_back( Triplet<T>(i, j , value ));

            }
        }
        i++;
    }

    alpha_ij.setFromTriplets( triplets1.begin(), triplets1.end() );
    triplets1.clear();


    size_t counter2 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret(counter2) += ( alpha_ij.coeff(counter2,elem)*f_ij.coeff(counter2,elem) );
        }
        counter2++;
    }


    // CHECKING F and Alpha properties

    /*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<f_ij.coeff(i,j)+f_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }



    std::cout<<"alpha_ij checking symmetry"<<'\n'<<std::endl;
    for(size_t i = 0; i< f_ij.rows() ; i++)
    {
        for(size_t j = 0; j< f_ij.cols() ; j++)
        {
            std::cout<<alpha_ij.coeff(i,j)-alpha_ij.coeff(j,i)<<" , ";
        }
       std::cout<<'\n'<<std::endl;
    }
    */



    /*
    std::cout<<"f_ij checking symmetry"<<'\n'<<std::endl;
    size_t counter3 = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<f_ij.coeff(counter3,elem)+f_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    counter3 = 0;
     std::cout<<"alpha_ij checking symmetry: METODO 2"<<'\n'<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<alpha_ij.coeff(counter3,elem)-alpha_ij.coeff(elem,counter3)<<" , ";
        }
        counter3++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;

    //  CHECKING F_IJ

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    size_t counter4 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret0(counter4) += new_mass.coeff(counter4,elem)*(delta_phi(elem)-delta_phi(counter4));
            ret1(counter4) += new_D.coeff(counter4,elem)*(phi_old(elem)-phi_old(counter4));
        }
        counter++;
    }

    VECTOR f_i = (ret0 + dt*ret1);

    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);
    //sum_Si( S_i , f_ij , One_Vec , f_i_NEW );
    size_t counter5 = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            f_i_NEW(counter5) += f_ij.coeff(counter5,elem)*(One_Vec(elem));
        }
        counter5++;
    }

    std::cout<<'\n'<<"Diff f_i 2 meths is:"<<'\n'<< f_i_NEW - f_i<<std::endl;
    */
    return  ret ;

}



template < typename T , typename MATRIX , typename VECTOR ,typename POSITION >
VECTOR f_ij_creator_SPARSE( const VECTOR& lumped_mass , const MATRIX& mass , const VECTOR& delta_phi , T dt , const MATRIX& D_ij , const MATRIX& Dc_ij , const VECTOR& phi_old , const POSITION& S_i)
{

    MATRIX new_mass = - mass;
    MATRIX new_D = (Dc_ij - D_ij); //(D_ij - Dc_ij);
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass.coeffRef(i,i) += lumped_mass(i);
    }

    /*
    std::cout<<"new_mass sum check: "<<std::endl;
    for(size_t i = 0 ; i < new_mass.rows() ; i++){
        new_mass(i,i) += lumped_mass(i);
        std::cout<<(new_mass.row(i)).sum()<<std::endl;
    }
    std::cout<<"new_D check: "<<std::endl;
    for(size_t i = 0 ; i < new_D.rows() ; i++){
       std::cout<<(new_D.row(i).sum() )<<std::endl;
    }
    */

    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);
    //averaged_sum_Si( S_i , new_mass , delta_phi , ret0 );
    //averaged_sum_Si( S_i , new_D , phi_old , ret1 );

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            ret0(counter) += new_mass.coeff(counter,elem)*(delta_phi(elem)-delta_phi(counter));
            ret1(counter) += new_D.coeff(counter,elem)*(phi_old(elem)-phi_old(counter));


        }
        counter++;
    }

    //  std::cout<<'\n'<<"dt: "<<'\n'<<dt<<std::endl;

    //    std::cout<<'\n'<<"ret0: "<<'\n'<<ret0<<std::endl;
    //    std::cout<<'\n'<<"ret1: "<<'\n'<<dt*ret1<<std::endl;

    return (ret0 + dt*ret1) ;

}







template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename Method_Transport , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , const Method_Transport& method , T& dt , bool mapping )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - COMPRESSED) -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    if(!mapping){
        phi.coefficients_mapping_MAX_MAX( );
        //phi.coefficients_mapping();
    }
    //phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
    //phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;



    // NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14 ; //constant into entropy
    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    // PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


    // SAVING OF USEFUL MATRICES
    auto global_mass = method.Global_Mass ;
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x ;
    auto global_cij_y = method.Global_c_term_y ;
    auto local_vandermonde = method.local_vandermonde ;

    auto cij_norm = method.cij_norm ;
    auto nij0 = method.nij0 ;
    auto nij1 = method.nij1 ;

    auto cji_norm = method.cij_norm ;
    auto nji0 = method.nji0 ;
    auto nji1 = method.nji1 ;



    // INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
    /*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT<SparseMatrix<T> >solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if(solver_global_mass.info()!=Success){
        std::cout<<"FAILED SOLVER LLT."<<std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


    /*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




    // ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    // RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM ;
    //std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;

    // TERM R_i^n
    //Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Emax_global *= -1e20;
    //Emin_global *= 1e20;

    // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for(auto& elem:row_i)
        {

            //Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
            //Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ( (q_entropy.values0(elem) - E.E_der(counter_row)*flux0(elem) )*global_cij_x.coeff(counter_row,elem) + (q_entropy.values1(elem) - E.E_der(counter_row)*flux1(elem) )*global_cij_y.coeff(counter_row,elem) );
            D_i_entropic0 += ( q_entropy.values0(elem) * global_cij_x.coeff(counter_row,elem) + q_entropy.values1(elem) * global_cij_y.coeff(counter_row,elem) );
            D_i_entropic1 += ( flux0(elem)*global_cij_x.coeff(counter_row,elem) + flux1(elem)*global_cij_y.coeff(counter_row,elem) ) ;

            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;

            if( counter_row != elem )
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1)*std::abs(E.E_der(counter_row)) ;

        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
        }
        else
            R_i(counter_row) = std::abs(N_i_entropic)/D_i ;


        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    T nu_max0 = CFL_numb/fe_data.hx;
    T nu0 = dt_old/fe_data.hx;
    T nu1 = dt/fe_data.hx;

    std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        std::cout<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" . STOP!"<<std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




    // CONSTANT TERM (PHI TILDE PROBLEM)
    //Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

  /*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

    timecounter tc_case02;
    tc_case02.tic();

 /*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
    timecounter tc_case03;
    tc_case03.tic();

    // ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix<T> dC_ij =  SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij            =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {

            if(elem!=counter)
            {

                auto R_i_j = c_e * std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) );
                //auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff( counter , elem ) * R_i_j ;
                //triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
                auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );
                //triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
                //T value = 0.0;
                bool check_else = FALSE;
                T value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                /*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    //std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    //std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    //auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                /*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    //std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2 )/( std::abs(phi_FEM(counter) - phi_FEM(elem))+ 1e-18 );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    //std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                } // CONTROLLA QUAAAAA

                auto value_dC_ij = value_E * value_C ;
                triplets_dC_ij.push_back( Triplet<T>(counter, elem, value_dC_ij ) );

                term_dij_no_entropy(counter) += dij.coeff(counter,elem)*(phi_FEM(elem)-phi_FEM(counter));

                term_dij(counter) += value_dC_ij*(phi_FEM(elem)-phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets( triplets_dC_ij.begin(), triplets_dC_ij.end() );
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
    // RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij ;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    //auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

    //std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

    //T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

    //std::cout << "The PROVA error is: " << error1_prova << std::endl;
    //std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

    /*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi_FEM , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;

    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {
        if(dir_elem){
            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }


    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new ;
    phi.converting_into_HHO_formulation(phi_new);

    if(!mapping){
        phi.coefficients_inverse_mapping_MAX_MAX( );
        //phi.coefficients_inverse_mapping();
    }
    //phi.coefficients_inverse_mapping();
    //phi_exact.coefficients_inverse_mapping();


    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}





template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt , bool mapping )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM (new D - INLET - COMPRESSED) -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    if(!mapping){
        phi.coefficients_mapping_MAX_MAX( );
        //phi.coefficients_mapping();
    }
    //phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
    //phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;



    // NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14 ; //constant into entropy
    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    // PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


    // SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass ;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;



    // INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
    /*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT<SparseMatrix<T> >solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if(solver_global_mass.info()!=Success){
        std::cout<<"FAILED SOLVER LLT."<<std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


    /*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




    // ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    // RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM ;
    //std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;

    // TERM R_i^n
    //Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Emax_global *= -1e20;
    //Emin_global *= 1e20;

    // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for(auto& elem:row_i)
        {

            //Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
            //Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ( (q_entropy.values0(elem) - E.E_der(counter_row)*flux0(elem) )*global_cij_x.coeff(counter_row,elem) + (q_entropy.values1(elem) - E.E_der(counter_row)*flux1(elem) )*global_cij_y.coeff(counter_row,elem) );
            D_i_entropic0 += ( q_entropy.values0(elem) * global_cij_x.coeff(counter_row,elem) + q_entropy.values1(elem) * global_cij_y.coeff(counter_row,elem) );
            D_i_entropic1 += ( flux0(elem)*global_cij_x.coeff(counter_row,elem) + flux1(elem)*global_cij_y.coeff(counter_row,elem) ) ;

            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;

            if( counter_row != elem )
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );

        T D_i = std::abs(D_i_entropic0) + std::abs(D_i_entropic1)*std::abs(E.E_der(counter_row)) ;

        if( std::abs(N_i_entropic)<1e-20 && std::abs(D_i) < 1e-20 ){
            R_i(counter_row) = std::abs(N_i_entropic)/(D_i + 1e-18);
            std::cout<<"R_i = "<<R_i(counter_row)<<" , R_i^{OLD} = "<<std::abs(N_i_entropic)/D_i<<std::endl;
        }
        else
            R_i(counter_row) = std::abs(N_i_entropic)/D_i ;


        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    T nu_max0 = CFL_numb/fe_data.hx;
    T nu0 = dt_old/fe_data.hx;
    T nu1 = dt/fe_data.hx;

    std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        std::cout<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" . STOP!"<<std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




    // CONSTANT TERM (PHI TILDE PROBLEM)
    //Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

  /*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

    timecounter tc_case02;
    tc_case02.tic();

 /*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
    timecounter tc_case03;
    tc_case03.tic();

    // ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix<T> dC_ij =  SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij            =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {

            if(elem!=counter)
            {

                auto R_i_j = c_e * std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) );
                //auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff( counter , elem ) * R_i_j ;
                //triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
                auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );
                //triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
                //T value = 0.0;
                bool check_else = FALSE;
                T value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                /*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    //std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    //std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    //auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                /*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    //std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2 )/( std::abs(phi_FEM(counter) - phi_FEM(elem))+ 1e-18 );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    //std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                } // CONTROLLA QUAAAAA

                auto value_dC_ij = value_E * value_C ;
                triplets_dC_ij.push_back( Triplet<T>(counter, elem, value_dC_ij ) );

                term_dij_no_entropy(counter) += dij.coeff(counter,elem)*(phi_FEM(elem)-phi_FEM(counter));

                term_dij(counter) += value_dC_ij*(phi_FEM(elem)-phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets( triplets_dC_ij.begin(), triplets_dC_ij.end() );
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
    // RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij ;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    //auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

    //std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

    //T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

    //std::cout << "The PROVA error is: " << error1_prova << std::endl;
    //std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

    /*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi_FEM , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;

    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {
        if(dir_elem){
            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }


    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new ;
    phi.converting_into_HHO_formulation(phi_new);

    if(!mapping){
        phi.coefficients_inverse_mapping_MAX_MAX( );
        //phi.coefficients_inverse_mapping();
    }
    //phi.coefficients_inverse_mapping();
    //phi_exact.coefficients_inverse_mapping();


    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}

template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt , bool mapping )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    if(!mapping)
        phi.coefficients_mapping_MAX_MAX( );

    //phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1
    //phi_exact.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;



    // NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14 ; //constant into entropy
    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    // PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


    // SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass ;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;



    // INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
    /*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT<SparseMatrix<T> >solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if(solver_global_mass.info()!=Success){
        std::cout<<"FAILED SOLVER LLT."<<std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


    /*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




    // ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    // RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM ;
    //std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;

    // TERM R_i^n
    //Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Emax_global *= -1e20;
    //Emin_global *= 1e20;

    // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for(auto& elem:row_i)
        {

            //Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
            //Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ( (q_entropy.values0(elem) - E.E_der(counter_row)*flux0(elem) )*global_cij_x.coeff(counter_row,elem) + (q_entropy.values1(elem) - E.E_der(counter_row)*flux1(elem) )*global_cij_y.coeff(counter_row,elem) );
            D_i_entropic0 += ( q_entropy.values0(elem) * global_cij_x.coeff(counter_row,elem) + q_entropy.values1(elem) * global_cij_y.coeff(counter_row,elem) );
            D_i_entropic1 += ( flux0(elem)*global_cij_x.coeff(counter_row,elem) + flux1(elem)*global_cij_y.coeff(counter_row,elem) ) ;

            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;

            if( counter_row != elem )
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );

        R_i(counter_row) = std::abs(N_i_entropic)/( std::abs(D_i_entropic0) + std::abs(D_i_entropic1)*std::abs(E.E_der(counter_row)) ) ;


        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    T nu_max0 = CFL_numb/fe_data.hx;
    T nu0 = dt_old/fe_data.hx;
    T nu1 = dt/fe_data.hx;

    std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        std::cout<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" . STOP!"<<std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;




    // CONSTANT TERM (PHI TILDE PROBLEM)
    //Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

  /*
    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;


  */

    timecounter tc_case02;
    tc_case02.tic();

 /*   // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
 */
    timecounter tc_case03;
    tc_case03.tic();

    // ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix<T> dC_ij =  SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij            =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {

            if(elem!=counter)
            {

                auto R_i_j = c_e * std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) );
                //auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff( counter , elem ) * R_i_j ;
                //triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                //auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
                //auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );
                //triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
                //T value = 0.0;
                //bool check_else = FALSE;
                //T value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                /*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                /*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    //std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    //std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    //auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                /*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                /*
                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    //std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2 )/( std::abs(phi_FEM(counter) - phi_FEM(elem))+ 1e-18 );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    //std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;

                } // CONTROLLA QUAAAAA
                */
                auto value_dC_ij = value_E ;  //* value_C ;
                triplets_dC_ij.push_back( Triplet<T>(counter, elem, value_dC_ij ) );

                term_dij_no_entropy(counter) += dij.coeff(counter,elem)*(phi_FEM(elem)-phi_FEM(counter));

                term_dij(counter) += value_dC_ij*(phi_FEM(elem)-phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets( triplets_dC_ij.begin(), triplets_dC_ij.end() );
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
    // RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij ;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    //auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H (new method book Alexandre), t = " << tc_solver5 << " seconds" << reset << std::endl;

    //std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

    //T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

    //std::cout << "The PROVA error is: " << error1_prova << std::endl;
    //std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

    /*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    //Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi_FEM , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;

    for ( const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {
        if(dir_elem){
            //phi_L(counter_dir) = phi_FEM(counter_dir) ;
            //phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }


    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new ;
    phi.converting_into_HHO_formulation(phi_new);

    if(!mapping)
        phi.coefficients_inverse_mapping_MAX_MAX( );
    //phi.coefficients_inverse_mapping();
    //phi_exact.coefficients_inverse_mapping();


    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}

template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM NEW D -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;


    // NON LINEAR ENTROPY INITIALISATION
    T eps = 1e-14 ; //constant into entropy
    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );
    typedef non_linear_entropy_new<T,Fonction,Mesh> Entropy_func;
    entropy_flux<Entropy_func,Fonction,Mesh,Vel_Field,T> q_entropy(E , phi , u , msh );

    // PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


    // SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass ;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;



    // INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
    /*
    ConjugateGradient<SparseMatrix<T> > solver_prova;
    solver_prova.compute(global_mass);
    if(solver_prova.info()!=Success){
           std::cout<<"FAILED SOLVER PROVA."<<std::endl;
           exit(1);
       }
    */
    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT<SparseMatrix<T> >solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if(solver_global_mass.info()!=Success){
        std::cout<<"FAILED SOLVER LLT."<<std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


    /*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




    // ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    // RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM ;
    //std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;

    // TERM R_i^n
    //Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    //Emax_global *= -1e20;
    //Emin_global *= 1e20;

    // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    //Matrix<T, Dynamic, 1> R_i_prova = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);


    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        T N_i_entropic = 0.0;
        T D_i_entropic0 = 0.0;
        T D_i_entropic1 = 0.0;
        for(auto& elem:row_i)
        {

            //Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
            //Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );
            N_i_entropic += ( (q_entropy.values0(elem) - E.E_der(counter_row)*flux0(elem) )*global_cij_x.coeff(counter_row,elem) + (q_entropy.values1(elem) - E.E_der(counter_row)*flux1(elem) )*global_cij_y.coeff(counter_row,elem) );
            D_i_entropic0 += ( q_entropy.values0(elem) * global_cij_x.coeff(counter_row,elem) + q_entropy.values1(elem) * global_cij_y.coeff(counter_row,elem) );
            D_i_entropic1 += ( flux0(elem)*global_cij_x.coeff(counter_row,elem) + flux1(elem)*global_cij_y.coeff(counter_row,elem) ) ;

            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;

            if( counter_row != elem )
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );

        R_i(counter_row) = std::abs(N_i_entropic)/( std::abs(D_i_entropic0) + std::abs(D_i_entropic1)*std::abs(E.E_der(counter_row)) ) ;
        //R_i_prova(counter_row) = std::abs(N_i_entropic) ;

        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    T nu_max0 = CFL_numb/fe_data.hx;
    T nu0 = dt_old/fe_data.hx;
    T nu1 = dt/fe_data.hx;

    std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        std::cout<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" . STOP!"<<std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << bold << yellow << "TIME CHECKING, t = " << tc_case01 << " seconds" << reset << std::endl;


  /*

    // CONSTANT TERM (PHI TILDE PROBLEM)
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;


    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection
    //auto prova0 = solver_prova.solve(b); // SAVE THE L2 projection
    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*phi_tilde.sol_FEM - b).norm() =  "<< (global_mass*phi_tilde.sol_FEM - b).norm() << std::endl;

    //T error0_prova = (global_mass*prova0 - b).norm() / b.norm();

    //std::cout << "The PROVA error is: " << error0_prova << std::endl;
    //std::cout << "b norm =  " << b.norm() << " , (global_mass*prova0 - b).norm() =  "<< (global_mass*prova0 - b).norm() << std::endl;

    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;

*/

/*
    timecounter tc_case02;
    tc_case02.tic();

    // TERM R_i^n

    Matrix<T, Dynamic, 1> R_i_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        //auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i_bis(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    //R_i_bis = R_i_bis.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    std::cout<<"Ri - R_i_bis = "<<'\n'<<R_i_prova<<" , "<<R_i_bis<<" , DIFF -> "<<R_i_prova- R_i_bis <<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;
*/
    timecounter tc_case03;
    tc_case03.tic();

    // ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix<T> dC_ij =  SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij            =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {

            if(elem!=counter)
            {

                auto R_i_j = c_e * std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) );
                //auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                auto value_E = dij.coeff( counter , elem ) * R_i_j ;
                //triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
                auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );
                //triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
                //T value = 0.0;
                bool check_else = FALSE;
                T value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                /*
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))>1e-15) && (std::abs(value_2)>1e-15) ){
                    value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );
                }
                */
                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                /*
                else{
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;
                    auto value_prova = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) ) ;
                    auto value_C = std::max( 1.0 - c_comp * value_prova , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value_prova) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }
                */
                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2 )/( std::abs(phi_FEM(counter) - phi_FEM(elem))+ 1e-18 );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C<<'\n' <<std::endl;
                } // CONTROLLA QUAAAAA

                auto value_dC_ij = value_E * value_C ;
                triplets_dC_ij.push_back( Triplet<T>(counter, elem, value_dC_ij ) );

                term_dij_no_entropy(counter) += dij.coeff(counter,elem)*(phi_FEM(elem)-phi_FEM(counter));

                term_dij(counter) += value_dC_ij*(phi_FEM(elem)-phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets( triplets_dC_ij.begin(), triplets_dC_ij.end() );
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
    // RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij ;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    //auto prova1 = solver_prova.solve(b_phiH); // SAVE THE L2 projection

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

    //std::cout << "mass_phi_old =  " << mass_phi_old << " , conv_global =  "<< conv_global << " , term_dij = "<< term_dij << " , dt = "<< dt << std::endl;

    T relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    //std::cout << "b_phiH.norm() =  " <<b_phiH.norm() << " , (global_mass*phi_H - b_phiH).norm() =  "<< (global_mass*phi_H - b_phiH).norm() << std::endl;

    //T error1_prova = (global_mass*prova1 - b_phiH).norm() / b_phiH.norm();

    //std::cout << "The PROVA error is: " << error1_prova << std::endl;
    //std::cout << "b_phiH norm =  " << b_phiH.norm() << " , (global_mass*prova1 - b_phiH).norm() =  "<< (global_mass*prova1 - b_phiH).norm() << std::endl;

    /*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi_FEM , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary )
    {
        if(dir_elem){
            phi_L(counter_dir) = phi_FEM(counter_dir) ;
            phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;





    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new ;
    phi.converting_into_HHO_formulation(phi_new);
    phi.coefficients_inverse_mapping();

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}



template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_CORRECT_FAST(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;


    // NON LINEAR ENTROPY INITIALISATION
    const T eps = 1e-14 ; //constant into entropy
    non_linear_entropy_new<T,Fonction,Mesh> E(eps , phi ,msh );


    // PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );


    // SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass ;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;



    // INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
    //ConjugateGradient<SparseMatrix<T> > solver_global_mass;

    timecounter tc_solver;
    tc_solver.tic();

    SimplicialLLT<SparseMatrix<T> >solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if(solver_global_mass.info()!=Success){
        std::cout<<"FAILED SOLVER 0->phi_tilde"<<std::endl;
        exit(1);
    }

    tc_solver.toc();
    std::cout << bold << yellow << "INVERSION WITH CHOLESKY METHOD, t = " << tc_solver << " seconds" << reset << std::endl;


    /*
    timecounter tc_solver1_bis;
    tc_solver1_bis.tic();
    ConjugateGradient<SparseMatrix<double>, Lower|Upper> solver2_bis;
    solver2_bis.compute(global_mass);
    if(solver2_bis.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }

    tc_solver1_bis.toc();
    std::cout << bold << yellow << "INVERSION WITH ITERATIVE CG METHOD, t = " << tc_solver1_bis << " seconds" << reset << std::endl;

    */




    // ALTERNATIVE VANDERMONDE MATRIX
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout  << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"  << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    // RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM ;
    //std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij + CALCULATION OF MAX AND MIN OF THE ENTROPY
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;

    // TERM R_i^n
    Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Emax_global *= -1e20;
    Emin_global *= 1e20;




    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {

            Emax_global(counter_row) = std::max ( E.E_values(elem) , Emax_global(counter_row) );
            Emin_global(counter_row) = std::min ( E.E_values(elem) , Emin_global(counter_row) );


            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;

            if( counter_row != elem )
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        std::cout<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" . STOP!"<<std::endl;
        exit(10);
    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




    // CONSTANT TERM (PHI TILDE PROBLEM)
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;


    timecounter tc_solver3;
    tc_solver3.tic();

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection

    // norm() is L2 norm
    T relative_error0 = (global_mass*phi_tilde.sol_FEM - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;

    /*
    auto prova_phi_tilde_2 = solver2_bis.solve(b);
    T relative_error2 = (global_mass*prova_phi_tilde_2 - b).norm() / b.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;


    if(solver_global_mass.info()!=Success) {
        std::cout<<"FAILED SOLVER 1->phi_tilde"<<std::endl;
        exit(1);
    }
    */
    tc_solver3.toc();
    std::cout << bold << yellow << "INVERSION OF phi_tilde, t = " << tc_solver3 << " seconds" << reset << std::endl;

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    timecounter tc_solver4;
    tc_solver4.tic();
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );
    tc_solver4.toc();
    std::cout << bold << yellow << "CONVERTING phi_tilde, t = " << tc_solver4 << " seconds" << reset << std::endl;




    timecounter tc_case02;
    tc_case02.tic();

    // TERM R_i^n
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
    {
        size_t di = 1;
        size_t offset_cell = offset(msh,cl) ;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();
        Matrix<T, Dynamic, 1> ret = Matrix<T, Dynamic, 1>::Zero(cbs);
        //auto qps = integrate(msh, cl, 2*(phi.degree_FEM+di));
        //auto qps = integrate(msh, cl, (phi.degree_FEM)+di);
        auto qps = integrate(msh, cl, di);

        for (auto& qp : qps)
        {
            auto bi = cb.eval_basis(qp.first);
            auto phi_grad0 = phi.gradient(qp.first,msh,cl)(0);
            auto phi_grad1 = phi.gradient(qp.first,msh,cl)(1);

            auto f = ( ( ( phi_tilde(qp.first,msh,cl)-phi(qp.first,msh,cl) )/dt + u(qp.first,msh,cl).first * phi_grad0 + u(qp.first,msh,cl).second * phi_grad1 ) * E.derivative(qp.first,cl) );
            ret += qp.second * bi * f;
        }
        for (size_t i = 0; i < phi.local_dim; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[offset_cell][i].first ;
            R_i(asm_map) += ret(i) ;
        }

    }


    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    //R_i = R_i.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    //std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;

    tc_case02.toc();
    std::cout << bold << yellow << "R_i PROCESS, t = " << tc_case02 << " seconds" << reset << std::endl;

    timecounter tc_case03;
    tc_case03.tic();

    // ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    T c_comp = 1.0;


    SparseMatrix<T> dC_ij =  SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dC_ij;

    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij            =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {

            if(elem!=counter)
            {

                auto R_i_j = c_e * std::max( std::abs(R_i(counter)),std::abs(R_i(elem)) );
                auto value_E = std::min( dij.coeff( counter , elem ) , R_i_j );
                //triplets_dE_ij.push_back( Triplet<T>(counter, elem, value_E ) );

                auto value_1 = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
                auto value_2 = std::max( value_1*(1.0 -value_1) , 0.0 );

                bool check_else = FALSE;
                //triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );
                //if( std::abs(phi_FEM(counter_tmp) - phi_FEM(elem))>1e-15 ){
                auto value = value_2/( std::abs(phi_FEM(counter) - phi_FEM(elem)) );

                if( (std::abs(phi_FEM(counter) - phi_FEM(elem))<1e-20) && (std::abs(value_2)<1e-20) ){
                    std::cout<<"SONO IN ELSE: std::abs(phi_FEM(counter) - phi_FEM(elem)) = "<<std::abs(phi_FEM(counter) - phi_FEM(elem))<< " and value_2 = "<<value_2<<std::endl;
                    std::cout<<"elem = "<<elem << " and counter = "<<counter<<std::endl;

                    auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    std::cout<<"1.0 - c_comp * value = "<<(1.0 - c_comp * value) << " and value_C = "<<value_C<<std::endl;
                    check_else = TRUE;
                }



                auto value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                if(check_else){
                    std::cout<<"value_C GIUSTO = "<<value_C <<std::endl;
                    value = (value_2+ 1e-18)/( std::abs(phi_FEM(counter) - phi_FEM(elem))  );
                    value_C = std::max( 1.0 - c_comp * value , 0.0 ) ;
                    //value_C = 1.0;
                    std::cout<<"Se NaN-> metto dC = 0!!! -> value_C CORRETTO = "<<value_C <<std::endl;
                }

                auto value_dC_ij = value_E * value_C ;
                triplets_dC_ij.push_back( Triplet<T>(counter, elem, value_dC_ij ) );

                term_dij_no_entropy(counter) += dij.coeff(counter,elem)*(phi_FEM(elem)-phi_FEM(counter));

                term_dij(counter) += value_dC_ij*(phi_FEM(elem)-phi_FEM(counter));


            }


        }
        counter++;
    }

    dC_ij.setFromTriplets( triplets_dC_ij.begin(), triplets_dC_ij.end() );
    triplets_dC_ij.clear();


    tc_case03.toc();
    std::cout << bold << yellow << "ENTROPIC and HO PROCESS, t = " << tc_case03 << " seconds" << reset << std::endl;



    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    timecounter tc_solver5;
    tc_solver5.tic();
    // RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij ;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    tc_solver5.toc();
    std::cout << bold << yellow << "SOLUTION phi_H, t = " << tc_solver5 << " seconds" << reset << std::endl;

    relative_error0 = (global_mass*phi_H - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error0 << std::endl;
    /*
    auto phi_H_prova2 = solver2_bis.solve(b_phiH);
    relative_error2 = (global_mass*phi_H_prova2 - b_phiH).norm() / b_phiH.norm();
    std::cout << "The relative error is: " << relative_error2 << std::endl;
   */

    timecounter tc_case06;
    tc_case06.tic();

    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi_FEM , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary )
    {
        if(dir_elem){
            phi_L(counter_dir) = phi_FEM(counter_dir) ;
            phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    tc_case06.toc();
    std::cout << bold << yellow << "EXTENSION HO, t = " << tc_case06 << " seconds" << reset << std::endl;





    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new ;
    phi.converting_into_HHO_formulation(phi_new);
    phi.coefficients_inverse_mapping();

    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}







template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename Transport_Method , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , const Transport_Method& method ,  T& dt )
{
    // Starting time for FE calculation
    std::cout<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND) -----------"<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;
    //auto phi_exact_FEM = phi_exact.sol_FEM ;



    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x ;
    auto global_cij_y = method.Global_c_term_y ;
    auto local_vandermonde = method.local_vandermonde ;

    auto cij_norm = method.cij_norm ;
    auto nij0 = method.nij0 ;
    auto nij1 = method.nij1 ;

    auto cji_norm = method.cij_norm ;
    auto nji0 = method.nji0 ;
    auto nji1 = method.nji1 ;





    // VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    //std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    //std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"CHECKING OF CFL CONDITION (ALEXANDRE BOOK):"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;
    std::cout<<"CFL condition ---------> dt =  "<< CFL_numb <<std::endl;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
    //std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
    /*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    //std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<"----------- FINE TRANSPORT PROBLEM -----------"<<std::endl;



    //return phi_tilde;

}


template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename Transport_Method , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , const Transport_Method& method , T& dt , const FiniteSpace& fe_data_u )
{
    // Starting time for FE calculation
    std::cout<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND - VEL L^\tilde{k}) -----------"<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;

    auto S_pt_cell = fe_data.S_pt_cell ;

    //size_t degree_u = fe_data_u.order; // finite element order
    //size_t dim_u = fe_data_u.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    //size_t local_ndof_u = fe_data_u.local_ndof ; // local degrees of freedom
    //auto S_i_u = fe_data_u.S_i;
    //auto S_pt_cell_u = fe_data_u.S_pt_cell ;
    //std::cout<<"HP: DoF velocity > DoF level set . "<<std::endl;
    //if( degree_u > degree)
    //    exit(10) ;

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;
    //auto phi_exact_FEM = phi_exact.sol_FEM ;



    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = method.Global_Mass_Lumped;

    auto global_cij_x = method.Global_c_term_x ;
    auto global_cij_y = method.Global_c_term_y ;
    auto local_vandermonde = method.local_vandermonde ;

    auto cij_norm = method.cij_norm ;
    auto nij0 = method.nij0 ;
    auto nij1 = method.nij1 ;

    auto cji_norm = method.cij_norm ;
    auto nji0 = method.nji0 ;
    auto nji1 = method.nji1 ;





    // VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );

        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u(pts[i], msh , cl ).first * phi(pts[i] , msh , cl );
            flux1_loc(i) = u(pts[i], msh , cl ).second * phi(pts[i] , msh , cl );

        }


        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    //std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_pt_cell)
    {
        T sum_row = 0.0 ;
        auto pt_i = row_i.first.first ;
        auto cl_i = row_i.first.second ;
        for(auto& elem:row_i.second)
        {
            auto pt_j = elem.second.first ;
            auto cl_j = elem.second.second ;
            size_t elem_j = elem.first ;
            T value0 = std::abs( u(pt_i,msh,cl_i).first * nij0.coeff(counter_row,elem_j) + u(pt_i,msh,cl_i).second * nij1.coeff(counter_row,elem_j) );
            T value1 = std::abs( u(pt_j,msh,cl_j).first * nij0.coeff(counter_row,elem_j) + u(pt_j,msh,cl_j).second * nij1.coeff(counter_row,elem_j) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u(pt_i,msh,cl_i).first * nji0.coeff(counter_row,elem_j) + u(pt_i,msh,cl_i).second * nji1.coeff(counter_row,elem_j) );
            T value_adj1 = std::abs( u(pt_j,msh,cl_j).first * nji0.coeff(counter_row,elem_j) + u(pt_j,msh,cl_j).second * nji1.coeff(counter_row,elem_j) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem_j) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem_j) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem_j )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem_j ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem_j, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem_j)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();
    /*
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
     dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );

     triplets_dij.clear();
    */





    tc_case00.toc();
    //std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"CHECKING OF CFL CONDITION (ALEXANDRE BOOK):"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;
    std::cout<<"CFL condition ---------> dt =  "<< CFL_numb <<std::endl;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
    //std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
    /*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    //std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<"----------- FINE TRANSPORT PROBLEM -----------"<<std::endl;



    //return phi_tilde;

}




template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt )
{
    // Starting time for FE calculation
    std::cout<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND) -----------"<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;
    //auto phi_exact_FEM = phi_exact.sol_FEM ;



    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;





    // VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    //std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    //std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"CHECKING OF CFL CONDITION (ALEXANDRE BOOK):"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;
    std::cout<<"CFL condition ---------> dt =  "<< CFL_numb <<std::endl;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
    //std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
    /*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    //std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<"----------- FINE TRANSPORT PROBLEM -----------"<<std::endl;



    //return phi_tilde;

}

template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt , const FiniteSpace& fe_data_u )
{
    // Starting time for FE calculation
    std::cout<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER (NEW INLET COND - VEL L^\tilde{k}) -----------"<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;

    auto S_pt_cell = fe_data.S_pt_cell ;

    size_t degree_u = fe_data_u.order; // finite element order
    //size_t dim_u = fe_data_u.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    //size_t local_ndof_u = fe_data_u.local_ndof ; // local degrees of freedom
    //auto S_i_u = fe_data_u.S_i;
    //auto S_pt_cell_u = fe_data_u.S_pt_cell ;
    //std::cout<<"HP: DoF velocity > DoF level set . "<<std::endl;
    //if( degree_u > degree)
    //    exit(10) ;

    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;
    //auto phi_exact_FEM = phi_exact.sol_FEM ;



    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;





    // VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );

        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u(pts[i], msh , cl ).first * phi(pts[i] , msh , cl );
            flux1_loc(i) = u(pts[i], msh , cl ).second * phi(pts[i] , msh , cl );

        }


        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    //std::cout << bold << yellow << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds" << reset << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_pt_cell)
    {
        T sum_row = 0.0 ;
        auto pt_i = row_i.first.first ;
        auto cl_i = row_i.first.second ;
        for(auto& elem:row_i.second)
        {
            auto pt_j = elem.second.first ;
            auto cl_j = elem.second.second ;
            size_t elem_j = elem.first ;
            T value0 = std::abs( u(pt_i,msh,cl_i).first * nij0.coeff(counter_row,elem_j) + u(pt_i,msh,cl_i).second * nij1.coeff(counter_row,elem_j) );
            T value1 = std::abs( u(pt_j,msh,cl_j).first * nij0.coeff(counter_row,elem_j) + u(pt_j,msh,cl_j).second * nij1.coeff(counter_row,elem_j) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u(pt_i,msh,cl_i).first * nji0.coeff(counter_row,elem_j) + u(pt_i,msh,cl_i).second * nji1.coeff(counter_row,elem_j) );
            T value_adj1 = std::abs( u(pt_j,msh,cl_j).first * nji0.coeff(counter_row,elem_j) + u(pt_j,msh,cl_j).second * nji1.coeff(counter_row,elem_j) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem_j) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem_j) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem_j )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem_j ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem_j, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem_j)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();
    /*
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        //std::cout<<"Row = "<<counter_row<<"d_ii = "<<-sum_row<<std::endl;
        counter_row++;


    }
     dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );

     triplets_dij.clear();
    */





    tc_case00.toc();
    //std::cout << bold << yellow << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << reset << std::endl;




    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"CHECKING OF CFL CONDITION (ALEXANDRE BOOK):"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary_inlet , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;
    std::cout<<"CFL condition ---------> dt =  "<< CFL_numb <<std::endl;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;







    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS -> NO INLET BDRY CONDITIONS!
    //std::cout<<"phi_L = "<<phi_L.size()<<" , phi_exact_FEM = "<<phi_exact_FEM.size()<<std::endl;
    /*
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary_inlet )
    {

        //std::cout<<"counter_dir = "<<counter_dir<<" , dir_elem = "<<dir_elem<<std::endl;
        if(dir_elem){
            phi_L(counter_dir) = phi_exact_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }

    */






    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    //std::cout << "FEM method, time resolution: " << tc << " seconds" << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<"----------- FINE TRANSPORT PROBLEM -----------"<<std::endl;



    //return phi_tilde;

}

template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM LOW ORDER FAST -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;



    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;





    // VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);

    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );

        }

        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }


    tc_solver2.toc();
    std::cout  << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"  << std::endl;



    timecounter tc_case00;
    tc_case00.tic();



    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;



    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout  << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;

    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );
    std::cout<<"----------------------> COND IN TEMPO CFL t_CFL = "<< CFL_numb <<" (ALEXANDRE BOOK)"<<std::endl;
    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        dt = floorf(CFL_numb*0.98 * 1000) / 1000;
        std::cout<<yellow<<bold<<"ATTENTION CHANGIN dt!!! ----> "<<reset<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" !"<<std::endl;
        //exit(10);

    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);


    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary )
    {
        if(dir_elem){
            phi_L(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }







    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}




template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check_C_NEW(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt , Matrix<T, Dynamic, 1>& phi2 , Matrix<T, Dynamic, 1>& phi3 , int i_prova , Matrix<T, Dynamic, 1>& vecprova0, Matrix<T, Dynamic, 1>& vecprova1, Matrix<T, Dynamic, 1>& vecprova2 , Matrix<T, Dynamic, 1>& vecprovabis0 , Matrix<T, Dynamic, 1>& vecprovabis1 ,Matrix<T, Dynamic, Dynamic>& vecprovabis2 , Matrix<T, Dynamic, Dynamic>& vecprovabis3 , Matrix<T, Dynamic, Dynamic>& vecprovabis4 ,Matrix<T, Dynamic, Dynamic>& vecprovabis5 , Matrix<T, Dynamic, 1>& vecprovabis6 , Matrix<T, Dynamic, 1>& vecprovabis7 )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- CHECKING ---> TRANSPORT PROBLEM LOW ORDER FAST -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;

    std::cout<<"IMPORTANTEEEEE --------------------------_> i = "<<i_prova <<std::endl;

    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    //auto global_cij_x = phi.Global_c_term_x ;
    //auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;


    //std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;
    SparseMatrix<T>                 global_cij_x; // Global mass, saved for FEM problem
    SparseMatrix<T>                 global_cij_y;
    global_cij_x = SparseMatrix<T>( dim, dim ); //(b_i,b_j)_ij , b_i Lagrange basis fx
    global_cij_y = SparseMatrix<T>( dim, dim ); //(b_i,b_j)_ij , b_i Lagrange basis fx
    std::vector< Triplet<T> >       triplets_c_term_x_l; // Position elements: Sparse Matrix Notation
    std::vector< Triplet<T> >       triplets_c_term_y_l; // Position elements: Sparse Matrix Notation
    for( const auto& cl : msh.cells )
    {
        size_t cell_offset = offset(msh, cl) ;
        //auto local_cij_lagrangian = make_lagrangian_local_cij_matrix (msh, cl, degree);
        auto local_cij_lagrangian = make_bernstein_local_cij_matrix_with_velocity (msh, cl, degree , u );
        auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);
        //std::cout<< "local_cij_lagrangian.first "<<'\n'<<local_cij_lagrangian.first<<std::endl;


        // Assembling triplets for global problem
        for (size_t i = 0; i < local_ndof; i++)
        {
            size_t asm_map_i = phi.connectivity_matrix[cell_offset][i].first ;
            for (size_t j = 0; j < local_ndof; j++)
            {
                size_t asm_map_j = phi.connectivity_matrix[cell_offset][j].first ;
                triplets_c_term_x_l.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij_lagrangian.first(i,j) ) );
                triplets_c_term_y_l.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij_lagrangian.second(i,j) ) );

            }
        }

    }

    global_cij_x.setFromTriplets( triplets_c_term_x_l.begin(), triplets_c_term_x_l.end() );
    triplets_c_term_x_l.clear();

    global_cij_y.setFromTriplets( triplets_c_term_y_l.begin(), triplets_c_term_y_l.end() );
    triplets_c_term_y_l.clear();
    /*
    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;
    */
    SparseMatrix<T> cij_norm = ( global_cij_x.cwiseProduct(global_cij_x) + global_cij_y.cwiseProduct(global_cij_y) ).cwiseSqrt() ;
    //std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

    // MATRIX n_ij
    SparseMatrix<T> nij0 = global_cij_x.cwiseQuotient( cij_norm );
    SparseMatrix<T> nij1 = global_cij_y.cwiseQuotient( cij_norm );

    //std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


    // MATRIX c_ji
    SparseMatrix<T> cji_x = global_cij_x.adjoint() ;
    SparseMatrix<T> cji_y = global_cij_y.adjoint() ;

    // NORM of c_ji -> i.e. c_ij transposed
    SparseMatrix<T> cji_norm = (cji_x.cwiseProduct(cji_x)+cji_y.cwiseProduct(cji_y)).cwiseSqrt();

    // MATRIX n_ij (TRANSPOSED)
    SparseMatrix<T> nji0 = cji_x.cwiseQuotient( cji_norm );
    SparseMatrix<T> nji1 = cji_y.cwiseQuotient( cji_norm );



    Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);

    Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_y.rows(), 1);

    for (size_t k = 0; k<global_cij_x.cols(); k++)
    {
        sum0 += (global_cij_x).col(k);
        sum1 += (global_cij_y).col(k);
    }

    for (size_t i=0; i<global_cij_x.rows(); i++) {
        std::cout<<"The sum is "<<sum1(i)<<" and "<<sum0(i)<<std::endl;
    }



    for(size_t counter_sum = 0 ; counter_sum < global_cij_x.rows() ; counter_sum++ )
    {
        for(size_t counter_col = 0 ; counter_col < global_cij_x.cols() ; counter_col++)
        {

            if(counter_col==counter_sum)
                std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0 = "<<global_cij_x.coeff( counter_sum , counter_col )<<" and c1 = "<<global_cij_y.coeff( counter_sum , counter_col )<<std::endl;
            else
                std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0_ij + c^0_ji = "<<global_cij_x.coeff( counter_sum , counter_col ) + global_cij_x.coeff( counter_col , counter_sum )<<" and c^1_ij + c^1_ji = "<<global_cij_y.coeff( counter_sum , counter_col ) + global_cij_y.coeff( counter_col , counter_sum ) <<std::endl;
        }
    }


    // VANDERMONDE MATRIX INTERPOLATION
    //size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    Matrix<T, Dynamic, 1> flux0_prova = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1_prova = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux0_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> vel2_loc0 = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> sol_vel_gl0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> vel2_loc1 = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> sol_vel_gl1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    /*
    Matrix<T, Dynamic, Dynamic> sol_vel_gl_cellwise = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof,msh.cells.size()) ;
    Matrix<T, Dynamic, Dynamic> one_loc = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof,local_ndof) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);
    ColPivHouseholderQR<Matrix<T, Dynamic, Dynamic > > cod_bis(local_vandermonde);


    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            //std::cout<<"pts[i] = "<<pts[i] << " HHO_u0 = "<<u0_cellwise(i,i_fl)<<std::endl;
            flux0_prova_loc(i) = u0_cellwise(i,i_fl) * (phi(pts[i] , msh , cl ) + 0.5);
            flux1_prova_loc(i) = u1_cellwise(i,i_fl) * (phi(pts[i] , msh , cl ) + 0.5);
            vel2_loc0(i) = u0_cellwise(i,i_fl) ;
            vel2_loc1(i) = u1_cellwise(i,i_fl) ;
            one_loc(i,i) = 1.0;
            if(i_prova == 0){
                //std::cout<<"phi(" << pts[i] <<", msh , cl ) = "<<phi(pts[i] , msh , cl )<<std::endl;
                vecprovabis4(i,offset(msh,cl)) = ( phi(pts[i] , msh , cl ) ) ;
            }
            else
                vecprovabis5(i,offset(msh,cl)) = ( phi(pts[i] , msh , cl ) ) ;
        }

        Matrix<T, Dynamic, 1> sol0_bis = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1_bis = cod.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol0 = cod_bis.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod_bis.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol_vel0 = cod_bis.solve(vel2_loc0);
        Matrix<T, Dynamic, 1> sol_vel1 = cod_bis.solve(vel2_loc1);
        Matrix<T, Dynamic, Dynamic> check_inversion = cod_bis.solve(one_loc);

        //T relative_error01 = (local_vandermonde*sol_vel- vel2_loc).norm() / vel2_loc.norm();
        //std::cout << "The relative error0 of VELOCITY is: " << relative_error01 << std::endl;


        //std::cout<<"Cell = "<<offset(msh,cl)<<", check_inversion_Vandermonde = "<<'\n'<<check_inversion <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", vel2_loc = "<<'\n'<<vel2_loc <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC = "<<'\n'<<sol_vel <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC - u0 LOC = "<<'\n'<<sol_vel - u0_cellwise.col(i_fl)  <<std::endl;

        if(i_prova == 0){
        //std::cout<<"-------------------> sol0 - sol0_bis "<<'\n'<< sol0 - sol0_bis<<std::endl;
        //std::cout<<"-------------------> sol1 - sol1_bis "<<'\n'<< sol1 - sol1_bis<<std::endl;
            vecprovabis2.col(offset(msh,cl)) = flux0_loc  ; // è quello +0.5
            vecprovabis3.col(offset(msh,cl)) = flux1_loc  ; // è quello +0.5

        }
        if(i_prova == 1)
        {
            //std::cout<<"-------------------> sol0 - vecprovabis2 "<<'\n'<< flux0_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> sol1 - vecprovabis3 "<<'\n'<< flux1_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;
            std::cout<<"-------------------> FLUX THEORETICAL 0 LOC"<<'\n'<< flux0_prova_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
            std::cout<<"-------------------> FLUX THEORETICAL 1 LOC"<<'\n'<< flux1_prova_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;

            //std::cout<<"-------------------> CHECK phi VAL LOC ----------"<<'\n'<< vecprovabis5.col(offset(msh,cl)) - vecprovabis4.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> CHECK phi VAL SOL +0.5 ----------"<<'\n'<<  vecprovabis4.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> CHECK phi VAL SOL OLD ----------"<<'\n'<<  vecprovabis5.col(offset(msh,cl))<<std::endl;


        }

        Matrix<T, Dynamic, 1>     sol0_prova = cod.solve(flux0_prova_loc);
        Matrix<T, Dynamic, 1>     sol1_prova = cod.solve(flux1_prova_loc);



        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }
        //T relative_error0 = (local_vandermonde*sol0_prova - flux0_prova_loc).norm() / flux0_prova_loc.norm();
        //T relative_error1 = (local_vandermonde*sol1_prova - flux1_prova_loc).norm() / flux1_prova_loc.norm();
        //T relative_error2 = (local_vandermonde*sol0 - flux0_loc).norm() / flux0_loc.norm();
        //T relative_error3 = (local_vandermonde*sol1- flux1_loc).norm() / flux1_loc.norm();
        //std::cout << "The relative error0 is: " << relative_error0 << std::endl;
        //std::cout << "The relative error1 is: " << relative_error1<< std::endl;
        //std::cout << "The relative error2 is: " << relative_error2 << std::endl;
        //std::cout << "The relative error3 is: " << relative_error3<< std::endl;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;
            flux0_prova(asm_map) = sol0_prova(i) ;
            flux1_prova(asm_map) = sol1_prova(i) ;
            sol_vel_gl0(asm_map) = sol_vel0(i) ;
            sol_vel_gl1(asm_map) = sol_vel1(i) ;
            sol_vel_gl_cellwise(i,i_fl) = sol_vel0.dot( cb.eval_basis(pts[i]) );
        }


        i_fl++;
    }

    */


   // auto check_div_u = 1.0/2.0 * global_cij_x *sol_vel_gl0   + global_cij_y * sol_vel_gl1 ;
   // auto check_div_u_2 = 1.0/2.0 * Global_c_term_x_lagrangian *u0   + Global_c_term_y_lagrangian * u1 ;

    //std::cout<<"----------CHECK DIV Bernstein -> "<<'\n'<<check_div_u<<std::endl;
    //std::cout<<"----------CHECK DIV Lagrangian -> "<<'\n'<<check_div_u_2<<std::endl;

    /*
    for(auto& cl:msh.cells)
    {
        size_t cell_offset = offset(msh, cl) ;
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++)
        {
            auto pt = pts[i];
            std::cout<<"In pt = "<<pt<<" --> u0(pt) = "<<u(pt,msh,cl).first<<" and ERROR = "<<  (u(pt,msh,cl).first - sol_vel_gl_cellwise(i,cell_offset))<<std::endl;
        }

    }

    //std::cout<<"-------------------> sol_vel - u0 "<<'\n'<< sol_vel_gl - u0<<std::endl;


    tc_solver2.toc();
    std::cout  << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"  << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    if(i_prova == 1){
        //std::cout<<"----->CHECK PROJECTION flux0 = "<<'\n'<<flux0 +0.5*u0 - vecprovabis0 <<std::endl;
        //std::cout<<"----->CHECK PROJECTION flux1 = "<<'\n'<<flux1 +0.5*u1 - vecprovabis1 <<std::endl;

        std::cout<<"----->CHECK PROJECTION flux0 TEORIC = "<<'\n'<<vecprovabis0 - flux0_prova<<std::endl;

        std::cout<<"----->CHECK PROJECTION flux1 TEORIC = "<<'\n'<<vecprovabis1 - flux1_prova <<std::endl;


        //std::cout<<"---> flux0 ERROR = "<<'\n'<<flux0 - vecprovabis0 <<std::endl;
        //std::cout<<"---> flux1 ERROR = "<<'\n'<<flux1 - vecprovabis1 <<std::endl;
        //std::cout<<"---> flux0  = "<<'\n'<<flux0  <<std::endl;
        //std::cout<<"---> flux1  = "<<'\n'<<flux1  <<std::endl;
        //std::cout<<"---> u0_cellwise = "<<'\n'<<u0_cellwise - vecprovabis2 <<std::endl;
        //std::cout<<"---> u1_cellwise = "<<'\n'<<u1_cellwise - vecprovabis3 <<std::endl;
        //std::cout<<"---> phi_FEM = "<<'\n'<<phi_FEM - vecprovabis4 <<std::endl;
        //std::cout<<"---> global_cij_x = "<<'\n'<<global_cij_x - vecprovabis5 <<std::endl;
        //std::cout<<"---> global_cij_y = "<<'\n'<<global_cij_y - vecprovabis6 <<std::endl;

    }
    if(i_prova == 0){
        vecprovabis0 = flux0 ;
        vecprovabis1 = flux1 ;


    }
    */
    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * phi_FEM  + global_cij_y * phi_FEM ;
    //Matrix<T, Dynamic, 1> prova0_fl =  0.5*(global_cij_x * u0  + global_cij_y * u1) ;
    Matrix<T, Dynamic, 1> prova0_fl1 =  global_cij_x * flux0_prova  + global_cij_y * flux1_prova ;

    if(i_prova == 0)
        vecprova2 = conv_global ;

    if(i_prova == 1){
        //std::cout<<"---> prova0_fl = "<<'\n'<<prova0_fl - vecprovabis7 <<std::endl;
        //std::cout<<"------> prova0_fl_somma phi_tilde convolution = "<<'\n'<<vecprova2 - conv_global - vecprovabis7  <<std::endl;
        std::cout<<"------> CHECK CONVOLUTION +0.5 = "<<'\n'<<prova0_fl1 - vecprova2   <<std::endl;
    }
    //if(i_prova == 0)//{
    //vecprovabis7 = prova0_fl ;
    //}
    //if(i_prova == 1)
        //std::cout<<"--------->   conv_global = "<<'\n'<<conv_global - vecprova2 <<std::endl;


    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    //tc_case00.toc();
    //std::cout  << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        dt = floorf(CFL_numb*0.98 * 1000) / 1000;
        std::cout<<yellow<<bold<<"ATTENTION CHANGIN dt!!! ----> "<<reset<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" !"<<std::endl;
        //exit(10);

    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

    if(i_prova == 1)
      //  std::cout<<"global_lumped_mass = "<<'\n'<<global_lumped_mass - vecprova0 <<std::endl;
    if(i_prova == 0)
        vecprova0 = global_lumped_mass ;

    if(i_prova == 1)
      //  std::cout<<"term_dij_no_entropy = "<<'\n'<<term_dij_no_entropy - vecprova1 <<std::endl;
    if(i_prova == 0)
        vecprova1 = term_dij_no_entropy ;



    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary )
    {
        if(dir_elem){
            phi_L(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }


    if(i_prova == 1)
     //   std::cout<<"phi_FEM = "<<'\n'<<phi_FEM - phi2 <<std::endl;

    if(i_prova == 0)
        phi2 = phi_FEM ;


    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}


template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt , Matrix<T, Dynamic, 1>& phi2 , Matrix<T, Dynamic, 1>& phi3 , int i_prova , Matrix<T, Dynamic, 1>& vecprova0, Matrix<T, Dynamic, 1>& vecprova1, Matrix<T, Dynamic, 1>& vecprova2 , Matrix<T, Dynamic, 1>& vecprovabis0 , Matrix<T, Dynamic, 1>& vecprovabis1 ,Matrix<T, Dynamic, Dynamic>& vecprovabis2 , Matrix<T, Dynamic, Dynamic>& vecprovabis3 , Matrix<T, Dynamic, Dynamic>& vecprovabis4 ,Matrix<T, Dynamic, Dynamic>& vecprovabis5 , Matrix<T, Dynamic, 1>& vecprovabis6 , Matrix<T, Dynamic, 1>& vecprovabis7 )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- CHECKING ---> TRANSPORT PROBLEM LOW ORDER FAST -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;


    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    auto u0_cellwise = u.sol_HHO.first ;
    auto u1_cellwise = u.sol_HHO.second ;

    std::cout<<"IMPORTANTEEEEE --------------------------_> i = "<<i_prova <<std::endl;

    // SAVING OF USEFUL MATRICES
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    auto cij_norm = phi.cij_norm ;
    auto nij0 = phi.nij0 ;
    auto nij1 = phi.nij1 ;

    auto cji_norm = phi.cij_norm ;
    auto nji0 = phi.nji0 ;
    auto nji1 = phi.nji1 ;

    //std::cout<<"local_vandermonde"<<'\n'<<local_vandermonde<<std::endl;
    SparseMatrix<T>                 Global_c_term_x_lagrangian; // Global mass, saved for FEM problem
    SparseMatrix<T>                 Global_c_term_y_lagrangian;
    Global_c_term_x_lagrangian = SparseMatrix<T>( dim, dim ); //(b_i,b_j)_ij , b_i Lagrange basis fx
    Global_c_term_y_lagrangian = SparseMatrix<T>( dim, dim ); //(b_i,b_j)_ij , b_i Lagrange basis fx
    std::vector< Triplet<T> >       triplets_c_term_x_l; // Position elements: Sparse Matrix Notation
    std::vector< Triplet<T> >       triplets_c_term_y_l; // Position elements: Sparse Matrix Notation
    for( const auto& cl : msh.cells )
    {
        size_t cell_offset = offset(msh, cl) ;
        //auto local_cij_lagrangian = make_lagrangian_local_cij_matrix (msh, cl, degree);
        auto local_cij_lagrangian = make_bernstein_local_cij_matrix_with_velocity (msh, cl, degree , u );
        auto qps = equidistriduted_nodes_ordered_bis<T,Mesh>(msh, cl, degree);
        //std::cout<< "local_cij_lagrangian.first "<<'\n'<<local_cij_lagrangian.first<<std::endl;


        // Assembling triplets for global problem
        for (size_t i = 0; i < local_ndof; i++)
        {
            size_t asm_map_i = phi.connectivity_matrix[cell_offset][i].first ;
            for (size_t j = 0; j < local_ndof; j++)
            {
                size_t asm_map_j = phi.connectivity_matrix[cell_offset][j].first ;
                triplets_c_term_x_l.push_back( Triplet<T>(asm_map_i, asm_map_j , local_cij_lagrangian.first(i,j) ) );
                triplets_c_term_y_l.push_back( Triplet<T>( asm_map_i , asm_map_j , local_cij_lagrangian.second(i,j) ) );

            }
        }

    }

    Global_c_term_x_lagrangian.setFromTriplets( triplets_c_term_x_l.begin(), triplets_c_term_x_l.end() );
    triplets_c_term_x_l.clear();

    Global_c_term_y_lagrangian.setFromTriplets( triplets_c_term_y_l.begin(), triplets_c_term_y_l.end() );
    triplets_c_term_y_l.clear();

    Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(Global_c_term_x_lagrangian.rows(), 1);

    Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(Global_c_term_y_lagrangian.rows(), 1);

    for (size_t k = 0; k<global_cij_x.cols(); k++)
    {
        sum0 += (Global_c_term_x_lagrangian).col(k);
        sum1 += (Global_c_term_y_lagrangian).col(k);
    }

    for (size_t i=0; i<Global_c_term_x_lagrangian.rows(); i++) {
        std::cout<<"The sum is "<<sum1(i)<<" and "<<sum0(i)<<std::endl;
    }



    for(size_t counter_sum = 0 ; counter_sum < Global_c_term_x_lagrangian.rows() ; counter_sum++ )
    {
        for(size_t counter_col = 0 ; counter_col < Global_c_term_x_lagrangian.cols() ; counter_col++)
        {

            if(counter_col==counter_sum)
                std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0 = "<<Global_c_term_x_lagrangian.coeff( counter_sum , counter_col )<<" and c1 = "<<Global_c_term_y_lagrangian.coeff( counter_sum , counter_col )<<std::endl;
            else
                std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0_ij + c^0_ji = "<<Global_c_term_x_lagrangian.coeff( counter_sum , counter_col ) + Global_c_term_x_lagrangian.coeff( counter_col , counter_sum )<<" and c^1_ij + c^1_ji = "<<Global_c_term_y_lagrangian.coeff( counter_sum , counter_col ) + Global_c_term_y_lagrangian.coeff( counter_col , counter_sum ) <<std::endl;
        }
    }


    // VANDERMONDE MATRIX INTERPOLATION
    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    Matrix<T, Dynamic, 1> flux0_prova = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1_prova = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux0_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_prova_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> vel2_loc0 = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> sol_vel_gl0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> vel2_loc1 = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> sol_vel_gl1 = Matrix<T, Dynamic, 1>::Zero(dim) ;


    Matrix<T, Dynamic, Dynamic> sol_vel_gl_cellwise = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof,msh.cells.size()) ;
    Matrix<T, Dynamic, Dynamic> one_loc = Matrix<T, Dynamic, Dynamic>::Zero(local_ndof,local_ndof) ;

    timecounter tc_solver2;
    tc_solver2.tic();

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod(local_vandermonde);
    ColPivHouseholderQR<Matrix<T, Dynamic, Dynamic > > cod_bis(local_vandermonde);


    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u0_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            flux1_loc(i) = u1_cellwise(i,i_fl) * phi(pts[i] , msh , cl );
            //std::cout<<"pts[i] = "<<pts[i] << " HHO_u0 = "<<u0_cellwise(i,i_fl)<<std::endl;
            flux0_prova_loc(i) = u0_cellwise(i,i_fl) * (phi(pts[i] , msh , cl ) + 0.5);
            flux1_prova_loc(i) = u1_cellwise(i,i_fl) * (phi(pts[i] , msh , cl ) + 0.5);
            vel2_loc0(i) = u0_cellwise(i,i_fl) ;
            vel2_loc1(i) = u1_cellwise(i,i_fl) ;
            one_loc(i,i) = 1.0;
            if(i_prova == 0){
                //std::cout<<"phi(" << pts[i] <<", msh , cl ) = "<<phi(pts[i] , msh , cl )<<std::endl;
                vecprovabis4(i,offset(msh,cl)) = ( phi(pts[i] , msh , cl ) ) ;
            }
            else
                vecprovabis5(i,offset(msh,cl)) = ( phi(pts[i] , msh , cl ) ) ;
        }

        Matrix<T, Dynamic, 1> sol0_bis = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1_bis = cod.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol0 = cod_bis.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod_bis.solve(flux1_loc);
        Matrix<T, Dynamic, 1> sol_vel0 = cod_bis.solve(vel2_loc0);
        Matrix<T, Dynamic, 1> sol_vel1 = cod_bis.solve(vel2_loc1);
        Matrix<T, Dynamic, Dynamic> check_inversion = cod_bis.solve(one_loc);

        //T relative_error01 = (local_vandermonde*sol_vel- vel2_loc).norm() / vel2_loc.norm();
        //std::cout << "The relative error0 of VELOCITY is: " << relative_error01 << std::endl;


        //std::cout<<"Cell = "<<offset(msh,cl)<<", check_inversion_Vandermonde = "<<'\n'<<check_inversion <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", vel2_loc = "<<'\n'<<vel2_loc <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC = "<<'\n'<<sol_vel <<std::endl;
        //std::cout<<"Cell = "<<offset(msh,cl)<<", sol_vel LOC - u0 LOC = "<<'\n'<<sol_vel - u0_cellwise.col(i_fl)  <<std::endl;

        if(i_prova == 0){
        //std::cout<<"-------------------> sol0 - sol0_bis "<<'\n'<< sol0 - sol0_bis<<std::endl;
        //std::cout<<"-------------------> sol1 - sol1_bis "<<'\n'<< sol1 - sol1_bis<<std::endl;
            vecprovabis2.col(offset(msh,cl)) = flux0_loc  ; // è quello +0.5
            vecprovabis3.col(offset(msh,cl)) = flux1_loc  ; // è quello +0.5

        }
        if(i_prova == 1)
        {
            //std::cout<<"-------------------> sol0 - vecprovabis2 "<<'\n'<< flux0_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> sol1 - vecprovabis3 "<<'\n'<< flux1_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;
            std::cout<<"-------------------> FLUX THEORETICAL 0 LOC"<<'\n'<< flux0_prova_loc - vecprovabis2.col(offset(msh,cl))<<std::endl;
            std::cout<<"-------------------> FLUX THEORETICAL 1 LOC"<<'\n'<< flux1_prova_loc - vecprovabis3.col(offset(msh,cl))<<std::endl;

            //std::cout<<"-------------------> CHECK phi VAL LOC ----------"<<'\n'<< vecprovabis5.col(offset(msh,cl)) - vecprovabis4.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> CHECK phi VAL SOL +0.5 ----------"<<'\n'<<  vecprovabis4.col(offset(msh,cl))<<std::endl;
            //std::cout<<"-------------------> CHECK phi VAL SOL OLD ----------"<<'\n'<<  vecprovabis5.col(offset(msh,cl))<<std::endl;


        }

        Matrix<T, Dynamic, 1>     sol0_prova = cod.solve(flux0_prova_loc);
        Matrix<T, Dynamic, 1>     sol1_prova = cod.solve(flux1_prova_loc);



        if (cod.info() != Success)
        {
            std::cout<<"Not positive"<<std::endl;
            assert(0);
        }
        //T relative_error0 = (local_vandermonde*sol0_prova - flux0_prova_loc).norm() / flux0_prova_loc.norm();
        //T relative_error1 = (local_vandermonde*sol1_prova - flux1_prova_loc).norm() / flux1_prova_loc.norm();
        //T relative_error2 = (local_vandermonde*sol0 - flux0_loc).norm() / flux0_loc.norm();
        //T relative_error3 = (local_vandermonde*sol1- flux1_loc).norm() / flux1_loc.norm();
        //std::cout << "The relative error0 is: " << relative_error0 << std::endl;
        //std::cout << "The relative error1 is: " << relative_error1<< std::endl;
        //std::cout << "The relative error2 is: " << relative_error2 << std::endl;
        //std::cout << "The relative error3 is: " << relative_error3<< std::endl;
        cell_basis_Bernstein<Mesh,T> cb(msh, cl, phi.degree_FEM);
        auto cbs = cb.size();

        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;
            flux0_prova(asm_map) = sol0_prova(i) ;
            flux1_prova(asm_map) = sol1_prova(i) ;
            sol_vel_gl0(asm_map) = sol_vel0(i) ;
            sol_vel_gl1(asm_map) = sol_vel1(i) ;
            sol_vel_gl_cellwise(i,i_fl) = sol_vel0.dot( cb.eval_basis(pts[i]) );
        }


        i_fl++;
    }


    auto check_div_u = 1.0/2.0 * global_cij_x *sol_vel_gl0   + global_cij_y * sol_vel_gl1 ;
    auto check_div_u_2 = 1.0/2.0 * Global_c_term_x_lagrangian *u0   + Global_c_term_y_lagrangian * u1 ;

    std::cout<<"----------CHECK DIV Bernstein -> "<<'\n'<<check_div_u<<std::endl;
    std::cout<<"----------CHECK DIV Lagrangian -> "<<'\n'<<check_div_u_2<<std::endl;


    for(auto& cl:msh.cells)
    {
        size_t cell_offset = offset(msh, cl) ;
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++)
        {
            auto pt = pts[i];
            std::cout<<"In pt = "<<pt<<" --> u0(pt) = "<<u(pt,msh,cl).first<<" and ERROR = "<<  (u(pt,msh,cl).first - sol_vel_gl_cellwise(i,cell_offset))<<std::endl;
        }

    }

    //std::cout<<"-------------------> sol_vel - u0 "<<'\n'<< sol_vel_gl - u0<<std::endl;


    tc_solver2.toc();
    std::cout  << "DIRECT INVERSION OF VANDERMONDE MATRIX LOCAL, t = " << tc_solver2 << " seconds"  << std::endl;



    timecounter tc_case00;
    tc_case00.tic();

    if(i_prova == 1){
        //std::cout<<"----->CHECK PROJECTION flux0 = "<<'\n'<<flux0 +0.5*u0 - vecprovabis0 <<std::endl;
        //std::cout<<"----->CHECK PROJECTION flux1 = "<<'\n'<<flux1 +0.5*u1 - vecprovabis1 <<std::endl;

        std::cout<<"----->CHECK PROJECTION flux0 TEORIC = "<<'\n'<<vecprovabis0 - flux0_prova<<std::endl;

        std::cout<<"----->CHECK PROJECTION flux1 TEORIC = "<<'\n'<<vecprovabis1 - flux1_prova <<std::endl;


        //std::cout<<"---> flux0 ERROR = "<<'\n'<<flux0 - vecprovabis0 <<std::endl;
        //std::cout<<"---> flux1 ERROR = "<<'\n'<<flux1 - vecprovabis1 <<std::endl;
        //std::cout<<"---> flux0  = "<<'\n'<<flux0  <<std::endl;
        //std::cout<<"---> flux1  = "<<'\n'<<flux1  <<std::endl;
        //std::cout<<"---> u0_cellwise = "<<'\n'<<u0_cellwise - vecprovabis2 <<std::endl;
        //std::cout<<"---> u1_cellwise = "<<'\n'<<u1_cellwise - vecprovabis3 <<std::endl;
        //std::cout<<"---> phi_FEM = "<<'\n'<<phi_FEM - vecprovabis4 <<std::endl;
        //std::cout<<"---> global_cij_x = "<<'\n'<<global_cij_x - vecprovabis5 <<std::endl;
        //std::cout<<"---> global_cij_y = "<<'\n'<<global_cij_y - vecprovabis6 <<std::endl;

    }
    if(i_prova == 0){
        vecprovabis0 = flux0 ;
        vecprovabis1 = flux1 ;


    }

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;
    //Matrix<T, Dynamic, 1> prova0_fl =  0.5*(global_cij_x * u0  + global_cij_y * u1) ;
    Matrix<T, Dynamic, 1> prova0_fl1 =  global_cij_x * flux0_prova  + global_cij_y * flux1_prova ;

    if(i_prova == 0)
        vecprova2 = conv_global ;

    if(i_prova == 1){
        //std::cout<<"---> prova0_fl = "<<'\n'<<prova0_fl - vecprovabis7 <<std::endl;
        //std::cout<<"------> prova0_fl_somma phi_tilde convolution = "<<'\n'<<vecprova2 - conv_global - vecprovabis7  <<std::endl;
        std::cout<<"------> CHECK CONVOLUTION +0.5 = "<<'\n'<<prova0_fl1 - vecprova2   <<std::endl;
    }
    //if(i_prova == 0)//{
    //vecprovabis7 = prova0_fl ;
    //}
    //if(i_prova == 1)
        //std::cout<<"--------->   conv_global = "<<'\n'<<conv_global - vecprova2 <<std::endl;


    // TERM d_ij
    SparseMatrix<T> dij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dij;
    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T,Dynamic,1>::Zero(dim, 1);

    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        T sum_row = 0.0 ;
        for(auto& elem:row_i)
        {
            T value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            T value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            T value = std::max(value0 , value1);

            T value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            T value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            T value_adj = std::max(value_adj0 , value_adj1);

            T lambda_max = value * cij_norm.coeff(counter_row,elem) ;
            T lambda_max_adj = value_adj * cji_norm.coeff(counter_row,elem) ;

            T val_dij = std::max( lambda_max , lambda_max_adj );

            if( counter_row == elem )
                val_dij = 0.0 ;

            sum_row += val_dij ;


            if( counter_row != elem ){
                triplets_dij.push_back( Triplet<T>(counter_row, elem, val_dij ) );
                term_dij_no_entropy(counter_row) += val_dij*(phi_FEM(elem)-phi_FEM(counter_row));
            }


        }
        triplets_dij.push_back( Triplet<T>(counter_row, counter_row, -sum_row ) );
        counter_row++;

    }

    dij.setFromTriplets( triplets_dij.begin(), triplets_dij.end() );
    triplets_dij.clear();



    tc_case00.toc();
    std::cout  << "RESOLUTION OF LOW ORDER TRANSPORT, t = " << tc_case00 << " seconds" << std::endl;

    timecounter tc_case01;
    tc_case01.tic();

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;

    if(dt_old != dt )
    {
        dt = floorf(CFL_numb*0.98 * 1000) / 1000;
        std::cout<<yellow<<bold<<"ATTENTION CHANGIN dt!!! ----> "<<reset<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" !"<<std::endl;
        //exit(10);

    }

    tc_case01.toc();
    std::cout << "TIME CHECKING, t = " << tc_case01 << " seconds" << std::endl;




    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

    if(i_prova == 1)
      //  std::cout<<"global_lumped_mass = "<<'\n'<<global_lumped_mass - vecprova0 <<std::endl;
    if(i_prova == 0)
        vecprova0 = global_lumped_mass ;

    if(i_prova == 1)
      //  std::cout<<"term_dij_no_entropy = "<<'\n'<<term_dij_no_entropy - vecprova1 <<std::endl;
    if(i_prova == 0)
        vecprova1 = term_dij_no_entropy ;



    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary )
    {
        if(dir_elem){
            phi_L(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }


    if(i_prova == 1)
     //   std::cout<<"phi_FEM = "<<'\n'<<phi_FEM - phi2 <<std::endl;

    if(i_prova == 0)
        phi2 = phi_FEM ;


    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_L ;
    phi.converting_into_HHO_formulation(phi_L);



    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;



    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    //postprocess_output<double> postoutput5;
    //auto test_phi_L = std::make_shared< gnuplot_output_object<double> >("phi_L.dat");



    /*
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_L->add_data( pt , phi(pt, msh , cl ) );
        }
    }
    postoutput5.add_object(test_phi_L);
    postoutput5.write();
    */


    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;



    //return phi_tilde;

}


template < typename Fonction, typename Mesh, typename Vel_Field , typename FiniteSpace , typename T = typename Mesh::coordinate_type >
void
run_FEM_BERNSTEIN_CORRECT(const Mesh & msh, const FiniteSpace& fe_data, Fonction & phi , Vel_Field& u , T& dt )
{
    // Starting time for FE calculation
    std::cout<<yellow<<bold<<"----------- STARTING TRANSPORT PROBLEM -----------"<<reset<<std::endl;
    //std::cout<<yellow<<bold<<"PROVA--- USO MIXC LAGRANGE- BERNSTEIN"<<reset<<std::endl;

    timecounter tc;
    tc.tic();

    size_t degree = fe_data.order; // finite element order
    size_t dim = fe_data.ndof_FE ;
    //size_t n_cls = fe_data.n_cls ;
    size_t local_ndof = fe_data.local_ndof ; // local degrees of freedom
    auto S_i = fe_data.S_i;

    // TOLTO PER ORA IL MAPPING NON SERVE NEL CASO BASE

    phi.coefficients_mapping(); // mapping of phi to have a phi between 0 and 1


    /// PLOT ---> PHI MAPPED INTO 0-1
    postprocess_output<double> postoutput4;
    auto test_phi_mapped = std::make_shared< gnuplot_output_object<double> >("phi_mapped.dat");
    for (auto cl:msh.cells) {
        auto pts = points(msh,cl) ;
        for (auto pt:pts) {
            T value = phi(pt,msh,cl);
            test_phi_mapped->add_data(pt,value);
        }
    }
    postoutput4.add_object(test_phi_mapped);
    postoutput4.write();


    // SAVING PHI AND VELOCITY COEFFS
    auto phi_FEM = phi.sol_FEM ;
    auto u0 = u.sol_FEM.first ;
    auto u1 = u.sol_FEM.second ;
    //u.set_max_vel(); // UPLOADING MAX VELOCITY OF u -> Bernstein Basis

    //std::cout<<"CONSTANT VELOCITY: u0 is "<<u0<<" and u1 is "<<u1<<std::endl;

    // NON LINEAR ENTROPY INITIALISATION
    const T eps = 1e-14 ; //constant into entropy
    non_linear_entropy<T,Fonction,Mesh> E(eps , phi ,msh );
    //SONOQUA1
    // PHI TILDE INITIALISATION --> (FOR HIGH ORDER METHOD)
    auto phi_tilde = L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );

    //L2_projection< T, Mesh , FiniteSpace> ( fe_data , msh );

    /// ENTROPY PLOT
    /*
    postprocess_output<double> postoutput6;
    auto cut_entropy = std::make_shared< gnuplot_output_object<double> >("entropy.dat");
    for (auto& cl:msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto& pt:pts)
        {
            T value = E(pt,cl);
            cut_entropy->add_data(pt,value);
        }
    }
    postoutput6.add_object(cut_entropy);
    postoutput6.write();
    */



    // SAVING OF USEFUL MATRICES
    auto global_mass = phi.Global_Mass ;
    Matrix<T, Dynamic, 1> global_lumped_mass = phi.Global_Mass_Lumped;

    auto global_cij_x = phi.Global_c_term_x ;
    auto global_cij_y = phi.Global_c_term_y ;
    auto local_vandermonde = phi.local_vandermonde ;

    // THE GLOBAL MATRIX c_ij varies each time: dependes on u -> c_ij = int(u*b_i*grad(b_j))
    /*
    SparseMatrix<T>                 global_cij_x = SparseMatrix<T>( dim, dim );
    SparseMatrix<T>                 global_cij_y = SparseMatrix<T>( dim, dim );
    std::vector< Triplet<T> >       triplets_c_term_x;
    std::vector< Triplet<T> >       triplets_c_term_y;
    for( const auto& cl : msh.cells )
    {
        size_t cell_offset = offset(msh, cl) ;


        // Local c_ij = u(x)*b_i* grad(b_j)
        auto local_cij = make_bernstein_local_cij_matrix_with_velocity(msh, cl, degree, u );

        for (size_t i = 0; i < local_ndof; i++)
        {
            auto asm_map_i = phi.connectivity_matrix[cell_offset][i].first ;
            for (size_t j = 0; j < local_ndof; j++)
            {
                auto asm_map_j = phi.connectivity_matrix[cell_offset][j].first ;
                triplets_c_term_x.push_back( Triplet<T>(asm_map_i, asm_map_j, local_cij.first(i,j) ) );
                triplets_c_term_y.push_back( Triplet<T>(asm_map_i, asm_map_j, local_cij.second(i,j) ) );
           }

        }
    }
    // FINALISATION c_ij GLOBAL ASSEMBLING
    global_cij_x.setFromTriplets( triplets_c_term_x.begin(), triplets_c_term_x.end() );
    triplets_c_term_x.clear();
    global_cij_y.setFromTriplets( triplets_c_term_y.begin(), triplets_c_term_y.end() );
    triplets_c_term_y.clear();
    */



    // INITIALISATION OF THE SOLVER (CONJUGATE GRADIENT)
    //ConjugateGradient<SparseMatrix<T> > solver_global_mass;

    timecounter tc1;
    tc1.tic();

    SimplicialLLT<SparseMatrix<T> >solver_global_mass;
    solver_global_mass.compute(global_mass); // use solver_global_mass to solve M^-1

    if(solver_global_mass.info()!=Success){
        std::cout<<"FAILED SOLVER 0->phi_tilde"<<std::endl;
        exit(1);
    }

    tc1.toc();
    std::cout << bold << yellow << "Inversion of the mass matrix: " << tc1 << " seconds" << reset << std::endl;

    /*
    SparseLU<SparseMatrix<T>, AMDOrdering<int> > solver2 ;
    solver2.compute(global_mass);
    if(solver2.info()!=Success) {
        std::cout<<"FAILED SOLVER2 PROVA ->phi_tilde"<<std::endl;
        return;
    }
    */

    /// CHECKING OF MASS MATRICES' PROPERTIES
    /*
    std::cout<<"First checking: Lumped Mass"<<std::endl;
    for(size_t i = 0; i<global_lumped_mass.rows();i++)
        if(global_lumped_mass(i)<0)
            std::cout<<"PROBLEM into lumped mass"<<std::endl;

    Matrix<T, Dynamic, Dynamic> mass_check = - global_mass;
    for(size_t i = 0 ; i < mass_check.rows() ; i++){
        mass_check(i,i) += global_lumped_mass(i);
        std::cout<<(mass_check.row(i)).sum()<<std::endl;
    }

    /// CHECK OF THE SUM PROPERTY OF CIJ
     Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);
     Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);

    for (size_t k = 0; k<global_cij_x.cols(); k++)
    {
        sum0 += (global_cij_x).col(k);
        sum1 += (global_cij_y).col(k);
    }

    for (size_t i=0; i<global_cij_y.rows(); i++) {
         std::cout<<"The sum is "<<sum1(i)<<" and "<<sum0(i)<<std::endl;
    }



    for(size_t counter_sum = 0 ; counter_sum < global_cij_x.rows() ; counter_sum++ )
    {
        for(size_t counter_col = 0 ; counter_col < global_cij_x.cols() ; counter_col++)
        {

           if(counter_col==counter_sum)
               std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0 = "<<global_cij_x.coeff( counter_sum , counter_col )<<" and c1 = "<<global_cij_y.coeff( counter_sum , counter_col )<<std::endl;
           else
                std::cout<<"In ("<<counter_sum<<" , "<<counter_col<<" ), c^0_ij + c^0_ji = "<<global_cij_x.coeff( counter_sum , counter_col ) + global_cij_x.coeff( counter_col , counter_sum )<<" and c^1_ij + c^1_ji = "<<global_cij_y.coeff( counter_sum , counter_col ) + global_cij_y.coeff( counter_col , counter_sum ) <<std::endl;
        }
    }

 */

    // FLUX TERM
    /*
    Matrix<T, Dynamic, 1>  RHS_flux0 =  Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1>  RHS_flux1 =  Matrix<T, Dynamic, 1>::Zero(dim) ;
    size_t counter_flux = 0 ;
    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto local_flux = make_bernstein_local_RHS_FLUX( msh , cl , degree , u , phi ) ;
        //std::cout<<"flux_loc0  "<<'\n'<<flux_loc.first<<std::endl;
        //std::cout<<"flux_loc1  "<<'\n'<<flux_loc.second<<std::endl;
        for (size_t i = 0; i < local_ndof ; i++)
        {
            size_t asm_map =  phi.connectivity_matrix[counter_flux][i].first ;
            RHS_flux0(asm_map) += local_flux.first(i) ;
            RHS_flux1(asm_map) += local_flux.second(i) ;
        }
        counter_flux++;
    }
    Matrix<T, Dynamic, 1> flux0 = solver_global_mass.solve(RHS_flux0);
    Matrix<T, Dynamic, 1> flux1 = solver_global_mass.solve(RHS_flux1);
     */


    // ALTERNATIVE VANDERMONDE MATRIX

    //Matrix<T, Dynamic, 1> flux0 = u0.cwiseProduct( phi_FEM ) ;
    //Matrix<T, Dynamic, 1> flux1 = u1.cwiseProduct( phi_FEM );

    size_t i_fl = 0 ;
    Matrix<T, Dynamic, 1> flux0_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;
    Matrix<T, Dynamic, 1> flux1_loc = Matrix<T, Dynamic, 1>::Zero(local_ndof) ;

    Matrix<T, Dynamic, 1> flux0 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    Matrix<T, Dynamic, 1> flux1 = Matrix<T, Dynamic, 1>::Zero(dim) ;

    //Matrix<T, Dynamic, Dynamic> local_vandermonde = Matrix<T, Dynamic, Dynamic>::Zero ( local_ndof , local_ndof) ;


    //T error0_L2 = 0.0 , error1_L2 = 0.0 ;

    CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod( local_vandermonde );


    for(auto& cl : msh.cells)
    {
        // FLUX TERM : flux is a pair flux0 and flux1
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        //cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree);
        for (size_t i = 0; i < local_ndof ; i++)
        {
            flux0_loc(i) = u(pts[i] , msh , cl ).first * phi(pts[i] , msh , cl );
            flux1_loc(i) = u(pts[i] , msh , cl ).second * phi(pts[i] , msh , cl );
            // LOCAL VANDERMONDE MATRIX -> è uguale penso basti farla tra [0,1] e riportarla qua
            //local_vandermonde.block(i,0,1,local_ndof) = (cb.eval_basis(pts[i])).transpose() ;

            //size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;

        }

        //std::cout<<'\n'<<'\n'<<"local_vandermonde "<<local_vandermonde<<'\n'<<std::endl;
        //CompleteOrthogonalDecomposition<Matrix<T, Dynamic, Dynamic > > cod( local_vandermonde );
        Matrix<T, Dynamic, 1> sol0 = cod.solve(flux0_loc);
        Matrix<T, Dynamic, 1> sol1 = cod.solve(flux1_loc);
        //std::cout<<"flux0_loc -sol0"<<'\n'<<flux0_loc-sol0<<'\n'<<std::endl;
        //if (cod.info() != Success)
        //{
        //    std::cout<<"Not positive"<<std::endl;
        //    assert(0);
        //}



        for (size_t i = 0; i < local_ndof ; i++)
        {

            size_t asm_map =  phi.connectivity_matrix[i_fl][i].first ;
            flux0(asm_map) = sol0(i) ;
            flux1(asm_map) = sol1(i) ;

        }


        i_fl++;
    }




    //std::cout<<"flux0_bis:"<<'\n'<<flux0_bis <<'\n' <<std::endl;
    //std::cout<<"flux0:"<<'\n'<< flux0<<'\n' <<std::endl;
/*
    T sum0 = 0.0 , sum1 = 0.0 ;
    for (int ii = 0 ; ii < dim ; ii++ )
    {
        sum0 += pow( (flux0_bis(ii) - flux0(ii)) , 2 );
        sum1 += pow( (flux1_bis(ii) - flux1(ii)) , 2 );
    }

    error0_L2 = sqrt( 1.0/dim * sum0 );
    error1_L2 = sqrt( 1.0/dim * sum1 );
    std::cout<<"ERRORE L2 (flux0_bis - flux0):"<<'\n'<<error0_L2<<'\n' <<std::endl;
    std::cout<<"ERRORE L2 (flux1_bis - flux1):"<<'\n'<<error1_L2<<'\n' <<std::endl;
*/


    // RESOLUTION OF phi_tilde (GLOBALLY)    ( with cij(phi_j) )
    Matrix<T, Dynamic, 1> mass_phi_old = global_mass * phi_FEM ; // USEFUL ALSO FOR HO PHI_H
    //std::cout<<"vec1  "<<'\n'<<mass_phi_old<<std::endl;

    // CONVOLUTION TERM
    Matrix<T, Dynamic, 1> conv_global = global_cij_x * flux0  + global_cij_y * flux1 ;
    //Matrix<T, Dynamic, 1> conv_global = global_cij_x * phi_FEM  + global_cij_y * phi_FEM ;
    /*
    Matrix<T, Dynamic, 1> flux0 = 10 * phi_FEM ;
    Matrix<T, Dynamic, 1> flux1 = 0 * phi_FEM ;
    Matrix<T, Dynamic, 1> conv_global2 = phi.Global_c_term_x * flux0  + phi.Global_c_term_y * flux1 ;
    std::cout<<"CHECK cij conv_global  "<<'\n'<<conv_global-conv_global2<<std::endl;
    */






    // NORM of c_ij
    SparseMatrix<T> cij_norm = ( global_cij_x.cwiseProduct(global_cij_x) + global_cij_y.cwiseProduct(global_cij_y) ).cwiseSqrt() ;
    //std::cout<<"cij norm "<<'\n'<<cij_norm<<std::endl;

    // MATRIX n_ij
    SparseMatrix<T> nij0 = global_cij_x.cwiseQuotient( cij_norm );
    SparseMatrix<T> nij1 = global_cij_y.cwiseQuotient( cij_norm );

    //std::cout<<"nij1  "<<'\n'<<nij1<<std::endl;


    // MATRIX c_ji
    SparseMatrix<T> cji_x = global_cij_x.adjoint() ;
    SparseMatrix<T> cji_y = global_cij_y.adjoint() ;

    // NORM of c_ji -> i.e. c_ij transposed
    SparseMatrix<T> cji_norm = (cji_x.cwiseProduct(cji_x)+cji_y.cwiseProduct(cji_y)).cwiseSqrt();

    // MATRIX n_ij (TRANSPOSED)
    SparseMatrix<T> nji0 = cji_x.cwiseQuotient( cji_norm );
    SparseMatrix<T> nji1 = cji_y.cwiseQuotient( cji_norm );


    // NORMAL VELOCITY
    SparseMatrix<T> normal_vel = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets;

    // NORMAL VELOCITY TRANSPOSED
    SparseMatrix<T> normal_vel_adj = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_adj ;
    /*
    // NORMAL VELOCITY
    SparseMatrix<T> normal_vel_bis = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets0_bis;

    // NORMAL VELOCITY TRANSPOSED
    SparseMatrix<T> normal_vel_bis_adj = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets1_bis ;
    */
    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            auto value0 = std::abs( u0(counter_row) * nij0.coeff(counter_row,elem) + u1(counter_row) * nij1.coeff(counter_row,elem) );
            auto value1 = std::abs( u0(elem) * nij0.coeff(counter_row,elem) + u1(elem) * nij1.coeff(counter_row,elem) );
            auto value = std::max(value0 , value1);

            auto value_adj0 = std::abs( u0(counter_row) * nji0.coeff(counter_row,elem) + u1(counter_row) * nji1.coeff(counter_row,elem) );
            auto value_adj1 = std::abs( u0(elem) * nji0.coeff(counter_row,elem) + u1(elem) * nji1.coeff(counter_row,elem) );
            auto value_adj = std::max(value_adj0 , value_adj1);

            triplets.push_back( Triplet<T>(counter_row, elem, value ) );
            triplets_adj.push_back( Triplet<T>(counter_row, elem, value_adj ) );


            // CHECK IT
            /*
            auto value0_bis = std::max( u0(counter_row) , u0(elem) );
            auto value1_bis = std::max( u1(counter_row) , u1(elem) );
            auto val = value0_bis * nij0.coeff(counter_row,elem) + value1_bis * nij1.coeff(counter_row,elem) ;
            auto val_adj = value0_bis * nji0.coeff(counter_row,elem) + value1_bis * nji1.coeff(counter_row,elem) ;

            triplets0_bis.push_back( Triplet<T>(counter_row, elem, val ) );
            triplets1_bis.push_back( Triplet<T>(counter_row, elem, val_adj ) );
            */


        }
        counter_row++;
    }

    normal_vel.setFromTriplets( triplets.begin(), triplets.end() );
    triplets.clear();
    normal_vel_adj.setFromTriplets( triplets_adj.begin(), triplets_adj.end() );
    triplets_adj.clear();

    /*
    normal_vel_bis.setFromTriplets( triplets0_bis.begin(), triplets0_bis.end() );
    triplets0_bis.clear();
    normal_vel_bis_adj.setFromTriplets( triplets1_bis.begin(), triplets1_bis.end() );
    triplets1_bis.clear();
    SparseMatrix<T> normal_vel_abs_bis = normal_vel_bis.cwiseAbs() ;  // o lambda_max=normal_vel ?
    SparseMatrix<T> normal_vel_abs_adj_bis = normal_vel_bis_adj.cwiseAbs();
    */
    // CHECKING NEW METHOD NORMAL VEL
    /*
    for(size_t i = 0 ; i < normal_vel_abs_bis.rows() ; i++)
    {
        for(size_t j = 0 ; j < normal_vel_abs_bis.cols() ; j++){
            if(std::abs(normal_vel.coeff(i,j)-normal_vel_abs_bis.coeff(i,j))>1e-5)
                std::cout<<"In ("<<i<<" , "<<j<<" ), normal vel OLD is "<<normal_vel_abs_bis.coeff(i,j)<<" , normal vel NEW is "<<normal_vel.coeff(i,j)<<std::endl;

            if(std::abs(normal_vel_adj.coeff(i,j)-normal_vel_abs_adj_bis.coeff(i,j))>1e-5)
                std::cout<<"In ("<<i<<" , "<<j<<" ), normal vel ADJ OLD is "<<normal_vel_abs_adj_bis.coeff(i,j)<<" , normal vel  ADJ NEW is "<<normal_vel_adj.coeff(i,j)<<std::endl;

        }
    }
    */
    //SparseMatrix<T> normal_vel2 = u0 * nij0 + u1 * nij1 ;
    //SparseMatrix<T> normal_vel_adj2 = u0 * nji0 + u1 * nji1 ;

    //std::cout<<"normal_vel - nij0"<<'\n'<<normal_vel - nij0<<std::endl;
    //std::cout<<"normal_vel_adj - nij0"<<'\n'<<normal_vel_adj - nji0<<std::endl;
    //std::cout<<"CHECK normal_vel2  : "<<'\n'<<normal_vel-normal_vel2<<'\n'<<std::endl;
    //std::cout<<"CHECK normal_vel_adj2 : "<<'\n'<<normal_vel_adj-normal_vel_adj2<<'\n'<<std::endl;

    // MATRIX Dij CALCULATION:
    // normval_vel and the adjoint one are already absolute value

    //SparseMatrix<T> normal_vel_abs = normal_vel.cwiseAbs() ;  // o lambda_max=normal_vel ?
    //SparseMatrix<T> normal_vel_abs_adj = normal_vel_adj.cwiseAbs();// o lambda_max=normal_vel?


    /// POSSO SCEGLIERE SE METTERE normal_vel_abs_bis O normal_vel !!!!!!!!!!!!!!!!
    //std::cout<<bold<<yellow<<"--->  sto usando normal_vel_abs_bis, i.e. con max su u(pt)!!"<<reset<<std::endl;
     std::cout<<bold<<yellow<<"--->  sto usando normal_vel, i.e. con max su u*n !!" <<reset<<std::endl;


    //SparseMatrix<T> lambda_max = normal_vel_abs_bis.cwiseProduct( cij_norm );
    //SparseMatrix<T> lambda_max_adj = normal_vel_abs_adj_bis.cwiseProduct( cji_norm );
    SparseMatrix<T> lambda_max = normal_vel.cwiseProduct( cij_norm );
    SparseMatrix<T> lambda_max_adj = normal_vel_adj.cwiseProduct( cji_norm );


    SparseMatrix<T> dij = lambda_max.cwiseMax(lambda_max_adj);
    //SparseMatrix<T> dij2 = lambda_max.cwiseMax(lambda_max_adj);

    for(size_t i = 0 ; i < dij.rows() ; i++)
    {
        dij.coeffRef(i,i) = 0;
        dij.coeffRef(i,i) = -dij.row(i).sum();
    }
    //std::cout<<"dij-dij2"<<'\n'<<dij-dij2<<std::endl;

    // CHECK TIME STEP dt
    T dt_old = dt ;
    std::cout<<bold<<yellow<<"---> COND IN TEMPO CFL, ALEXANDRE BOOK"<<reset<<std::endl;
    T CFL_numb = time_step_CFL_L2_velocity_NEW( dij.diagonal() , global_lumped_mass , fe_data.Dirichlet_boundary , dt );

    //T nu_max0 = CFL_numb/fe_data.hx;
    //T nu0 = dt_old/fe_data.hx;
    //T nu1 = dt/fe_data.hx;

    //std::cout<<"VALID FOR u = (1,0). nu_max VERO = "<<nu_max0<<" , nu max con dt assegnato = "<<nu0<< " and with dt appeared by CFL COND "<<nu1<<std::endl;
    //T nu_max = dt/fe_data.hx;
    //std::cout<<"VALID FOR u = (1,0). nu_max = "<<nu_max<<std::endl;
    if(dt_old != dt )
    {
        std::cout<<"dt is "<<dt_old<<" and dt CFL is "<<dt<<" . STOP!"<<std::endl;
        exit(10);
    }




    // CONSTANT TERM (PHI TILDE PROBLEM)
    //Matrix<T,Dynamic,1> vec2 = Matrix<T, Dynamic, 1>::Zero(dim) ;
    //averaged_sum_Si_SPARSE(S_i , global_cij_x , flux0 , vec2);
    //averaged_sum_Si_SPARSE(S_i , global_cij_y , flux1 , vec2);

    //std::cout<<"CHECK phi TILDE "<<'\n'<<conv_global-vec2<<'\n'<<"FINE PHI TILDE CHECKING"<<std::endl;
    Matrix<T, Dynamic, 1> b = mass_phi_old - dt*conv_global.cwiseQuotient(global_lumped_mass);
    //std::cout<<"TERMINE NOTO:b  "<<'\n'<<b<<std::endl;

    // RESOLUTION OF PHI_TILDE
    phi_tilde.sol_FEM = solver_global_mass.solve(b); // SAVE THE L2 projection

    //auto prova_phi_tilde = solver2.solve(b);
    //std::cout<<"phi_tilde.sol_FEM  "<<'\n'<<phi_tilde.sol_FEM <<std::endl;

    //std::cout<<"phi_tilde.sol_FEM - prova_phi_tilde "<<'\n'<<phi_tilde.sol_FEM - prova_phi_tilde <<std::endl;


    if(solver_global_mass.info()!=Success) {
        std::cout<<"FAILED SOLVER 1->phi_tilde"<<std::endl;
        exit(1);
    }

    // SAVING BOTH SOL_HHO AND VERTICES OF PHI_TILDE
    std::cout<<"CONVERTING phi_tilde"<<std::endl;
    phi_tilde.converting_into_HHO_formulation( phi_tilde.sol_FEM );



    // TERM R_i^n
    Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Emax_global *= -1e20;
    Emin_global *= 1e20;
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    for( auto& cl: msh.cells )
        r_i_calculator_Bernstein( msh , cl , E , phi_tilde , phi , dt , u , Emax_global , Emin_global , R_i);

    // R_i FINALISATION:
    //std::cout<<"Emax_global: "<<'\n'<<Emax_global<<std::endl;
    //std::cout<<"Emin_global: "<<'\n'<<Emin_global<<std::endl;
    R_i = R_i.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    //std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;



    // ENTROPIC SOLUTION: MINIMUM BETWEEN d_ij AND R_i --> d^E_ij MATRIX
    T c_e = 1.0;
    SparseMatrix<T> dE_ij  = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_dE_ij;
    SparseMatrix<T> phi_ij = SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_phi_ij;


    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {

            if(elem!=counter)
            {
                auto R_i_j = c_e * std::max(std::abs( R_i(counter) ) , std::abs( R_i(elem) ));
                auto value = std::min( dij.coeff( counter , elem ), R_i_j );
                triplets_dE_ij.push_back( Triplet<T>(counter, elem, value ) );
            //dE_ij( counter_row , elem ) = std::min( dij( counter_row , elem ), R_i_j );
            //std::cout<<"R_i_j "<<R_i_j<<" and dij"<<dij( counter_row , elem )<<std::endl;
            }
            auto value_bis = 0.5*( phi_FEM(counter) + phi_FEM(elem) );
            triplets_phi_ij.push_back( Triplet<T>(counter, elem, value_bis ) );


        }
        counter++;
    }

    //std::cout<<"term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy<<std::endl;

    dE_ij.setFromTriplets( triplets_dE_ij.begin(), triplets_dE_ij.end() );
    triplets_dE_ij.clear();
    phi_ij.setFromTriplets( triplets_phi_ij.begin(), triplets_phi_ij.end() );
    triplets_phi_ij.clear();

    //std::cout<<"dE_ij: "<<'\n'<<dE_ij<<std::endl;

    // MATRIX d^C_ij

    T c_comp = 1.0;
    SparseMatrix<T> tmp0 = phi_ij - phi_ij.cwiseProduct(phi_ij);
    //std::cout<<"tmp0 "<<'\n'<<tmp0<<std::endl;
    positive_part_SPARSE( tmp0 );
    //std::cout<<"tmp0 POSITIVE "<<'\n'<<tmp0<<std::endl;

    SparseMatrix<T> tmp_dC1 =  SparseMatrix<T>( dim , dim );
    std::vector< Triplet<T> >   triplets_tmp_dC1;
    SparseMatrix<T> Mat_One =  SparseMatrix<T>( dim , dim );
    //Matrix<T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones( dim, dim );
    std::vector< Triplet<T> >   triplets_1;

    size_t counter_tmp = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
           // std::cout<<"In ("<<counter<<" , "<<elem<<") tmp_dC0 = "<<tmp_dC0(counter,elem)<<" and phi.ver diff "<<std::abs(phi.vertices(counter) - phi.vertices(elem))<<std::endl;
            if( std::abs(phi_FEM(counter_tmp) - phi_FEM(elem))>1e-15 ){
                auto value = tmp0.coeff(counter_tmp,elem)/( std::abs(phi_FEM(counter_tmp) - phi_FEM(elem)) );
                triplets_tmp_dC1.push_back( Triplet<T>(counter_tmp, elem, value ) );
                triplets_1.push_back( Triplet<T>(counter_tmp, elem, 1.0 ) );
            }
            //tmp_dC1(counter_tmp,elem) = tmp0(counter_tmp,elem)/( std::abs(sol_FEM(counter_tmp) - sol_FEM(elem)) );
        }
        counter_tmp++;
    }
    tmp_dC1.setFromTriplets( triplets_tmp_dC1.begin(), triplets_tmp_dC1.end() );
    triplets_tmp_dC1.clear();


    Mat_One.setFromTriplets( triplets_1.begin(), triplets_1.end() );


    Matrix<T , Dynamic , Dynamic > Mat1 = Eigen::Matrix<T, Dynamic, Dynamic>::Ones(dim, dim);
    Matrix<T , Dynamic , Dynamic > tmp1_bis = Mat1 - c_comp*tmp_dC1;
    positive_part( tmp1_bis );
    Matrix<T , Dynamic , Dynamic > dC_ij_bis = dE_ij.cwiseProduct(tmp1_bis) ;



    //std::cout<<'\n'<<"tmp_dC1: "<<'\n'<<tmp_dC1<<std::endl;
    SparseMatrix<T> tmp1 = Mat_One - c_comp*tmp_dC1;

    //Matrix<T, Dynamic, Dynamic> tmp1 = Mat_One - c_comp*tmp_dC1;
    //positive_part( tmp1  );
    //SparseMatrix<T> dC_ij = SparseMatrix<T>( dim , dim );
    //size_t counter_prova = 0;
    //for(auto& row_i:S_i)
    //{
     //   for(auto& elem:row_i)
     //   {
     //       dC_ij.coeffRef(counter_prova,elem) += ( dE_ij.coeff(counter_prova,elem)*tmp1(counter_prova,elem) );
     //   }
      //  counter_prova++;
    //}



    //std::cout<<'\n'<<"tmp1: "<<'\n'<<tmp1<<std::endl;
    positive_part_SPARSE( tmp1  );

    SparseMatrix<T> dC_ij = dE_ij.cwiseProduct(tmp1) ;

    /*
    SparseMatrix<T> dC_ij_prova = dC_ij ;
    // NON SONO SICURO SERVA STA COSA
    std::cout<<"CHECK IF SERVE L'IMPOSIZIONE PER L'ELEMENTO DIAGONALE = SOMMA RIGA PER VARI d^I_ij!!!!"<<std::endl;
    for(size_t i = 0 ; i < dC_ij.rows() ; i++)
    {
        dC_ij.coeffRef(i,i) = 0.;
        dij.coeffRef(i,i) = 0.;
        dC_ij.coeffRef(i,i) = -dC_ij.row(i).sum();
        dij.coeffRef(i,i) = -dij.row(i).sum();
    }

    std::cout<<'\n'<<"dC_ij_prova - dC_ij: "<<'\n'<<dC_ij_prova - dC_ij<<std::endl;
    */

    // ARTIFICIAL VISCOSITY TERM d_ij * (phi_j-phi_i)

    Matrix<T, Dynamic, 1> term_dij_no_entropy =  Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij_E            =  Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    Matrix<T, Dynamic, 1> term_dij            =  Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    //Matrix<T, Dynamic, 1> term_dij_bis =  Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);

    size_t counter_dij = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
             // TERM d_ij * (phi_j-phi_i)
            term_dij_no_entropy(counter_dij) += dij.coeff(counter_dij,elem)*(phi_FEM(elem)-phi_FEM(counter_dij));
             // TERM dC_ij * (phi_j-phi_i)
            term_dij(counter_dij) += dC_ij.coeff(counter_dij,elem)*(phi_FEM(elem)-phi_FEM(counter_dij));
            term_dij_E(counter_dij) += dE_ij.coeff(counter_dij,elem)*(phi_FEM(elem)-phi_FEM(counter_dij));

            //term_dij_bis(counter_dij) += dC_ij_bis.coeff(counter_dij,elem)*(phi_FEM(elem)-phi_FEM(counter_dij));
        }
        counter_dij++;
    }

    //std::cout<<"term_dij_bis - term_dij"<<'\n'<<term_dij_bis - term_dij<<std::endl;

    // FOR CHECKING
    //std::cout<<"CHECK term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy - term_dij<<std::endl;

    //std::cout<<"CHECK term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy - term_dij_no_entropy2<<std::endl;

    //Matrix<T, Dynamic, 1> term_dij_no_entropy2 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1 );
    //term_dij_no_entropy2 = dij * phi_FEM ;

    //Matrix<T, Dynamic, 1> term_dij2 = dC_ij * phi_FEM ;
    //std::cout<<"CHECK term_dij2 : "<<'\n'<<term_dij2 - term_dij<<std::endl;

    //std::cout<<"CHECK term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy - term_dij_no_entropy2<<std::endl;



    /// MATRIX D_IJ CHECKING
    /*
     //The  error is < 1e-15, at max
    std::cout<<"D_ij check: "<<std::endl;
    for(size_t i = 0; i<lambda_max.rows();i++){
        for(size_t j = i+1; j<lambda_max.rows();j++){
            if(std::abs(dij.coeff(i,j)-dij.coeff(j,i))>1e-15)
            std::cout<<dij.coeff(i,j)-dij.coeff(j,i);
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;


     std::cout<<'\n'<<"dij: "<<'\n'<<dij<<std::endl;

    std::cout<<"D_ij check symmetry "<<std::endl;
    for(size_t counter_row = 0 ; counter_row < global_cij_x.rows() ; counter_row++ )
    {

        for(size_t elem = 0 ; elem < global_cij_x.cols() ; elem++)
        {
            std::cout<<dij.coeff(counter_row,elem) - dij.coeff(elem,counter_row)<<std::endl;
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */

    /// TERM D_IJ*(PHI_J-PHI_I)  CHECKING
    /*
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    for(size_t i = 0 ; i < dij.rows() ; i++)
    {
        for(size_t j = 0 ; j < dij.cols() ; j++)
        {
            term_dij_no_entropy.coeffRef(i) += dij.coeff(i,j) * ( phi_FEM(j)-phi_FEM(i) ) ;
        }
    }
    */

    ///********* RESOLUTION OF THE SYSTEM: **********//


    // RESOLUTION FIRST ORDER
    Matrix<T, Dynamic, 1> phi_L = phi_FEM - dt * conv_global.cwiseQuotient(global_lumped_mass)  + dt * term_dij_no_entropy.cwiseQuotient(global_lumped_mass);

    //std::cout<<'\n'<<"phi_L : "<<'\n'<<phi_L<<std::endl;


    // RESOLUTION HIGH ORDER -> NO MIN MAX PRINCIPLE PRESERVING
    Matrix<T, Dynamic, 1> b_phiH = mass_phi_old - dt * conv_global + dt * term_dij ;
    Matrix<T, Dynamic, 1> phi_H = solver_global_mass.solve(b_phiH);

    Matrix<T, Dynamic, 1> b_phiE = mass_phi_old - dt * conv_global + dt * term_dij_E ;
    Matrix<T, Dynamic, 1> phi_E = solver_global_mass.solve(b_phiE);


    // CHECKING OF phi_h AND phi_l
    //Matrix<T, Dynamic, 1> check0 = global_lumped_mass.cwiseProduct( (phi_L - phi_FEM)/dt ) + conv_global - term_dij_no_entropy;
    //std::cout<<'\n'<<"CHECK phi_L is "<<'\n'<<check0<<std::endl;

    //Matrix<T, Dynamic, 1> check1 = global_mass*( (phi_H - phi_FEM)/dt ) + conv_global - term_dij;
    //std::cout<<'\n'<<"CHECK phi_H is "<<'\n'<<check1<<std::endl;


    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi_FEM;
    //std::cout<<'\n'<<"delta_phi "<<'\n'<<delta_phi<<std::endl;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi_FEM , S_i );

    // CHECKING PHI
    /*
    auto check_phi = phi_H - phi_L - f_i.cwiseQuotient(global_lumped_mass) ;//+dt*Vec_One ;

    Matrix<T, Dynamic, 1>  phi_H2 = phi_L + f_i.cwiseQuotient(global_lumped_mass);

    std::cout<<'\n'<<"check phi "<<'\n'<<check_phi<<std::endl;
    std::cout<<'\n'<<"check phi_h: "<<'\n'<<phi_H - phi_H2<<std::endl;
    */


    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator_SPARSE( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi_FEM , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);




    // IMPOSITION DIRICHLET BOUNDARY CONDITIONS
    size_t counter_dir = 0 ;
    for (const auto& dir_elem : fe_data.Dirichlet_boundary )
    {
        if(dir_elem){
            phi_L(counter_dir) = phi_FEM(counter_dir) ;
            phi_H(counter_dir) = phi_FEM(counter_dir) ;
            phi_new(counter_dir) = phi_FEM(counter_dir) ;
            phi_E(counter_dir) = phi_FEM(counter_dir) ;
        }
        counter_dir++ ;
    }


    //std::cout<<"phi_L - phi_H"<<'\n'<<phi_L - phi_H<<'\n'<<'\n'<<'\n'<<std::endl;
    //std::cout<<"phi_L - phi_new"<<'\n'<<phi_L - phi_new<<'\n'<<'\n'<<'\n'<<std::endl;
    //std::cout<<"phi_H - phi_new"<<'\n'<<phi_H - phi_new<<'\n'<<'\n'<<'\n'<<std::endl;



    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;





    /// PLOTTING SOLUTION (GNUPLOT) + SAVING FOR HHO (MISCHIATO PER POTERE PLOTTARE ENTRAMBE).
    postprocess_output<double> postoutput5;
    auto test_phi_h = std::make_shared< gnuplot_output_object<double> >("phi_h.dat");
    auto test_phi_l = std::make_shared< gnuplot_output_object<double> >("phi_l.dat");
    auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");

    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set

   /*


    phi.sol_FEM = phi_L ;

    std::cout<<"USING LOW ORDER SOLUTION PHI_L. Also vertices uploading."<<std::endl;
    //phi.converting_into_HHO_formulation(phi_L);
    phi.converting_into_HHO_formulation(phi_L);
    //std::cout<<"phi max "<<phi.sol_FEM.maxCoeff()<<'\n';
    //std::cout<<"phi min "<<phi.sol_FEM.minCoeff()<<'\n';
    //std::cout<<"SAVED phi max "<<phi.phi_max<<'\n';
    //std::cout<<"SAVED phi min "<<phi.phi_min<<std::endl;

    phi.coefficients_inverse_mapping();
    //std::cout<<"phi max "<<phi.sol_FEM.maxCoeff()<<'\n';
    //std::cout<<"phi min "<<phi.sol_FEM.minCoeff()<<'\n';
    //std::cout<<"SAVED phi max "<<phi.phi_max<<'\n';
    //std::cout<<"SAVED phi min "<<phi.phi_min<<std::endl;

    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM
    //std::cout<<"phi max "<<phi.sol_FEM.maxCoeff()<<'\n';
    //std::cout<<"phi min "<<phi.sol_FEM.minCoeff()<<'\n';
    //std::cout<<"SAVED phi max "<<phi.phi_max<<'\n';
    //std::cout<<"SAVED phi min "<<phi.phi_min<<std::endl;

    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_l->add_data( pt ,phi(pt, msh , cl ) );
        }
    }

     */

    /*



    phi.sol_FEM = phi_E ;

    std::cout<<"CONVERTING phi_E in HHO formulation. Also vertices uploading."<<std::endl;
    phi.converting_into_HHO_formulation(phi_E);


    phi.coefficients_inverse_mapping();
    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM





    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_H ;


    std::cout<<"CONVERTING phi_L in HHO formulation. Also vertices uploading."<<std::endl;
    //phi.converting_into_HHO_formulation(phi_L);
    phi.converting_into_HHO_formulation(phi_H);


    phi.coefficients_inverse_mapping();
    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM

    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            test_phi_h->add_data( pt ,phi(pt, msh , cl ) );
        }
    }


     */


    // SAVING AND UPLOAD phi_L  INTO CLASS projected_level_set
    phi.sol_FEM = phi_new ;

    std::cout<<"USING HIGH ORDER SOLUTION PHI_HP. Also vertices uploading."<<std::endl;
    //phi.converting_into_HHO_formulation(phi_L);
    phi.converting_into_HHO_formulation(phi_new);


    phi.coefficients_inverse_mapping();
    //phi.set_max_min(); // SETTING OF THE NEW MAX AND MIN FOR NEXT TRANSPORT PROBLEM




    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            //test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_new->add_data( pt , phi(pt, msh , cl ) );
        }
    }



    /// PLOTTING SOLUTION (GNUPLOT)
    /*
    postprocess_output<double> postoutput5;
    auto test_phi_h = std::make_shared< gnuplot_output_object<double> >("phi_h.dat");
    auto test_phi_l = std::make_shared< gnuplot_output_object<double> >("phi_l.dat");
    //auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");

    size_t counter_cl = 0;
    for(auto& cl :msh.cells)
    {
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, degree );
        size_t iii = 0;
        for (auto pt : pts){
            //std::cout<<pt<<std::endl;
            test_phi_h->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            test_phi_l->add_data( pt , phi.sol_HHO(iii , counter_cl ) );
            iii++;
        }
        counter_cl++;
    }
     */
    postoutput5.add_object(test_phi_h);
    postoutput5.add_object(test_phi_l);
    postoutput5.add_object(test_phi_new);
    postoutput5.write();

    std::cout<<yellow<<bold<<"----------- FINE TRANSPORT PROBLEM -----------"<<reset<<std::endl;

    //return phi_tilde;

}







template < typename Fonction, typename Mesh, typename Vel_Field , typename T = typename Mesh::coordinate_type >
void run_FEM_levelset(const Mesh & msh, size_t degree, Fonction & phi, const Vel_Field & u , const T& dt , const mesh_init_params<T>& params)
{
    timecounter tc;
    tc.tic();
    //size_t ndof = ( degree+1 ) * ( degree+1 ) ; // degrees of freedom
    const T eps = 1e-14; //constant into entropy

    // LOCAL MASS MATRIX ==> CHECK DEGREE == 1!!!
    assert(degree==1);


    mapping_phi(phi , phi.phi_max , phi.phi_min ); // mapping of phi to  have a phi between 0 and 1
    /// PHI MAPPED INTO 0-1 PLOT
    /*
    postprocess_output<double> postoutput4;
    auto test_phi_mapped = std::make_shared< gnuplot_output_object<double> >("phi_mapped.dat");
    for (auto cl:msh.cells) {
        auto pts = points(msh,cl) ;
        for (auto pt:pts) {
            T value = phi(pt,msh,cl);
            test_phi_mapped->add_data(pt,value);
        }
    }
    postoutput4.add_object(test_phi_mapped);
    postoutput4.write();
    */

    // ENTROPY -> for phi with codomain in (0,1)
    non_linear_entropy<T,Fonction,Mesh> E(eps , phi ,msh );
    auto phi_tilde = projection<T,Mesh> ( msh, degree , params );

    /// ENTROPY PLOT
    /*
    postprocess_output<double> postoutput6;
    auto cut_entropy = std::make_shared< gnuplot_output_object<double> >("entropy.dat");
    for (auto cl:msh.cells) {
        auto pts = points(msh,cl) ;
        for (auto pt:pts) {
            T value = E(pt,cl);
            cut_entropy->add_data(pt,value);
        }
    }
    postoutput6.add_object(cut_entropy);
    postoutput6.write();
    */

    // Global Matrix and Global Vector Definitions:
    size_t dim = msh.nodes.size();
    // Lumped mass vector
    Matrix<T, Dynamic, 1> global_lumped_mass = Eigen::Matrix<T, Dynamic, 1>::Zero( dim, 1 );
    // Mass matrix
    Matrix<T, Dynamic, Dynamic> global_mass = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim );
    // C_ij,1 matrix
    Matrix<T, Dynamic, Dynamic> global_cij_x = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim );
    // C_ij,2 matrix
    Matrix<T, Dynamic, Dynamic> global_cij_y = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim );
    // Convection term (vector)
    Matrix<T, Dynamic, 1> conv_global = Eigen::Matrix<T, Dynamic, 1>::Zero( dim, 1 );
    // D_ij term (vector)
    Matrix<T, Dynamic, 1> term_dij = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1 );
    // N_ij matrix
    std::pair<Matrix<T, Dynamic, Dynamic>,Matrix<T, Dynamic, Dynamic>> nij = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim ) , Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim ) ) ;
    // N_ji matrix
    std::pair<Matrix<T, Dynamic, Dynamic>,Matrix<T, Dynamic, Dynamic>> nij_transpose = std::make_pair(Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim ) , Eigen::Matrix<T, Dynamic, Dynamic>::Zero( dim, dim ) ) ;
    // ||c_ij||^2
    Matrix<T, Dynamic, Dynamic> cij_square = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    // ||c_ji||^2
    Matrix<T, Dynamic, Dynamic> cji_square = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);

    // One vector
    Matrix<T, Dynamic, 1> Vec_One = Eigen::Matrix<T, Dynamic, 1>::Ones( dim, 1 );
    // One matrix
    Matrix<T, Dynamic, Dynamic> Mat_One = Eigen::Matrix<T, Dynamic, Dynamic>::Ones( dim, dim );


    // Boundary Nodes = Vertices (in Q1)
    auto bdry_nodes = boundary_nodes_function( phi.Nx , phi.Ny );


    // The Support of Global Shape Function: list of neighborood nodes for each node i
    std::vector<std::set<size_t>> S_i(dim);
    timecounter tc1;
    tc1.tic();
    for (auto cl : msh.cells)
    {


        auto nodes_position = nodes(msh, cl); // node_pos.ptid to have just the number

        // In basis (mesh creation) the order is
        /// 2 - - 3
        /// |       |
        /// 0 - - 1

        // In nodes position instead the order is
        /// 3 - - 2
        /// |       |
        /// 0 - - 1
        // I swap last two elements to have the first ordering
        iter_swap(nodes_position.end()-1 , nodes_position.end()-2 );

        // Support of global shape function: list of close nodes for each node i
        supporting_nodes( S_i , nodes_position );

        /*
        // CALCULATION OF THE SIZE + PLOTTING
        size_t size_supp_nodes = 0;
        std::cout<<"Supporting nodes:"<<std::endl;
        size_t jjjj = 0;
        for (auto& i:S_i) {
            size_supp_nodes+=i.size();
            std::cout <<"Node "<<jjjj<<":";
            for (auto it=i.begin(); it != i.end(); ++it)
                std::cout << ' ' << *it;
               // std::cout<<ii;
            std::cout<<'\n';
            jjjj++;
        }
        std::cout<<std::endl;
        std::cout<<"Supporting nodes size:"<<size_supp_nodes<<std::endl;
        */


        // Local mass matrix
        Matrix<T, Dynamic, Dynamic> mass = make_lagrange_local_mass_matrix(msh, cl, degree);

        // Assembling into global matrix
        //global_update2( mass , global_mass , nodes_position2 );
        global_update( mass , global_mass , nodes_position );

        // Local c_ij = b_i nabla(b_j)
        auto cij = make_local_cij_matrix(msh, cl, degree);

        // Assembling into global matrix
        global_update( cij.first , global_cij_x , nodes_position );
        global_update( cij.second , global_cij_y , nodes_position );

    // USEFUL COMMAND FOR NORMS of a Eigen::matrix A:
    // A.template lpNorm<2>()
    // A.norm()

    }

    // LUMPED MASS VECTOR (i.e. vector = diagonal of a matrix)
    sum_Si(S_i, global_mass , Vec_One , global_lumped_mass );



    // CHECKING OF MASS MATRICES' PROPERTIES-> OK, perfect precision 1e-19
    /*
    std::cout<<"First checking: Lumped Mass"<<std::endl;
    for(size_t i = 0; i<global_lumped_mass.rows();i++)
        if(global_lumped_mass(i)<0)
            std::cout<<"PROBLEM into lumped mass"<<std::endl;

    Matrix<T, Dynamic, Dynamic> mass_check = - global_mass;
    for(size_t i = 0 ; i < mass_check.rows() ; i++){
        mass_check(i,i) += global_lumped_mass(i);
        std::cout<<(mass_check.row(i)).sum()<<std::endl;
    }
    */



    /// CHECK OF THE SUM PROPERTY OF CIJ
    /*
     Matrix<T, Dynamic, 1> sum0 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);
     Matrix<T, Dynamic, 1> sum1 = Eigen::Matrix<T, Dynamic, 1>::Zero(global_cij_x.rows(), 1);

    for (size_t k = 0; k<global_cij_x.cols(); k++)
    {
        sum0 += (global_cij_x).col(k);
        sum1 += (global_cij_y).col(k);
    }

    for (size_t i=0; i<global_cij_y.rows(); i++) {
         std::cout<<"The sum is "<<sum1(i)<<" and "<<sum0(i)<<std::endl;
    }

    size_t counter_sum = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
           sum0( counter_sum ) += global_cij_x( counter_sum , elem );
           sum1( counter_sum ) += global_cij_y( counter_sum , elem );
           if(elem==counter_sum)
               std::cout<<"In ("<<counter_sum<<" , "<<elem<<" ), c^0 = "<<global_cij_x( counter_sum , elem )<<" and c1 = "<<global_cij_y( counter_sum , elem )<<std::endl;
           else
                std::cout<<"In ("<<counter_sum<<" , "<<elem<<" ), c^0_ij + c^0_ji = "<<global_cij_x( counter_sum , elem ) + global_cij_x( elem , counter_sum )<<" and c^1_ij + c^1_ji = "<<global_cij_y( counter_sum , elem ) + global_cij_y( elem , counter_sum ) <<std::endl;
        }
        counter_sum++;
    }
    //std::cout<<"The sum0 is "<<'\n'<<sum0<<" and sum1 "<<'\n'<<sum1<<std::endl;
    */



    // FLUX TERM
    Matrix<T, Dynamic, 1> flux0 = (u.vertices.first).cwiseProduct(phi.vertices) ;
    Matrix<T, Dynamic, 1> flux1 = (u.vertices.second).cwiseProduct(phi.vertices) ;



    // RESOLUTION OF phi_tilde GLOBALE     ( with cij(phi_j - phi_i) )

    Matrix<T, Dynamic, 1> vec1 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    sum_Si(S_i , global_mass , phi.vertices , vec1);

    Matrix<T, Dynamic, 1> vec2 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    //Matrix<T, Dynamic, 1> vec2_bis = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    averaged_sum_Si(S_i , global_cij_x , flux0 , vec2);
    averaged_sum_Si(S_i , global_cij_y , flux1 , vec2);
    //sum_Si(S_i , global_cij_x , flux0 , vec2_bis);
    //sum_Si(S_i , global_cij_y , flux1 , vec2_bis);
    //std::cout<<"diff vec 2 = "<<'\n'<<vec2-vec2_bis<<std::endl;
    /// THERE IS A DIFFERENCE OF  <1E-18 DEPENDING IF I CONSIDER OR NOT THE AVERAGED SUM

    Matrix<T, Dynamic, 1> b = vec1 - dt*vec2.cwiseQuotient(global_lumped_mass);

    /// OLD IMPLEMENTATION
    //Matrix<T, Dynamic, 1> prova_FAST = global_mass.completeOrthogonalDecomposition().solve(b);
    //phi_tilde.vertices = global_mass.HouseholderQR().solve(b);
    timecounter tc00;
    tc00.tic();
    LLT<Matrix<T, Dynamic, Dynamic > > llt( global_mass );
    phi_tilde.vertices = llt.solve(b);
    tc00.toc();


    if (llt.info() != Success)
    {
        std::cout<<"not positive"<<std::endl;
        assert(0);
    }
    //std::cout<<"ERRORE FAST= "<<'\n'<<phi_tilde.vertices - prova_FAST <<std::endl;

    phi_tilde.converting_into_HHO_formulation( phi_tilde.vertices );
    std::cout << bold << yellow << "LLT RESOLUTION TIME: " << tc00 << " seconds" << reset << std::endl;


    //std::cout<<"phi_tilde= "<<'\n'<<phi_tilde.vertices<<std::endl;
    /*
    postprocess_output<double> postoutput3;
    typedef typename Mesh::point_type       point_type;
    point<double,2> node;
    auto test_phi_tilde = std::make_shared< gnuplot_output_object<double> >("phi_tilde.dat");
    for (size_t i = 0; i<phi_tilde.vertices.rows(); i++) {
        node = msh.points.at(i);
        test_phi_tilde->add_data(node,phi_tilde.vertices(i));
    }
    postoutput3.add_object(test_phi_tilde);
    postoutput3.write();
    */


    // Term R_i^n
    Matrix<T, Dynamic, 1> Emax_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Matrix<T, Dynamic, 1> Emin_global = Eigen::Matrix<T, Dynamic, 1>::Ones(dim, 1);
    Emax_global *= -1e20;
    Emin_global *= 1e20;
    Matrix<T, Dynamic, 1> R_i = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    for( auto& cl: msh.cells )
    {
        r_i_calculator( msh , cl , E , phi_tilde , phi , dt , u ,S_i , Emax_global , Emin_global , R_i);
    }
    //std::cout<<"Emax_global - Emin_global = "<<'\n'<<Emax_global-Emin_global<<std::endl;
    R_i = R_i.cwiseQuotient( Emax_global - Emin_global );
    //std::cout<<"Ri = "<<'\n'<<R_i<<std::endl;



    // CONVOLUTION TERM
    //sum_Si(S_i, global_cij_x , flux0 , conv_global );
    //sum_Si(S_i, global_cij_y , flux1 , conv_global );
    averaged_sum_Si(S_i, global_cij_x , flux0 , conv_global );
    averaged_sum_Si(S_i, global_cij_y , flux1 , conv_global );
    // OLD IMPLEMENTATION
    //auto conv_global2 = global_cij_x*( flux0 ) + global_cij_y*( flux1 ) ;

    // Norm of c_ij
    moltiplication_Si( S_i , global_cij_x , global_cij_x , cij_square );
    moltiplication_Si( S_i , global_cij_y , global_cij_y , cij_square );
    Matrix<T, Dynamic, Dynamic> cij_norm = cij_square.cwiseSqrt();

    // Matrix n_ij
    division_Si( S_i , global_cij_x , cij_norm , nij.first );
    division_Si( S_i , global_cij_y , cij_norm , nij.second );
    // OLD IMPLEMENTATION
    //auto nij2 = std::make_pair( global_cij_x.cwiseQuotient(cij_norm) , (global_cij_y).cwiseQuotient( cij_norm ) ) ;

    // NOTICE:
    /// Normal Velocity calculation IS EQUIVALENT TO f', that is EQUIVALENT to lambda_r , lambda_l.  Moreover I don't need the calculation of the normal flux. Since then it has to be derived, it is enough to calculate f' = u dot n

    // Normal velocity
    Matrix<T, Dynamic, Dynamic> normal_vel = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    size_t counter_row = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            auto u_max_0 = std::max( u.vertices.first(counter_row),u.vertices.first(elem) );
            auto u_max_1 = std::max( u.vertices.second(counter_row),u.vertices.second(elem) );
            normal_vel(counter_row,elem) = u_max_0 * nij.first(counter_row,elem) + u_max_1*nij.second(counter_row,elem);
        }
        counter_row++;
    }




    // C_ji matrix
    std::pair<Matrix<T, Dynamic, Dynamic>,Matrix<T, Dynamic, Dynamic>> cji_global = std::make_pair(global_cij_x.adjoint() , global_cij_y.adjoint() );

    // Norm of c_ji -> i.e. c_ij transposed
    moltiplication_Si( S_i , cji_global.first , cji_global.first , cji_square );
    moltiplication_Si( S_i , cji_global.second , cji_global.second , cji_square );
    // CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
    //moltiplication_Si_T( S_i , cji_global.first , cji_global.first , cji_square );
    //moltiplication_Si_T( S_i , cji_global.second , cji_global.second , cji_square );

    //C_ji Norm
    Matrix<T, Dynamic, Dynamic> cji_norm = cji_square.cwiseSqrt();
    //auto cji_square2 = (cji_global.first).cwiseProduct(cji_global.first) + (cji_global.second).cwiseProduct(cji_global.second);
    //Matrix<T, Dynamic, Dynamic> cji_norm2 = cji_square2.cwiseSqrt();


    // Matrix n_ij (TRANSPOSED)
    division_Si( S_i , cji_global.first , cji_norm , nij_transpose.first );
    division_Si( S_i , cji_global.second , cji_norm , nij_transpose.second );
     // CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
    //division_Si_T( S_i , cji_global.first , cji_norm , nij_transpose.first );
    //division_Si_T( S_i , cji_global.second , cji_norm , nij_transpose.second );
    //auto  nij_transposex2 = cji_global.first.cwiseQuotient( cji_norm2 );
    //auto  nij_transposey2 = cji_global.second.cwiseQuotient( cji_norm2 );

    // Normal velocity (TRANSPOSED)
    Matrix<T, Dynamic, Dynamic> normal_vel_adj = Eigen::Matrix<T,Dynamic,Dynamic>::Zero(dim, dim);
    //Matrix<T, Dynamic, Dynamic> normal_vel_adj2 = Eigen::Matrix<T,Dynamic,Dynamic>::Zero(dim, dim);
    /*
    for(size_t i = 0 ; i< normal_vel_adj2.rows() ; i++)
    {
        for(size_t j = 0 ; j< normal_vel_adj2.cols() ; j++)
        {
            auto u_max_0 = std::max( u.vertices.first(i),u.vertices.first(j) );
            auto u_max_1 = std::max( u.vertices.second(i),u.vertices.second(j) );
            //normal_vel(counter_row,elem) = u_max_0 * nij.first(counter_row,elem) + u_max_1*nij.second(counter_row,elem);
            // CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
            normal_vel_adj2(i,j) = u_max_0 * nij_transposex2(i,j) + u_max_1*nij_transposey2(i,j);
        }
    }

    */

    counter_row = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            auto u_max_0 = std::max( u.vertices.first(elem),u.vertices.first(counter_row) );
            auto u_max_1 = std::max( u.vertices.second(elem),u.vertices.second(counter_row) );
            //normal_vel_adj(elem,counter_row) = u_max_0 * nij.first(elem,counter_row) + u_max_1*nij.second(elem,counter_row);
            // CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
            normal_vel_adj(counter_row , elem) = u_max_0 * nij_transpose.first(counter_row,elem) + u_max_1*nij_transpose.second(counter_row,elem);
        }
        counter_row++;
    }


    // Matrix Dij calculation
    Matrix<T, Dynamic, Dynamic> lambda_max = normal_vel.cwiseAbs() ;  // o lambda_max=normal_vel ?
    Matrix<T, Dynamic, Dynamic> tmp = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    moltiplication_Si( S_i , lambda_max , cij_norm , tmp );

    Matrix<T, Dynamic, Dynamic> lambda_max_adj=normal_vel_adj.cwiseAbs();// o lambda_max=normal_vel?
    Matrix<T, Dynamic, Dynamic> tmp_adj = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    moltiplication_Si( S_i , lambda_max_adj , cji_norm , tmp_adj );
    // CHECK IF WORKS BETTER NOW (  NO TRANSPOSE )
    //moltiplication_Si_T( S_i , lambda_max_adj , cji_norm , tmp_adj );
    //Matrix<T, Dynamic, Dynamic> lambda_max_adj2=normal_vel_adj2.cwiseAbs();
    //auto tmp_adj2 = lambda_max_adj.cwiseProduct( cji_norm2 ) ;

    Matrix<T, Dynamic, Dynamic> dij = tmp.cwiseMax(tmp_adj);

    //Matrix<T, Dynamic, Dynamic> dij2 = tmp.cwiseMax(tmp_adj2);

    //std::cout<<"Dij: "<<'\n'<<dij<<std::endl;

    /*
      /// The  error is < 1e-15, at max
    std::cout<<"D_ij check: "<<std::endl;
    for(size_t i = 0; i<tmp.rows();i++){
        for(size_t j = i+1; j<tmp.rows();j++){
            if(std::abs(dij(i,j)-dij(j,i))>1e-15)
            std::cout<<dij(i,j)-dij(j,i);
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */


    tc1.toc();
    std::cout << bold << yellow << "Solving time method original: " << tc1 << " seconds" << reset << std::endl;

    timecounter tc2;
    tc2.tic();




    // Minimum between d_ij and R_i
    T c_e = 1.;
    Matrix<T, Dynamic, Dynamic> dE_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    Matrix<T, Dynamic, Dynamic> phi_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    counter_row = 0;

    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            if(elem!=counter_row)
            {
            auto R_i_j = c_e * std::max( std::abs( R_i(counter_row) ) , std::abs( R_i(elem) ) );
            dE_ij( counter_row , elem ) = std::min( dij( counter_row , elem ), R_i_j );
            //std::cout<<"R_i_j "<<R_i_j<<" and dij"<<dij( counter_row , elem )<<std::endl;
            }
            phi_ij( counter_row , elem ) = 0.5*( phi.vertices(counter_row) + phi.vertices(elem) );
        }
        counter_row++;
    }
    //std::cout<<"dE_ij: "<<'\n'<<dE_ij<<std::endl;
    //std::cout<<"phi_ij"<<'\n'<<phi_ij<<std::endl;
    T c_comp = 1.;
    Matrix<T, Dynamic, Dynamic> dC_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);
    Matrix<T, Dynamic, Dynamic> tmp0 = phi_ij - phi_ij.cwiseProduct(phi_ij);
    //Matrix<T, Dynamic, Dynamic> tmp0 = (phi_ij-phi.phi_min*Mat_One).cwiseProduct(phi.phi_max*Mat_One-phi_ij);
    //std::cout<<"tmp0: "<<'\n'<<tmp0<<std::endl;
    positive_part( tmp0 );


   // Matrix<T, Dynamic, Dynamic> tmp_dC0 = positive_part( tmp0 );


    Matrix<T, Dynamic, Dynamic> tmp_dC1 =  Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim, dim);

    size_t counter = 0;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
           // std::cout<<"In ("<<counter<<" , "<<elem<<") tmp_dC0 = "<<tmp_dC0(counter,elem)<<" and phi.ver diff "<<std::abs(phi.vertices(counter) - phi.vertices(elem))<<std::endl;
            if( std::abs(phi.vertices(counter) - phi.vertices(elem))>1e-15 )
            tmp_dC1(counter,elem) = tmp0(counter,elem)/( std::abs(phi.vertices(counter) - phi.vertices(elem)) );
        }
        counter++;
    }
    //std::cout<<'\n'<<"tmp_dC1: "<<'\n'<<tmp_dC1<<std::endl;
    Matrix<T, Dynamic, Dynamic> tmp1 = Mat_One-c_comp*tmp_dC1;

    //std::cout<<'\n'<<"tmp1: "<<'\n'<<tmp1<<std::endl;
    positive_part( tmp1  );
    //std::cout<<'\n'<<"tmp1 POSTIVIVE: "<<'\n'<<tmp1<<std::endl;

    moltiplication_Si( S_i , dE_ij , tmp1 , dC_ij );


    for(size_t i = 0 ; i < dC_ij.rows() ; i++)
    {
        dC_ij(i,i) = 0;
        dij(i,i) = 0;
        dC_ij(i,i) = -dC_ij.row(i).sum();
        dij(i,i) = -dij.row(i).sum();
    }
    //dC_ij = dE_ij.cwiseProduct( positive_part( tmp1  ) );
    //   std::cout<<'\n'<<"dC_ij: "<<'\n'<<dC_ij<<std::endl;
    //   std::cout<<'\n'<<"dij: "<<'\n'<<dij<<std::endl;


    //std::cout<<"dC_ij: "<<'\n'<<dC_ij<<std::endl;


    /*
    counter_row = 0;
    std::cout<<"DC_ij check symmetry: "<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<dC_ij(counter_row,elem) - dC_ij(elem,counter_row)<<std::endl;
        }
        counter_row++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;


    counter_row = 0;
    std::cout<<"D_ij check symmetry "<<std::endl;
    for(auto& row_i:S_i)
    {
        for(auto& elem:row_i)
        {
            std::cout<<dij(counter_row,elem) - dij(elem,counter_row)<<std::endl;
        }
        counter_row++;
        std::cout<<'\n';
    }
    std::cout<<std::endl;
    */


    // Term D_ij(phi_j - phi_i )
    averaged_sum_Si(S_i, dC_ij , phi.vertices , term_dij );
    //std::cout<<"term_dij : "<<'\n'<<term_dij<<std::endl;


    //averaged_sum_Si(S_i, dE_ij , phi.vertices , term_dij );
    Matrix<T, Dynamic, 1> term_dij_no_entropy = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1 );
    // VERSION WITHOUT ENTROPY CORRECTION
    averaged_sum_Si(S_i, dij , phi.vertices , term_dij_no_entropy );

    //std::cout<<"term_dij_no_entropy : "<<'\n'<<term_dij_no_entropy<<std::endl;

    // M*phi^n
    Matrix<T, Dynamic, 1> mass_phi_old = Eigen::Matrix<T, Dynamic, 1>::Zero(dim, 1);
    sum_Si( S_i , global_mass , phi.vertices , mass_phi_old );



  /*
    // **************** OLD IMPLEMENTATION **************** //

   for (size_t i = 0; i<global_lumped_mass.rows(); i++) {
          global_lumped_mass(i) = global_mass.row(i).sum() ;
      }


    Matrix<T, Dynamic, Dynamic> normal_vel2 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim1, dim2);
    Matrix<T, Dynamic, Dynamic> normal_vel_adj2 = Eigen::Matrix<T, Dynamic, Dynamic>::Zero(dim2, dim1);

    //normal velocity
    for (size_t i = 0; i < dim1; i++)
    {
        for (size_t j = 0; j < dim2; j++)
        {
            auto u_max_0 = std::max( u.vertices.first(i),u.vertices.first(j) );
            auto u_max_1 = std::max( u.vertices.second(i),u.vertices.second(j) );
            normal_vel2( i , j ) = u_max_0 * nij.first(i,j) + u_max_1*nij.second(i,j);
            //}
        }

    }

     //normal velocity (transposed)
    auto nij_transpose2 = std::make_pair( ( global_cij_x.transpose() ).cwiseQuotient(cji_norm) ,                                    ( global_cij_y. transpose() ).cwiseQuotient( cji_norm ) ) ;

    for (size_t i = 0; i < dim2; i++)
    {
        for (size_t j = 0; j < dim1; j++)
        {
            auto u_max_0 = std::max( u.vertices.first(i),u.vertices.first(j) );
            auto u_max_1 = std::max( u.vertices.second(i),u.vertices.second(j) );
            normal_vel_adj2( i , j ) = u_max_0 * nij_transpose2.first(i,j) + u_max_1*nij_transpose2.second(i,j);
        }
    }

    Matrix<T, Dynamic, Dynamic> lambda_max2 = normal_vel2.cwiseAbs() ;  // o lambda_max=normal_vel ?
    auto tmp2 = lambda_max2.cwiseProduct( cij_norm ) ;

    Matrix<T, Dynamic, Dynamic> lambda_max_adj2 = normal_vel_adj2.cwiseAbs() ;
    auto tmp_adj2 = lambda_max_adj2.cwiseProduct( cji_norm ) ;

    auto dij2 = tmp2.cwiseMax(tmp_adj2);
    Matrix<T, Dynamic, 1> term_dij2 = Eigen::Matrix<T, Dynamic, 1>::Zero(dim2, 1);
    /// CHECK OUT THE FUNCTION: make_dij_vector
    // auto phi_old = (phi.values_bis).col(counter);
    // auto last_term = make_dij_vector(msh , dij, phi_old );

    for (size_t i = 0; i<dij.rows(); i++)
    {
        auto diff =  phi.vertices - phi.vertices(i)*Vec_One;
        term_dij2(i) = ( dij2.row(i) ).dot( diff )  ;
    }
    std::cout<<"diff term dij: "<<term_dij-term_dij2<<std::endl;

    // ****************END OF OLD IMPLEMENTATION **************** //

 */

    tc2.toc();
    std::cout << bold << yellow << "Solving time method2: " << tc2 << " seconds" << reset << std::endl;


    timecounter tc3;
    tc3.tic();

    ///********* RESOLUTION OF THE SYSTEM: **********//
    //tc.tic();
    Matrix<T, Dynamic, 1> phi_L = solveFEM(global_lumped_mass , conv_global , term_dij_no_entropy , phi.vertices , dt , bdry_nodes); // VERSION WITHOUT ENTROPY CORRECTION
    tc3.toc();
    std::cout << bold << yellow << "Solving time ORIGINAL METHOD: " << tc3 << " seconds" << reset << std::endl;

    timecounter tc4;
    tc4.tic();

     Matrix<T, Dynamic, 1> phi_H = solveFEM_Entropic_FAST(llt , conv_global , term_dij , mass_phi_old , dt );

    //Matrix<T, Dynamic, 1> phi_H = solveFEM_Entropic(global_mass , conv_global , term_dij , mass_phi_old , dt );
     //std::cout<<'\n'<<"phi_H -phi_H_fast : "<<'\n'<<phi_H-phi_H_prova<<std::endl;
    tc4.toc();

    std::cout << bold << yellow << "Solving time CORRECTED METHOD: " << tc4 << " seconds" << reset << std::endl;



    // std::cout<<'\n'<<"phi_L : "<<'\n'<<phi_L<<std::endl;


    // CHECKING phi_h and phi_l
    Matrix<T, Dynamic, 1> zero_vec = Eigen::Matrix<T, Dynamic, 1>::Zero(phi.vertices.rows(), 1);
   // checking_phi_l( global_lumped_mass , global_cij_x , global_cij_y ,dij , phi.vertices ,phi_L,dt, S_i); // NO, DA MODIFICARE

    //checking_phi_lBIS( global_lumped_mass , conv_global , term_dij_no_entropy , phi.vertices , phi_L , dt );

    //checking_phi_h( global_mass , global_cij_x , global_cij_y , dC_ij , phi.vertices  , phi_H ,dt,S_i); // NO, DA MODIFICARE

    //checking_phi_hBIS( global_mass , conv_global , term_dij , phi.vertices , phi_H , dt );






    // EXTENSION: MAXIMUM PRINCIPLE PRESERVING

    Matrix<T, Dynamic, 1> delta_phi = phi_H - phi.vertices;
    //std::cout<<'\n'<<"delta_phi "<<'\n'<<delta_phi<<std::endl;

    Matrix<T, Dynamic, 1> f_i = f_ij_creator( global_lumped_mass , global_mass , delta_phi , dt , dij , dC_ij , phi.vertices , S_i );

    // CHECKING PHI
    auto check_phi = phi_H - phi_L - f_i.cwiseQuotient(global_lumped_mass) ;//+dt*Vec_One ;
    Matrix<T, Dynamic, 1>  phi_H2 = phi_L + f_i.cwiseQuotient(global_lumped_mass);
    //std::cout<<'\n'<<"check phi "<<'\n'<<check_phi<<std::endl;
   // std::cout<<'\n'<<"check phi_h: "<<'\n'<<phi_H - phi_H2<<std::endl;

    // CORRECTION TERM
    Matrix<T, Dynamic, 1> correction_fi = alfaf_ij_creator( global_lumped_mass , global_mass , delta_phi , phi_L , dt , dij , dC_ij , phi.vertices , S_i );
    Matrix<T, Dynamic, 1>  phi_new = phi_L + correction_fi.cwiseQuotient(global_lumped_mass);

    //T check_phi2 = ((phi_new - phi_L).cwiseProduct(global_lumped_mass)).sum();
   // std::cout<<'\n'<<"check PHI_NEW - PHI_L = "<<check_phi2<<std::endl;

    //T check_phi3 = ((phi_new - phi.vertices).cwiseProduct(global_lumped_mass)).sum();
   // std::cout<<'\n'<<"check PHI_NEW - PHI_OLD = "<<check_phi3<<std::endl;

   // T check_phi4 = ((phi_L - phi.vertices).cwiseProduct(global_lumped_mass)).sum();
   // std::cout<<'\n'<<"check PHI_L - PHI_OLD = "<<check_phi4<<std::endl;

    //T check_phi5 = ((phi_H - phi.vertices).cwiseProduct(global_lumped_mass)).sum();
    //std::cout<<'\n'<<"check PHI_H - PHI_OLD = "<<check_phi5<<std::endl;

    //T check_phi6 = ((phi_H - phi_L).cwiseProduct(global_lumped_mass)).sum();
    //std::cout<<'\n'<<"check PHI_H - PHI_L = "<<check_phi6<<std::endl;



    // BOUNDARY CONDITION IMPOSITION -->   NO ENTROPY
    for (auto& j : bdry_nodes )
        phi_L(j) = phi.vertices(j) ;

    // BOUNDARY CONDITION IMPOSITION -> ENTROPIC SOLUTION
    for (auto& j : bdry_nodes )
        phi_H(j) = phi.vertices(j) ;

    // BOUNDARY CONDITION IMPOSITION -> ENTROPIC AND MAX PRESERVING SOLUTION
    for (auto& j : bdry_nodes )
        phi_new(j) = phi.vertices(j) ;


    // SAVING AND UPLOAD phi_new  INTO CLASS projected_level_set
    phi.converting_into_HHO_formulation(phi_new);
    phi.vertices = phi_new;

    // INVERSE MAPPING BACK [0,1] --> [PHI_MIN,PHI_MAX]
    inverse_mapping_phi( phi , phi.phi_max , phi.phi_min );
    tc.toc();
    std::cout << bold << yellow << "FEM method, time resolution: " << tc << " seconds" << reset << std::endl;

    /// PLOTTING SOLUTION (GNUPLOT)
    /*
    postprocess_output<double> postoutput5;
    // auto test_phi_h = std::make_shared< gnuplot_output_object<double> >("phi_h.dat");
    // auto test_phi_l = std::make_shared< gnuplot_output_object<double> >("phi_l.dat");
    auto test_phi_new = std::make_shared< gnuplot_output_object<double> >("phi_new.dat");

    size_t iii = 0;
    for (auto pt : msh.points) {
      //  test_phi_h->add_data(pt,phi_H(iii) );
      //  test_phi_l->add_data(pt,phi_L(iii) );
        test_phi_new->add_data(pt,phi_new(iii) );
        iii++;
    }
    //   postoutput5.add_object(test_phi_h);
    //  postoutput5.add_object(test_phi_l);
    postoutput5.add_object(test_phi_new);
    postoutput5.write();
    */

    std::cout << bold << yellow << "!!ATTENCTION: I'M COMPUTING BOTH phi AND phi_entropic!!" << reset <<std::endl;



    /// COUT OF PHI IN CELLWISE NOTATION
/*
    for (size_t i = 0; i<phi.values_bis.rows(); i++) {
        for (size_t j = 0; j<phi.values_bis.cols(); j++) {
            std::cout<<phi.values_bis(i,j);
        }
        std::cout<<'\n';
    }
    std::cout<<std::endl;
*/



}



template< typename Mesh , typename Fonction , typename T = typename Mesh::coordinate_type ,typename VEC >
void Lp_space_Tfin_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree ,double p , VEC& error )
{
    T errorLp = 0.;
    for(auto& cl : msh.cells)
    {
        auto qps = integrate(msh, cl, 2*degree + 2 );
            for (auto& qp : qps )
            {
                auto diff_val = std::abs( level_set_final( qp.first , msh , cl ) - level_set_initial( qp.first , msh , cl ) );
                errorLp += qp.second * pow(diff_val , p) ;
            }
        //std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    //std::cout<<"The L^"<<p<<" error is "<< pow (errorLp , 1.0/p )<<std::endl;
    error.push_back(pow (errorLp , 1.0/p ));
}



template< typename Mesh , typename Fonction , typename T = typename Mesh::coordinate_type >
void Lp_space_Tfin_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree ,double p )
{
    T errorLp = 0.;
    for(auto& cl : msh.cells)
    {
        auto qps = integrate(msh, cl, 2*degree + 2 );
            for (auto& qp : qps )
            {
                auto diff_val = std::abs( level_set_final( qp.first , msh , cl ) - level_set_initial( qp.first , msh , cl ) );
                errorLp += qp.second * pow(diff_val , p) ;
            }
        //std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    std::cout<<"The L^"<<p<<" error is "<< pow (errorLp , 1.0/p )<<std::endl;
}

template< typename Mesh , typename Fonction , typename T = typename Mesh::coordinate_type >
T Lp_space_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree , double p )
{
    // L^p in space ; l^q in time
    T errorLp = 0.;
    for(auto& cl : msh.cells)
    {
        auto qps = integrate(msh, cl, 2*degree + 2 ); // what orders?
            for (auto& qp : qps )
            {
                auto diff_val = std::abs( level_set_final( qp.first , msh , cl ) - level_set_initial( qp.first , msh , cl ) );
                errorLp += qp.second * pow(diff_val,p) ;
            }
        //std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    errorLp = pow( errorLp , 1.0/ p );
    //std::cout<<"The L^2 error is "<<sqrt( errorL2 )<<std::endl;
    return errorLp ;
}

template< typename Mesh , typename Fonction , typename T = typename Mesh::coordinate_type >
T W1p_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree , double p )
{
    T errorH1 = 0.;
    for(auto& cl : msh.cells)
    {
        auto qps = integrate(msh, cl, 2*degree + 2 ); // what orders?
            for (auto& qp : qps )
            {
                auto diff_val0 = std::abs( level_set_final.gradient( qp.first , msh , cl )(0) - level_set_initial.gradient( qp.first , msh , cl )(0) );
                auto diff_val1 = std::abs( level_set_final.gradient( qp.first , msh , cl )(1) - level_set_initial.gradient( qp.first , msh , cl )(1) );
                errorH1 += qp.second * (pow(diff_val0,p) + pow(diff_val1,p)) ;
            }
        //std::cout<<"The L^2 error squared in cell "<<offset(msh,cl)<<" is "<< errorL2 <<std::endl;
    }
    errorH1 = pow( errorH1 , 1.0/p );
    //std::cout<<"The L^2 error is "<<sqrt( errorL2 )<<std::endl;
    return errorH1 ;
}



template< typename Mesh , typename Fonction , typename T = typename Mesh::coordinate_type >
T Linf_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree )
{
    T errorLinf = ((level_set_final.vertices - level_set_initial.vertices).cwiseAbs()).maxCoeff();
    return errorLinf;

}

template< typename Mesh , typename Fonction , typename T = typename Mesh::coordinate_type >
T W1inf_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree )
{
    T errorLinf0 = 0 , errorLinf1 = 0;

    for(auto& cl : msh.cells)
    {
        auto pts = points(msh,cl);
        for (auto& pt : pts )
        {
            auto diff_val0 = std::abs( level_set_final.gradient( pt , msh , cl )(0) - level_set_initial.gradient( pt , msh , cl )(0) );
            errorLinf0 = std::max(errorLinf0 , diff_val0);
            auto diff_val1 = std::abs( level_set_final.gradient( pt , msh , cl )(1) - level_set_initial.gradient( pt , msh , cl )(1) );
            errorLinf1 = std::max(errorLinf1 , diff_val1);
        }

    }
    return errorLinf0 + errorLinf1;

}


template< typename T , typename VeloField>
T time_step_CFL( const VeloField& u , const mesh_init_params<T>& mip , T eps ){

    auto h_max = std::max(mip.hx() , mip.hy() );
    auto u_max = u.values_bis.first.template lpNorm<Infinity>() + u.values_bis.second.template lpNorm<Infinity>() ;
    if( std::abs(u_max) < 1e-15 )
        return 1e-8;
    else
        return eps*h_max/u_max ;
}

template< typename T , typename VeloField>
T time_step_CFL_new( const VeloField& u , const mesh_init_params<T>& mip ,T eps)
{

    auto h_max = std::max(mip.hx() , mip.hy() );
    auto u_max = u.sol_FEM.first.template lpNorm<Infinity>() + u.sol_FEM.second.template lpNorm<Infinity>() ;
    if( std::abs(u_max) < 1e-15 )
        return 1e-8;
    else
        return eps*h_max/(std::abs(u_max)) ;
}
















/*****************************************************************************
*   PREVIOUS CODE STOKES HHO
*****************************************************************************/



///////////////////////   FICTITIOUS DOMAIN METHODS  ///////////////////////////

template<typename T, size_t ET, typename testType>
class stokes_fictdom_method
{
    using Mat  = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_fictdom_method(bool sym)
        : sym_grad(sym)
        {}

    virtual std::pair< std::pair<Mat,Mat>, std::pair<Vect,Vect> >
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType test_case, const hho_degree_info hdi,
                     const element_location where = element_location::IN_NEGATIVE_SIDE,
                     const params<T>& parms = params<T>())
    {}

public:
    std::pair< std::pair<Mat,Mat>, std::pair<Vect,Vect> >
    make_contrib_uncut(const Mesh& msh, const typename Mesh::cell_type& cl,
                       const hho_degree_info hdi, const testType test_case)
    {
        Mat gr2;
        if(sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = gr2 + stab;
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Vect f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);
        Vect p_rhs = Vect::Zero( dr.first.rows() );
        return std::make_pair( std::make_pair(lc, dr.second) , std::make_pair(f,p_rhs) );
    }


    std::pair< std::pair<Mat,Mat>, std::pair<Vect,Vect> >
    make_contrib(const Mesh& msh, const typename Mesh::cell_type& cl,
                 const testType test_case, const hho_degree_info hdi,
                 const element_location where = element_location::IN_NEGATIVE_SIDE,
                 const params<T>& parms = params<T>())
    {
        if( location(msh, cl) == where )
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else if( location(msh, cl) != element_location::ON_INTERFACE )
        {
            Mat lc;
            Vect f;
            return std::make_pair(std::make_pair(lc, lc) , std::make_pair(f,f) );
        }
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi, where, parms);
    }
};

/////////////////////////  GRADREC_FICTITIOUS_METHOD

template<typename T, size_t ET, typename testType>
class gradrec_stokes_fictdom_method : public stokes_fictdom_method<T, ET, testType>
{
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta;

    gradrec_stokes_fictdom_method(T eta_, bool sym)
        : stokes_fictdom_method<T,ET,testType>(sym), eta(eta_) {}

    std::pair< std::pair<Mat,Mat>, std::pair<Vect,Vect> >
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType test_case, const hho_degree_info hdi,
                     const element_location where = element_location::IN_NEGATIVE_SIDE,
                     const params<T>& parms = params<T>())
    {
        // LHS
        Mat gr1, gr2;
        if( this->sym_grad )
        {
            auto gr = make_hho_gradrec_sym_matrix(msh, cl, test_case.level_set_, hdi, where, 1.0);
            gr1 = gr.first;
            gr2 = gr.second;
        }
        else
        {
            auto gr = make_hho_gradrec_matrix(msh, cl, test_case.level_set_, hdi, where, 1.0);
            gr1 = gr.first;
            gr2 = gr.second;
        }
        Mat stab = make_hho_vector_cut_stabilization(msh, cl, hdi, where)
            + make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta);
        Mat lc = gr2 + stab;
        auto dr = make_hho_divergence_reconstruction(msh, cl, test_case.level_set_,
                                                     hdi, where, 1.0);

        // RHS
        auto celdeg = hdi.cell_degree();
        auto cbs = vector_cell_basis<Mesh,T>::size(celdeg);

        Vect f = Vect::Zero(lc.rows());
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun, where);
        f.block(0, 0, cbs, 1) += make_vector_rhs_penalty(msh, cl, celdeg, test_case.bcs_vel, eta);
        f += make_vector_GR_rhs(msh, cl, celdeg, test_case.bcs_vel, test_case.level_set_,
                                gr1, this->sym_grad);
        auto p_rhs = make_pressure_rhs(msh, cl, hdi.face_degree(), where,
                                       test_case.level_set_, test_case.bcs_vel);

        return std::make_pair(std::make_pair(lc, dr.second), std::make_pair(f,p_rhs) );
    }
};



template<typename T, size_t ET, typename testType>
auto make_gradrec_stokes_fictdom_method(const cuthho_mesh<T, ET>& msh, const T eta_,
                                        const testType test_case, bool sym)
{
    return gradrec_stokes_fictdom_method<T, ET, testType>(eta_, sym);
}

///////////////////////////

template<typename Mesh, typename testType>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_fictdom(const Mesh& msh, size_t degree, testType test_case)
{
    using RealType = typename Mesh::coordinate_type;

    auto level_set_function = test_case.level_set_;

    auto sol_vel = test_case.sol_vel;
    auto vel_grad = test_case.vel_grad;
    auto bcs_fun = test_case.bcs_vel;


    /************** OPEN SILO DATABASE **************/
    silo_database silo;
    silo.create("cuthho_fictdom.silo");
    silo.add_mesh(msh, "mesh");

    /************** MAKE A SILO VARIABLE FOR CELL POSITIONING **************/
    std::vector<RealType> cut_cell_markers;
    for (auto& cl : msh.cells)
    {
        if ( location(msh, cl) == element_location::IN_POSITIVE_SIDE )
            cut_cell_markers.push_back(1.0);
        else if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            cut_cell_markers.push_back(-1.0);
        else if ( location(msh, cl) == element_location::ON_INTERFACE )
            cut_cell_markers.push_back(0.0);
        else
            throw std::logic_error("shouldn't have arrived here...");
    }
    silo.add_variable("mesh", "cut_cells", cut_cell_markers.data(), cut_cell_markers.size(), zonal_variable_t);

    /************** MAKE A SILO VARIABLE FOR LEVEL SET FUNCTION **************/
    std::vector<RealType> level_set_vals;
    for (auto& pt : msh.points)
        level_set_vals.push_back( level_set_function(pt) );
    silo.add_variable("mesh", "level_set", level_set_vals.data(), level_set_vals.size(), nodal_variable_t);

    /************** MAKE A SILO VARIABLE FOR NODE POSITIONING **************/
    std::vector<RealType> node_pos;
    for (auto& n : msh.nodes)
        node_pos.push_back( location(msh, n) == element_location::IN_POSITIVE_SIDE ? +1.0 : -1.0 );
    silo.add_variable("mesh", "node_pos", node_pos.data(), node_pos.size(), nodal_variable_t);


    timecounter tc;

    bool sc = true; // static condensation

    /************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree+1, degree);

    element_location where = element_location::IN_NEGATIVE_SIDE;

    tc.tic();
    auto assembler = make_stokes_fict_assembler(msh, bcs_fun, hdi, where);
    auto assembler_sc = make_stokes_fict_condensed_assembler(msh, bcs_fun, hdi, where);

    // method with gradient reconstruction (penalty-free)
    auto class_meth = make_gradrec_stokes_fictdom_method(msh, 1.0, test_case, true);

    for (auto& cl : msh.cells)
    {
        if( !(location(msh, cl) == element_location::ON_INTERFACE || location(msh, cl) == where) )
            continue;
        auto contrib = class_meth.make_contrib(msh, cl, test_case, hdi,
                                               element_location::IN_NEGATIVE_SIDE);
        auto lc_A = contrib.first.first;
        auto lc_B = -contrib.first.second;
        auto rhs_A = contrib.second.first;
        auto rhs_B = -contrib.second.second;

        if( sc )
            assembler_sc.assemble(msh, cl, lc_A, lc_B, rhs_A, rhs_B);
        else
            assembler.assemble(msh, cl, lc_A, lc_B, rhs_A, rhs_B);
    }

    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;


    /************** SOLVE **************/
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    /************** POSTPROCESS **************/



    postprocess_output<RealType>  postoutput;

    auto uT_l2_gp  = std::make_shared< gnuplot_output_object<RealType> >("fictdom_uT_norm.dat");
    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("fictdom_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("fictdom_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("fictdom_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;
    for (auto& cl : msh.cells)
    {
        bool hide_fict_dom = true; // hide the fictitious domain in the gnuplot outputs
        if (hide_fict_dom && location(msh,cl) == element_location::IN_POSITIVE_SIDE)
            continue;

        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis<cuthho_poly_mesh<RealType>, RealType> s_cb(msh, cl, hdi.face_degree());

        auto cbs = cb.size();

        Matrix<RealType, Dynamic, 1> locdata_vel, locdata_p;
        if( sc )
        {
            locdata_vel = assembler_sc.take_velocity(msh, cl, sol);
            locdata_p   = assembler_sc.take_pressure(msh, cl, sol);
        }
        else
        {
            locdata_vel = assembler.take_velocity(msh, cl, sol);
            locdata_p   = assembler.take_pressure(msh, cl, sol);
        }

        Matrix<RealType, Dynamic, 1> cell_v_dofs = locdata_vel.head(cbs);

        //auto bar = barycenter(msh, cl, element_location::IN_NEGATIVE_SIDE);

        if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE ||
             location(msh, cl) == element_location::ON_INTERFACE )
        {
            //Matrix<RealType, 1, 2> real_grad_int = Matrix<RealType, 1, 2>::Zero();
            //Matrix<RealType, 1, 2> comp_grad_int = Matrix<RealType, 1, 2>::Zero();
            auto qps = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 0; i < cbs; i++ )
                    grad += cell_v_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;

                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                /* L2 - error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * cell_v_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );
                uT_l2_gp->add_data( qp.first, std::sqrt( v(0)*v(0) + v(1)*v(1) ) );

                /* L2 - pressure - error */
                auto s_cphi = s_cb.eval_basis( qp.first );
                RealType p_num = s_cphi.dot(locdata_p);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }
    }

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2 - pressure - error:                " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT_l2_gp);
    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();

    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p   = std::sqrt(L2_pressure_error);

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;

    return TI;
}



//////////////////////////////  INTERFACE METHODS  ///////////////////////////

template<typename T, size_t ET, typename testType>
class stokes_interface_method
{
    using Mat  = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method(bool sym)
        : sym_grad(sym) {}

    virtual std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
    }

public:
    std::pair<Mat, Vect>
    make_contrib_uncut(const Mesh& msh, const typename Mesh::cell_type& cl,
                       const hho_degree_info hdi, const testType& test_case)
    {
        T kappa;
        if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if(sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero( loc_size, loc_size );
        Vect rhs = Vect::Zero( loc_size );

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair<Mat, Vect>
    make_contrib(const Mesh& msh, const typename Mesh::cell_type& cl,
                 const testType& test_case, const hho_degree_info hdi)
    {
        if( location(msh, cl) != element_location::ON_INTERFACE )
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};



template<typename T, size_t ET, typename testType>
class stokes_interface_method_ref_pts
{
    using Mat  = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method_ref_pts(bool sym)
        : sym_grad(sym) {}

    virtual std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
    }

public:
    std::pair<Mat, Vect>
    make_contrib_uncut(const Mesh& msh, const typename Mesh::cell_type& cl,
                       const hho_degree_info hdi, const testType& test_case)
    {
        T kappa;
        if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if(sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero( loc_size, loc_size );
        Vect rhs = Vect::Zero( loc_size );

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair<Mat, Vect>
    make_contrib(const Mesh& msh, const typename Mesh::cell_type& cl,
                 const testType& test_case, const hho_degree_info hdi)
    {
        if( location(msh, cl) != element_location::ON_INTERFACE )
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};


template<typename T, size_t ET, typename testType>
class stokes_interface_method_ref_pts_cont
{
    using Mat  = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

protected:
    bool sym_grad;

    stokes_interface_method_ref_pts_cont(bool sym)
        : sym_grad(sym) {}

    virtual std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
    }

public:
    std::pair<Mat, Vect>
    make_contrib_uncut(const Mesh& msh, const typename Mesh::cell_type& cl,
                       const hho_degree_info hdi, const testType& test_case)
    {
        T kappa;
        if ( location(msh, cl) == element_location::IN_NEGATIVE_SIDE )
            kappa = test_case.parms.kappa_1;
        else
            kappa = test_case.parms.kappa_2;

        Mat gr2;
        if(sym_grad)
            gr2 = make_hho_gradrec_sym_matrix(msh, cl, hdi).second;
        else
            gr2 = make_hho_gradrec_matrix(msh, cl, hdi).second;
        Mat stab = make_hho_vector_naive_stabilization(msh, cl, hdi);
        Mat lc = kappa * (gr2 + stab);
        auto dr = make_hho_divergence_reconstruction(msh, cl, hdi);
        Mat f = make_vector_rhs(msh, cl, hdi.cell_degree(), test_case.rhs_fun);

        size_t v_size = gr2.rows();
        size_t p_size = dr.first.rows();
        size_t loc_size = v_size + p_size;
        Mat lhs = Mat::Zero( loc_size, loc_size );
        Vect rhs = Vect::Zero( loc_size );

        lhs.block(0, 0, v_size, v_size) = lc;
        lhs.block(0, v_size, v_size, p_size) = -dr.second.transpose();
        lhs.block(v_size, 0, p_size, v_size) = -dr.second;

        rhs.head(f.rows()) = f;
        return std::make_pair(lhs, rhs);
    }


    std::pair<Mat, Vect>
    make_contrib(const Mesh& msh, const typename Mesh::cell_type& cl,
                 const testType& test_case, const hho_degree_info hdi)
    {
        if( location(msh, cl) != element_location::ON_INTERFACE )
            return make_contrib_uncut(msh, cl, hdi, test_case);
        else // on interface
            return make_contrib_cut(msh, cl, test_case, hdi);
    }
};



////////////////////////  SYMMETRIC GRADREC INTERFACE METHOD


template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method : public stokes_interface_method<T, ET, testType>
{
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method(T eta_, T gamma_, bool sym)
        : stokes_interface_method<T,ET,testType>(sym), eta(eta_), gamma_0(gamma_) {}

    std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment( cl );
        ///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh,T>::size(celdeg);
        auto pbs = cell_basis<Mesh,T>::size(pdeg);

        // GR
        Mat gr2_n, gr2_p;
        if(this->sym_grad)
        {
            // ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

            // 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
            /// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
            /// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }
        else
        {
            gr2_n = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

        // stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi,parms);
        // Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0,0,cbs,cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
        // This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

        // DR : Penalty divided:
        // (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
        // (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface
            (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface
            (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2*pbs, lc.rows() + 2*pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


        // stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2*cbs, 2*cbs) -= gamma_0 * stokes_stab.block(0, 0, 2*cbs, 2*cbs);
        lhs.block(0, lc.rows(), 2*cbs, 2*pbs) -= gamma_0 * stokes_stab.block(0,2*cbs,2*cbs,2*pbs);
        lhs.block(lc.rows(), 0, 2*pbs, 2*cbs) -= gamma_0 * stokes_stab.block(2*cbs,0,2*pbs,2*cbs);
        lhs.block(lc.rows(), lc.rows(), 2*pbs, 2*pbs)
            -= gamma_0 * stokes_stab.block(2*cbs, 2*cbs, 2*pbs, 2*pbs);



        ////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
        // neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);

        // pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2*pbs);
        rhs.head(lc.rows()) = f;

        // stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
            (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2*cbs) -= gamma_0 * stab_rhs.head(2*cbs);
        rhs.tail(2*pbs) -= gamma_0 * stab_rhs.tail(2*pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method(const cuthho_mesh<T, ET>& msh, const T eta_,
                                              const T gamma_, testType& test_case, bool sym)
{
    return Sym_gradrec_stokes_interface_method<T, ET, testType>(eta_, gamma_, sym);
}



template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_ref_pts : public stokes_interface_method_ref_pts<T, ET, testType>
{
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method_ref_pts(T eta_, T gamma_, bool sym)
        : stokes_interface_method_ref_pts<T,ET,testType>(sym), eta(eta_), gamma_0(gamma_) {}

    std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment( cl );
        ///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh,T>::size(celdeg);
        auto pbs = cell_basis<Mesh,T>::size(pdeg);

        // GR
        Mat gr2_n, gr2_p;
        if(this->sym_grad)
        {
            // ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

            // 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
            /// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
            /// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface_ref_pts
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface_ref_pts
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }
        else
        {
            // ANCORA DA MODIFICAREEEEEE
            std::cout<<"STILL TO BE MODIFIED WITH parametric curve"<<std::endl;
            gr2_n = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

        // stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi,parms);
        // Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0,0,cbs,cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
        // This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

        // DR : Penalty divided:
        // (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
        // (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface_ref_pts
            (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface_ref_pts
            (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2*pbs, lc.rows() + 2*pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


        // stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization_ref_pts(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2*cbs, 2*cbs) -= gamma_0 * stokes_stab.block(0, 0, 2*cbs, 2*cbs);
        lhs.block(0, lc.rows(), 2*cbs, 2*pbs) -= gamma_0 * stokes_stab.block(0,2*cbs,2*cbs,2*pbs);
        lhs.block(lc.rows(), 0, 2*pbs, 2*cbs) -= gamma_0 * stokes_stab.block(2*cbs,0,2*pbs,2*cbs);
        lhs.block(lc.rows(), lc.rows(), 2*pbs, 2*pbs)
            -= gamma_0 * stokes_stab.block(2*cbs, 2*cbs, 2*pbs, 2*pbs);



        ////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
        // neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5*make_vector_flux_jump_reference_pts(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);

        // pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump_reference_pts(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2*pbs);
        rhs.head(lc.rows()) = f;

        // stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS_ref_pts
            (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2*cbs) -= gamma_0 * stab_rhs.head(2*cbs);
        rhs.tail(2*pbs) -= gamma_0 * stab_rhs.tail(2*pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_ref_pts(const cuthho_mesh<T, ET>& msh, const T eta_,
                                              const T gamma_, testType& test_case, bool sym)
{
    return Sym_gradrec_stokes_interface_method_ref_pts<T, ET, testType>(eta_, gamma_, sym);
}




template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_ref_pts_cont : public stokes_interface_method_ref_pts_cont<T, ET, testType>
{
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method_ref_pts_cont(T eta_, T gamma_, bool sym)
        : stokes_interface_method_ref_pts_cont<T,ET,testType>(sym), eta(eta_), gamma_0(gamma_) {}

    std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
        auto parms = test_case.parms ;
        auto parametric_interface = test_case.parametric_interface;
        auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment( cl );
        ///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh,T>::size(celdeg);
        auto pbs = cell_basis<Mesh,T>::size(pdeg);

        // GR
        Mat gr2_n, gr2_p;
        if(this->sym_grad)
        {
            // ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

            // 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
            /// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
            /// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface_ref_pts_cont
                (msh, cl, parametric_interface, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface_ref_pts_cont
                (msh, cl, parametric_interface, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }
        else
        {
            // ANCORA DA MODIFICAREEEEEE
            std::cout<<"STILL TO BE MODIFIED WITH parametric curve"<<std::endl;
            gr2_n = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

        // stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi,parms);
        // Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0,0,cbs,cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
        // This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

        // DR : Penalty divided:
        // (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
        // (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface_ref_pts_cont
            (msh, cl, parametric_interface, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface_ref_pts_cont
            (msh, cl, parametric_interface, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2*pbs, lc.rows() + 2*pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


        // stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization_ref_pts_cont(msh, cl, hdi, parametric_interface);
        lhs.block(0, 0, 2*cbs, 2*cbs) -= gamma_0 * stokes_stab.block(0, 0, 2*cbs, 2*cbs);
        lhs.block(0, lc.rows(), 2*cbs, 2*pbs) -= gamma_0 * stokes_stab.block(0,2*cbs,2*cbs,2*pbs);
        lhs.block(lc.rows(), 0, 2*pbs, 2*cbs) -= gamma_0 * stokes_stab.block(2*cbs,0,2*pbs,2*cbs);
        lhs.block(lc.rows(), lc.rows(), 2*pbs, 2*pbs)
            -= gamma_0 * stokes_stab.block(2*cbs, 2*cbs, 2*pbs, 2*pbs);



        ////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
        // neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
//        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump);
        f.head(cbs) += 0.5*make_vector_flux_jump_reference_pts_cont(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE, test_case.neumann_jump , parametric_interface);

        // pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
//        f.block(cbs, 0, cbs, 1)
//            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump);
        f.block(cbs, 0, cbs, 1) += 0.5 * make_vector_flux_jump_reference_pts_cont(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,  test_case.neumann_jump,parametric_interface);


        Vect rhs = Vect::Zero(lc.rows() + 2*pbs);
        rhs.head(lc.rows()) = f;

        // stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS_ref_pts_cont
            (msh, cl, hdi, parametric_interface, test_case.neumann_jump);

        rhs.head(2*cbs) -= gamma_0 * stab_rhs.head(2*cbs);
        rhs.tail(2*pbs) -= gamma_0 * stab_rhs.tail(2*pbs);

        return std::make_pair(lhs, rhs);
    }
};

template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_ref_pts_cont(const cuthho_mesh<T, ET>& msh, const T eta_, const T gamma_, testType& test_case, bool sym)
{
    return Sym_gradrec_stokes_interface_method_ref_pts_cont<T, ET, testType>(eta_, gamma_, sym);
}






template<typename T, size_t ET, typename testType>
class Sym_gradrec_stokes_interface_method_analytic : public stokes_interface_method<T, ET, testType>
{
    using Mat = Matrix<T, Dynamic, Dynamic>;
    using Vect = Matrix<T, Dynamic, 1>;
    using Mesh = cuthho_mesh<T, ET>;

public:
    T eta, gamma_0;

    Sym_gradrec_stokes_interface_method_analytic(T eta_, T gamma_, bool sym)
        : stokes_interface_method<T,ET,testType>(sym), eta(eta_), gamma_0(gamma_) {}

    std::pair<Mat, Vect>
    make_contrib_cut(const Mesh& msh, const typename Mesh::cell_type& cl,
                     const testType& test_case, const hho_degree_info hdi)
    {
        auto parms = test_case.parms;
        auto level_set_function = test_case.level_set_;
        ///////////////   LHS
        auto celdeg = hdi.cell_degree();
        auto pdeg = hdi.face_degree();
        auto cbs = vector_cell_basis<Mesh,T>::size(celdeg);
        auto pbs = cell_basis<Mesh,T>::size(pdeg);

        // GR
        Mat gr2_n, gr2_p;
        if(this->sym_grad)
        {
            // ---- THIS CASE IS ROBUST FOR K_1 SIMILAR TO K_2 -----

            // 0.5 is the weight coefficient that scale the interface term between inner and outer interface (Omega_1 and Omega_2)
            /// Paper: Un Unfitted HHO method with cell agglomeration for elliptic interface pb.
            /// -->  This is the variant 2.5 (pag.7)
            gr2_n = make_hho_gradrec_sym_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_sym_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }
        else
        {
            gr2_n = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_NEGATIVE_SIDE, 0.5).second;
            gr2_p = make_hho_gradrec_matrix_interface
                (msh, cl, level_set_function, hdi,element_location::IN_POSITIVE_SIDE, 0.5).second;
        }

        // stab
        Mat stab = make_hho_vector_stabilization_interface(msh, cl, level_set_function, hdi,parms);
        // Penalty conforming to variant 2.5, paper "Un Unfitted HHO method.."
        Mat penalty = make_hho_cut_interface_vector_penalty(msh, cl, hdi, eta).block(0,0,cbs,cbs);
        stab.block(0, 0, cbs, cbs) += parms.kappa_2 * penalty;
        stab.block(0, cbs, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, 0, cbs, cbs) -= parms.kappa_2 * penalty;
        stab.block(cbs, cbs, cbs, cbs) += parms.kappa_2 * penalty;
        // This is term \tilde{a_T} (eq.15), paper "Un Unfitted HHO method.."
        Mat lc = stab + parms.kappa_1 * gr2_n + parms.kappa_2 * gr2_p;

        // DR : Penalty divided:
        // (1.0 - coeff) * interface_term in NEGATIVE SIDE + coeff contribute into positive side
        // (coeff- 1.0 ) * interface_term in POSITIVE SIDE - coeff contribute into negative side
        auto dr_n = make_hho_divergence_reconstruction_interface
            (msh, cl, level_set_function, hdi, element_location::IN_NEGATIVE_SIDE, 0.5);
        auto dr_p = make_hho_divergence_reconstruction_interface
            (msh, cl, level_set_function, hdi, element_location::IN_POSITIVE_SIDE, 0.5);


        Mat lhs = Mat::Zero(lc.rows() + 2*pbs, lc.rows() + 2*pbs);
        lhs.block(0, 0, lc.rows(), lc.rows()) = lc;
        lhs.block(0, lc.rows(), lc.rows(), pbs) -= dr_n.second.transpose();
        lhs.block(0, lc.rows() + pbs, lc.rows(), pbs) -= dr_p.second.transpose();
        lhs.block(lc.rows(), 0, pbs, lc.rows()) -= dr_n.second;
        lhs.block(lc.rows() + pbs, 0, pbs, lc.rows()) -= dr_p.second;


        // stokes stabilization terms
        auto stokes_stab = make_stokes_interface_stabilization(msh, cl, hdi, level_set_function);
        lhs.block(0, 0, 2*cbs, 2*cbs) -= gamma_0 * stokes_stab.block(0, 0, 2*cbs, 2*cbs);
        lhs.block(0, lc.rows(), 2*cbs, 2*pbs) -= gamma_0 * stokes_stab.block(0,2*cbs,2*cbs,2*pbs);
        lhs.block(lc.rows(), 0, 2*pbs, 2*cbs) -= gamma_0 * stokes_stab.block(2*cbs,0,2*pbs,2*cbs);
        lhs.block(lc.rows(), lc.rows(), 2*pbs, 2*pbs)
            -= gamma_0 * stokes_stab.block(2*cbs, 2*cbs, 2*pbs, 2*pbs);



        ////////////////    RHS

        Vect f = Vect::Zero(lc.rows());
        // neg part
        f.block(0, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                 element_location::IN_NEGATIVE_SIDE);
        f.head(cbs) += 0.5*make_vector_flux_jump(msh,cl,celdeg, element_location::IN_NEGATIVE_SIDE,
                                                 test_case.neumann_jump);

        // pos part
        f.block(cbs, 0, cbs, 1) += make_vector_rhs(msh, cl, celdeg, test_case.rhs_fun,
                                                   element_location::IN_POSITIVE_SIDE);
        f.block(cbs, 0, cbs, 1)
            += 0.5 * make_vector_flux_jump(msh, cl, celdeg, element_location::IN_POSITIVE_SIDE,
                                           test_case.neumann_jump);


        Vect rhs = Vect::Zero(lc.rows() + 2*pbs);
        rhs.head(lc.rows()) = f;

        // stokes stabilization rhs
        auto stab_rhs = make_stokes_interface_stabilization_RHS
            (msh, cl, hdi, level_set_function, test_case.neumann_jump);

        rhs.head(2*cbs) -= gamma_0 * stab_rhs.head(2*cbs);
        rhs.tail(2*pbs) -= gamma_0 * stab_rhs.tail(2*pbs);

        return std::make_pair(lhs, rhs);
    }
};



template<typename T, size_t ET, typename testType>
auto make_sym_gradrec_stokes_interface_method_analytic(const cuthho_mesh<T, ET>& msh, const T eta_,
                                              const T gamma_, testType& test_case, bool sym)
{
    return Sym_gradrec_stokes_interface_method_analytic<T, ET, testType>(eta_, gamma_, sym);
}




///////////////////////////////////////

template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity , typename RealType >
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_analytic(const Mesh& msh, size_t degree, meth method, testType test_case , Fonction & level_set_function , Velocity & velocity , bool sym_grad , RealType radius )
{
    //using RealType = typename Mesh::coordinate_type;

    //auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"Interface isovalue = "<<iso_val_interface<<std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


    // ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    timecounter tc_bis2 ;
    tc_bis2.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler , time = "<<tc_bis2<<std::endl;
    tc_bis2.tic();
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler_sc , time = "<<tc_bis2<<std::endl;
    for (auto& cl : msh.cells)
    {
        // ADD BY STE
        timecounter tc_bis ;
        tc_bis.tic();
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_analytic(msh, level_set_function, prm, sym_grad,radius);

        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES PARTE 0 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case_cell, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES PARTE 1 , time = "<<tc_bis<<std::endl;
         tc_bis.tic();
        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES PARTE 2 , time = "<<tc_bis<<std::endl;
    }


    tc_bis2.tic();
    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc_bis2.toc();
    std::cout<<"-------> TIME STOKES PARTE 3 , time = "<<tc_bis2<<std::endl;
    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    // ************** SOLVE **************
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    // ************** POSTPROCESS **************


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;

    std::cout<<"sono qua 0.0"<<std::endl;
    size_t i_global = 0 ; // ADD BY STE
    for (auto& cl : msh.cells)
    {


        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();


        // ADD BY STE
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_analytic(msh, level_set_function, prm, sym_grad, radius);
        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



            // Updating velocity field by STE
            //std::cout<<"------------>>> CUT CELL"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > iso_val_interface )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                        //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                        //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > iso_val_interface )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                            //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                            //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }



            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                 // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;
                std::cout<<"Local error pressure (NEGATIVE CUT) = "<<qp.second * p_diff * p_diff <<std::endl;
                p_gp->add_data( qp.first, p_num );
            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                 // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;
                std::cout<<"Local error pressure (POSITIVE CUT) = "<<qp.second * p_diff * p_diff <<std::endl;
                p_gp->add_data( qp.first, p_num );
            }
        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            //std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
            /*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }




            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;
                std::cout<<"Local error pressure (UNCUT) = "<<qp.second * p_diff * p_diff <<std::endl;
                p_gp->add_data( qp.first, p_num );
            }
        }

        i_global++;
    }
    //std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
    //std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity(const Mesh& msh, size_t degree, meth method, testType test_case , Fonction & level_set_function , Velocity & velocity , bool sym_grad )
{
    using RealType = typename Mesh::coordinate_type;

    //auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"Interface isovalue = "<<iso_val_interface<<std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


    // ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    timecounter tc_bis2 ;
    tc_bis2.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler , time = "<<tc_bis2<<std::endl;
    tc_bis2.tic();
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
     std::cout<<"-------> TIME assembler_sc , time = "<<tc_bis2<<std::endl;
    for (auto& cl : msh.cells)
    {
        // ADD BY STE
        timecounter tc_bis ;
        tc_bis.tic();
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 0 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        //auto rhs_fun = test_case_cell.rhs_fun;
        //auto sol_vel = test_case_cell.sol_vel;
        //auto sol_p = test_case_cell.sol_p;
        //auto vel_grad = test_case_cell.vel_grad;
        ///---> QUESTO NO auto bcs_vel = test_case.bcs_vel;
        //auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 1 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case_cell, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 2 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 3 , time = "<<tc_bis<<std::endl;
    }
    tc_bis2.tic();

    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc_bis2.toc();
    std::cout<<"------------------> TIME STOKES 4 , time = "<<tc_bis2<<std::endl;
    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    // ************** SOLVE **************
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    // ************** POSTPROCESS **************


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;

    std::cout<<"sono qua 0.0"<<std::endl;
    size_t i_global = 0 ; // ADD BY STE
    for (auto& cl : msh.cells)
    {


        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();


        // ADD BY STE
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



            // Updating velocity field by STE
            //std::cout<<"------------>>> CUT CELL"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > iso_val_interface )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                        //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                        //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > iso_val_interface )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                            //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                            //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }



            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                 // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                 // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            //std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
            /*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }




            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }

        i_global++;
    }
    //std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
    //std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity  >
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_prova(const Mesh& msh, size_t degree, meth& method, testType& test_case , Fonction & level_set_function , Velocity & velocity , bool sym_grad , size_t time )
{
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface ;

    std::cout<<"WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."<<std::endl;

    auto bcs_vel = test_case.bcs_vel;



    timecounter tc;

    bool sc = true ;  // static condensation


    // ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree+1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

    // IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func( bcs_vel ); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh) ;

    for (auto& cl : msh.cells)
    {

        //std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
        test_case.test_case_cell_assignment(cl);
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    // ************** SOLVE **************
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds"  << std::endl;

    // ************** POSTPROCESS **************


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");
//    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;
    RealType    l1_u_n_error = 0.0;
    RealType    l2_u_n_error = 0.0;
    RealType    linf_u_n_error = 0.0;
    size_t      counter_interface_pts = 0;


    size_t i_global = 0 ;
    for (auto& cl : msh.cells)
    {


        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        //auto pbs = pb.size();


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl) ;

        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        //auto neumann_jump = test_case.neumann_jump;
        //assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



            // Updating velocity field by STE
            //std::cout<<"------------>>> CUT CELL"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > iso_val_interface )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                        //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                        //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
            else // AGGLO CELL
            {
                //for(auto pt:points(msh,cl))
                 //   std::cout<<"pt = "<<pt<<std::endl;

                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     //std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > iso_val_interface )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                            //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                            //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }



            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                 // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num; // era test_case STE
                //auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                 // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num; // era test_case STE
                //auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
            if(1)
            {
                for(auto& interface_point : cl.user_data.interface)
                {
                    auto t_phi = cb.eval_basis( interface_point );
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal( interface_point ) ;
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n,2.0);
                    linf_u_n_error = std::max( linf_u_n_error , std::abs(v_n) );
                    counter_interface_pts++;
                }
            }

        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            //std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
            /*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    //std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }




            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num; // era test_case STE
                //auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }

        i_global++;
    }
    //std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
    //std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error/counter_interface_pts << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error/counter_interface_pts) << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if(1)
    {
        TI.l1_normal_vel = l1_u_n_error/counter_interface_pts ;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error/counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error ;
    }






    if (0)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
               JacobiSVD<MatrixXd> svd(Mat);
               RealType cond = svd.singularValues()(0)
                   / svd.singularValues()(svd.singularValues().size()-1);
            std::cout<<"cond numb = "<< cond << std::endl;
        }

        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity  >
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_new(const Mesh& msh, size_t degree, meth& method, testType& test_case , Fonction & level_set_function , Velocity & velocity , bool sym_grad , size_t time )
{
    using RealType = typename Mesh::coordinate_type;

    auto iso_val_interface = level_set_function.iso_val_interface ;

    std::cout<<"WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."<<std::endl;

    auto bcs_vel = test_case.bcs_vel;



    timecounter tc;

    bool sc = true ;  // static condensation


    // ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree+1, degree);

    tc.tic();


    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);

    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);

    // IT MAY GO INTO THE LOOP ( IF YES ADD ALSO IN THE POST-PROCESSING LOOP )
    assembler_sc.set_dir_func( bcs_vel ); // DOVE VA? INTO LOOP cl? SE CAMBIASSE bcs_vel in spazio forse si!

    test_case.test_case_mesh_assignment(msh) ;

    for (auto& cl : msh.cells)
    {

        //std::cout<<yellow<<bold<<"CELL = "<<offset(msh,cl) <<reset<<std::endl;
//        test_case.test_case_cell_assignment(cl); // DIREI CHE NON SERVE PIU
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

    }


    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();


    tc.toc();
    std::cout << "Matrix assembly: " << tc << " seconds" << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    // ************** SOLVE **************
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << "Linear solver: " << tc << " seconds"  << std::endl;

    // ************** POSTPROCESS **************


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
//    std::string filename_pressure = "interface_p_" + std::to_string(time) + ".dat";
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");
    //auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >(filename_pressure);

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;
    RealType    l1_u_n_error = 0.0;
    RealType    l2_u_n_error = 0.0;
    RealType    linf_u_n_error = 0.0;
    size_t      counter_interface_pts = 0;


    size_t i_global = 0 ;
    for (auto& cl : msh.cells)
    {


        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        //auto pbs = pb.size();


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl) ;

        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        //auto neumann_jump = test_case.neumann_jump;
        //assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



            // Updating velocity field by STE
            //std::cout<<"------------>>> CUT CELL"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > iso_val_interface )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                        //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                        //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
            else // AGGLO CELL
            {
                //for(auto pt:points(msh,cl))
                 //   std::cout<<"pt = "<<pt<<std::endl;

                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     //std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > iso_val_interface )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                            //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                            //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }



            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                 // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num; // era test_case STE
                //auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                 // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num; // era test_case STE
                //auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
            if(1)
            {
                for(auto& interface_point : cl.user_data.interface)
                {
                    auto t_phi = cb.eval_basis( interface_point );
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal( interface_point ) ;
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs(v_n);
                    l2_u_n_error += pow(v_n,2.0);
                    linf_u_n_error = std::max( linf_u_n_error , std::abs(v_n) );
                    counter_interface_pts++;
                }
            }

        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            //std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;
            /*
            for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
            {
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                 std::cout<<"offset_old = "<<offset_old<<std::endl;
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            */

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                    //std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }




            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num; // era test_case STE
                //auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }

        i_global++;
    }
    //std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
    //std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << l1_u_n_error/counter_interface_pts << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << std::sqrt(l2_u_n_error/counter_interface_pts) << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << linf_u_n_error << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);
    if(1)
    {
        TI.l1_normal_vel = l1_u_n_error/counter_interface_pts ;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error/counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error ;
    }






    if (0)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;

        {
               JacobiSVD<MatrixXd> svd(Mat);
               RealType cond = svd.singularValues()(0)
                   / svd.singularValues()(svd.singularValues().size()-1);
            std::cout<<"cond numb = "<< cond << std::endl;
        }

        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


/*
template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_velocity_parallel(const Mesh& msh, size_t degree, meth method, testType test_case , Fonction & level_set_function , Velocity & velocity , bool sym_grad )
{
    using RealType = typename Mesh::coordinate_type;

    //auto level_set_function = test_case.level_set_;

    auto iso_val_interface = level_set_function.iso_val_interface ;
    std::cout<<"Interface isovalue = "<<iso_val_interface<<std::endl;
    auto bcs_vel = test_case.bcs_vel;

    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


    // ************** ASSEMBLE PROBLEM **************
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    timecounter tc_bis2 ;
    tc_bis2.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler , time = "<<tc_bis2<<std::endl;
    tc_bis2.tic();
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    tc_bis2.toc();
    std::cout<<"-------> TIME assembler_sc , time = "<<tc_bis2<<std::endl;
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&] (size_t  cell_ind){
        auto& cl = msh.cells[cell_ind];

    //for (auto& cl : msh.cells)
    //{
        // ADD BY STE
        timecounter tc_bis ;
        tc_bis.tic();
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);
        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);

        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function, prm, sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 0 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        auto contrib = method.make_contrib(msh, cl, test_case_cell, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;
        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 1 , time = "<<tc_bis<<std::endl;
        tc_bis.tic();
        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);

        tc_bis.toc();
        std::cout<<"-------> TIME STOKES 2 , time = "<<tc_bis<<std::endl;



    });

    tc_bis2.tic();
    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc_bis2.toc();
    std::cout<<"-------> TIME STOKES 3 , time = "<<tc_bis2<<std::endl;
    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    // ************** SOLVE **************
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    // ************** POSTPROCESS **************


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;

    std::cout<<"sono qua 0.0"<<std::endl;
    size_t i_global = 0 ; // ADD BY STE
    for (auto& cl : msh.cells)
    {


        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());


        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();


        // ADD BY STE
        level_set_function.cell_assignment(cl);
        //auto test_case_cell = make_test_case_stokes_2(msh, level_set_function);

        auto prm = params<RealType>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        auto test_case_cell = make_test_case_eshelby_2(msh, level_set_function, prm, sym_grad);
        //auto test_case_cell = make_test_case_eshelby(msh, level_set_function,  prm , sym_grad);
        //This stuff before it was before the loop in msh.cells and test_case and not test_case_cell
        auto rhs_fun = test_case_cell.rhs_fun;
        auto sol_vel = test_case_cell.sol_vel;
        auto sol_p = test_case_cell.sol_p;
        auto vel_grad = test_case_cell.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case_cell.neumann_jump;
        assembler_sc.set_dir_func( bcs_vel);


        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);



            // Updating velocity field by STE
            //std::cout<<"------------>>> CUT CELL"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;

            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > iso_val_interface )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;
                        //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                        //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                    }
                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > iso_val_interface )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                            //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                            i_local++;
                            //  velocity.first(i_local,i_global) = cell_dofs_n.dot( phi_HHO );
                            //  velocity.second(i_local,i_global) = 0; // elliptic case is scalar
                        }
                    }

                }
            }



            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                 // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                 // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            //std::cout<<"------------>>> NOT CUT CELL!!!!!"<<std::endl;
            //std::cout<<"subcells.size() = "<<level_set_function.subcells.size()<<std::endl;


            // NOT AGGLO CELL
            if ( level_set_function.subcells.size()<1 )
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];
                     std::cout<<"offset_old = "<<offset_old<<std::endl;
                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        //std::cout<<"In pt = "<<ln_Qk<<"-> vel(0) = "<<vel(0)<<" and vel(1) = "<<vel(1)<<std::endl;
                        i_local++;

                    }

                }
            }




            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                // Compute H1-error //
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                // Compute L2-error //
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                // L2 - pressure - error //
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case_cell.sol_p( qp.first ) - p_num; // era test_case STE
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }

        i_global++;
    }
    //std::cout<<"velocity.sol_HHO.first"<<'\n'<<velocity.sol_HHO.first<<std::endl;
    //std::cout<<"velocity.sol_HHO.second"<<'\n'<<velocity.sol_HHO.second<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if (false)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
                  << sigma_min << "  cond = " << cond
                  << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}


*/


template<typename Mesh, typename testType, typename meth>
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface(const Mesh& msh, size_t degree, meth method, testType test_case , bool normal_analysis = FALSE )
{
    using RealType = typename Mesh::coordinate_type;

    auto level_set_function = test_case.level_set_;

    auto rhs_fun = test_case.rhs_fun;
    auto sol_vel = test_case.sol_vel;
    auto sol_p = test_case.sol_p;
    auto vel_grad = test_case.vel_grad;
    auto bcs_vel = test_case.bcs_vel;
    auto neumann_jump = test_case.neumann_jump;
    struct params<RealType> parms = test_case.parms;

    timecounter tc;

    bool sc = true; // static condensation


    /************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    for (auto& cl : msh.cells)
    {
        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    /************** SOLVE **************/
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    /************** POSTPROCESS **************/


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;
    RealType    l2_u_n_error = 0.0;
    RealType    linf_u_n_error = 0.0;
    size_t      counter_interface_pts = 0;

    for (auto& cl : msh.cells)
    {
        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);


            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );


            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            if(normal_analysis)
            {
                for(auto& interface_point : cl.user_data.interface)
                {
                    auto t_phi = cb.eval_basis( interface_point );
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal( interface_point ) ;
                    auto v_n = v.dot(n);
                    l2_u_n_error += pow(v_n,2.0);
                    linf_u_n_error = std::max( linf_u_n_error , std::abs(v_n) );
                    counter_interface_pts++;
                }
            }

        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }
        }

    }

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;

    // Stefano: I dont want plots (in the code uTi_gp and p_gp still present). Just commented these.
    //postoutput.add_object(uT1_gp);
    //postoutput.add_object(uT2_gp);
    //postoutput.add_object(p_gp);
    //postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if(normal_analysis)
    {
        TI.l2_normal_vel = std::sqrt(l2_u_n_error/counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error ;
    }

    if (0)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        // Add by Stefano
        Eigen::BDCSVD<Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
        double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size()-1);
        std::cout<<"cond_numb = "<<cond<<std::endl;



        // Erased by Stefano
        /*
        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        */
        // compute condition number
        //RealType cond = sigma_max / sigma_min;
        TI.cond = cond;
        //std::cout << "sigma_max = " << sigma_max << "   sigma_min = " << sigma_min << "  cond = " << cond << std::endl;

    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;


    return TI;
}

template<typename Mesh, typename testType, typename meth , typename Fonction >
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_numerical_ls(const Mesh& msh, size_t degree, meth& method, testType& test_case ,  Fonction & level_set_function , bool normal_analysis = FALSE )
{
    using RealType = typename Mesh::coordinate_type;

//    bool sym_grad = true ;
//
//    struct params<RealType> parms = test_case.parms;


    auto bcs_vel = test_case.bcs_vel;
    test_case.test_case_mesh_assignment(msh) ;

    timecounter tc;

    bool sc = true; // static condensation

    std::cout<<"WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."<<std::endl;
    //std::cout<<"WARNING: check integration points: it seems there is a repetition in agglomerated cells."<<std::endl; --> NOT TRUE, THE WEIGHTS ARE ZEROS!

    /************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    // Dir condition out the for loop -> CHECK IT

    assembler_sc.set_dir_func( bcs_vel );
    for (auto& cl : msh.cells)
    {

        test_case.test_case_cell_assignment(cl);
        //auto level_set_function = test_case.level_set_;
        //test_case.refresh_lambdas(level_set_function, parms , sym_grad );

        //auto rhs_fun = test_case.rhs_fun;
        //auto sol_vel = test_case.sol_vel;
        //auto sol_p = test_case.sol_p;
        //auto vel_grad = test_case.vel_grad;
        //auto bcs_vel = test_case.bcs_vel;
        //auto neumann_jump = test_case.neumann_jump;




        //std::cout<<"CHECK cl_refresh:"<<'\n'<<"---> CEll loop = "<<offset(msh,cl)<<" , refreshed cell = "<<offset(msh,test_case.upload_cl())<<std::endl;

        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    /************** SOLVE **************/
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    /************** POSTPROCESS **************/


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;
    RealType    l1_u_n_error = 0.0;
//    RealType    l2_u_n_error = 0.0;
    RealType    linf_u_n_error = 0.0;
    size_t      counter_interface_pts = 0;
    RealType flux_interface = 0.0;
    RealType rise_vel0 = 0.0 , rise_vel1 = 0.0 , area_fin = 0.0 ;


    for (auto& cl : msh.cells)
    {
        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
//        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;

        //auto level_set_function = test_case.level_set_;
        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl) ;
        //test_case.refresh_lambdas(level_set_function, parms , sym_grad );

        auto rhs_fun = test_case.rhs_fun;
        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
        auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case.neumann_jump;

        //assembler_sc.set_dir_func( bcs_vel);

        //std::cout<<"CHECK cl_refresh:"<<'\n'<<"---> CEll loop = "<<offset(msh,cl)<<" , refreshed cell = "<<offset(msh,test_case.upload_cl())<<std::endl;

        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);
            
//             if( cl.user_data.offset_subcells[0] == 83 || cl.user_data.offset_subcells[0] == 163 )
//             {
//                 std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<"cell = "<<offset(msh,cl)<<" , vertices:"<<std::endl;
//                 for(auto& pt:points(msh,cl))
//                     std::cout<<" pt = "<<pt;
//                 std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1) <<'\n'<<"Interface points:"<<std::endl;
//                 for(auto& pt: cl.user_data.integration_msh.points)
//                     std::cout<<" pt = "<<pt;
//                 std::cout<<std::endl;
//             }

            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            RealType local_H1_err_cut_n = 0.;
            for (auto& qp : qps_n)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                local_H1_err_cut_n += qp.second * inner_product(grad_diff , grad_diff);
                

                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
//                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;
                
//                if( std::abs(qp.second * p_diff * p_diff) > 1e-15 )
//                    std::cout<<"L2 local pressure error (NEGATIVE CUT) = "<<qp.second * p_diff * p_diff<<std::endl;
                
                p_gp->add_data( qp.first, p_num );


            }

//            std::cout<<"H1 local error (negative cut cell) = "<<local_H1_err_cut_n<<std::endl;
            RealType local_H1_err_cut_p = 0.;
            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
           
            
            
            for (auto& qp : qps_p)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                local_H1_err_cut_p += qp.second * inner_product(grad_diff , grad_diff);
                
                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
//                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;
//                if( std::abs(qp.second * p_diff * p_diff) > 1e-15 )
//                    std::cout<<"L2 local pressure error (POSITIVE CUT) = "<<qp.second * p_diff * p_diff<<std::endl;
                p_gp->add_data( qp.first, p_num );
            }
//            std::cout<<"H1 local error (positive cut cell) = "<<local_H1_err_cut_p<<std::endl;
            
            if(normal_analysis)
            {
                auto qps = integrate_interface(msh, cl, level_set_function.level_set.degree_FEM + hdi.cell_degree() , element_location::ON_INTERFACE);
                for(auto& qp:qps){
                    auto t_phi = cb.eval_basis( qp.first );
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal( qp.first ) ;
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs( v_n ) ;
                    flux_interface += qp.second * std::abs(v_n) ;
                    linf_u_n_error = std::max( linf_u_n_error , std::abs(v_n) );
                    counter_interface_pts++;
                
                }
                

                auto qps_n = integrate( msh , cl , hdi.cell_degree() , element_location::IN_NEGATIVE_SIDE);
                RealType partial_area = measure( msh, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                for(auto& qp:qps_n){
                    auto t_phi = cb.eval_basis( qp.first );
                    auto v = t_phi.transpose() * vel_cell_dofs_n;
                    rise_vel0 +=  qp.second * v[0];
                    rise_vel1 +=  qp.second * v[1];
                }


            }

        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);

            
            RealType local_H1_err_uncut = 0.;
            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);
                local_H1_err_uncut += qp.second * inner_product(grad_diff , grad_diff);
                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
//                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;
//                if( std::abs(qp.second * p_diff * p_diff) > 1e-15 )
//                    std::cout<<"L2 local pressure error (UNCUT) = "<<qp.second * p_diff * p_diff<<std::endl;
                p_gp->add_data( qp.first, p_num );
            }
//            std::cout<<"H1 local error (uncut cell) = "<<local_H1_err_uncut<<std::endl;
            if(normal_analysis)
            {
                auto qps = integrate( msh , cl , degree+1 );

                RealType partial_area = measure( msh, cl );
                area_fin += partial_area;

                for(auto& qp:qps){
                    auto t_phi = cb.eval_basis( qp.first );
                    auto v = t_phi.transpose() * vel_cell_dofs;
                    rise_vel0 +=  qp.second * v[0];
                    rise_vel1 +=  qp.second * v[1];
                }
            }
        }

    }



    postoutput.add_object(uT1_gp);
    postoutput.add_object(uT2_gp);
    postoutput.add_object(p_gp);
    postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if(normal_analysis)
    {
        TI.l1_normal_vel = l1_u_n_error/counter_interface_pts ;
        TI.flux_interface = flux_interface;
        TI.linf_normal_vel = linf_u_n_error ;
    }
  

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << TI.l1_normal_vel << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << TI.linf_normal_vel<< std::endl;
    std::cout << bold << green << "Flux interface:               " << flux_interface << std::endl;
    std::cout << bold << green << "Rise velocity x :               " << rise_vel0/area_fin  << std::endl;
    std::cout << bold << green << "Rise velocity y :               " << rise_vel1/area_fin << std::endl;
    std::cout << bold << green << "|Rise velocity| :               " << std::abs(rise_vel0/area_fin) + std::abs(rise_vel1/area_fin) << std::endl;
    std::cout << bold << green << "Rise velocity :               " << rise_vel0/area_fin + rise_vel1/area_fin  << std::endl;

    if (0)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        // Add by Stefano
        Eigen::BDCSVD<Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
        double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size()-1);
        std::cout<<"cond_numb = "<<cond<<std::endl;

        /*
        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        */
        TI.cond = cond;
        //std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
         //         << sigma_min << "  cond = " << cond
         //         << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;



    return TI;
}

template<typename Mesh, typename testType, typename meth , typename Fonction , typename Velocity >
stokes_test_info<typename Mesh::coordinate_type>
run_cuthho_interface_numerical_ls_velocity(const Mesh& msh, size_t degree, meth& method, testType& test_case ,  Fonction & level_set_function , Velocity& velocity ,  bool normal_analysis = FALSE )
{
    using RealType = typename Mesh::coordinate_type;

    bool sym_grad = true ;

    struct params<RealType> parms = test_case.parms;


    auto bcs_vel = test_case.bcs_vel;
    test_case.test_case_mesh_assignment(msh) ;

    timecounter tc;

    bool sc = true; // static condensation

    std::cout<<"WARNING: interface integration points made by linear approximation. Integration error h^2 order. To be developped higher order integration."<<std::endl;


    /************** ASSEMBLE PROBLEM **************/
    hho_degree_info hdi(degree+1, degree);

    tc.tic();
    auto assembler = make_stokes_interface_assembler(msh, bcs_vel, hdi);
    auto assembler_sc = make_stokes_interface_condensed_assembler(msh, bcs_vel, hdi);
    // Dir condition out the for loop -> CHECK IT

    assembler_sc.set_dir_func( bcs_vel );
    for (auto& cl : msh.cells)
    {

        test_case.test_case_cell_assignment(cl);

        auto contrib = method.make_contrib(msh, cl, test_case, hdi);
        auto lc = contrib.first;
        auto f = contrib.second;

        if( sc )
            assembler_sc.assemble(msh, cl, lc, f);
        else
            assembler.assemble(msh, cl, lc, f);
    }

    if( sc )
        assembler_sc.finalize();
    else
        assembler.finalize();

    tc.toc();
    std::cout << bold << yellow << "Matrix assembly: " << tc << " seconds" << reset << std::endl;

    if( sc )
        std::cout << "System unknowns: " << assembler_sc.LHS.rows() << std::endl;
    else
        std::cout << "System unknowns: " << assembler.LHS.rows() << std::endl;

    std::cout << "Cells: " << msh.cells.size() << std::endl;
    std::cout << "Faces: " << msh.faces.size() << std::endl;

    /************** SOLVE **************/
    tc.tic();
#if 1
    SparseLU<SparseMatrix<RealType>>  solver;
    Matrix<RealType, Dynamic, 1> sol;

    if( sc )
    {
        solver.analyzePattern(assembler_sc.LHS);
        solver.factorize(assembler_sc.LHS);
        sol = solver.solve(assembler_sc.RHS);
    }
    else
    {
        solver.analyzePattern(assembler.LHS);
        solver.factorize(assembler.LHS);
        sol = solver.solve(assembler.RHS);
    }
#endif
#if 0
    Matrix<RealType, Dynamic, 1> sol;
    cg_params<RealType> cgp;
    cgp.histfile = "cuthho_cg_hist.dat";
    cgp.verbose = true;
    cgp.apply_preconditioner = true;
    if( sc )
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler_sc.RHS.rows());
        cgp.max_iter = assembler_sc.LHS.rows();
        conjugated_gradient(assembler_sc.LHS, assembler_sc.RHS, sol, cgp);
    }
    else
    {
        sol = Matrix<RealType, Dynamic, 1>::Zero(assembler.RHS.rows());
        cgp.max_iter = assembler.LHS.rows();
        conjugated_gradient(assembler.LHS, assembler.RHS, sol, cgp);
    }
#endif
    tc.toc();
    std::cout << bold << yellow << "Linear solver: " << tc << " seconds" << reset << std::endl;

    /************** POSTPROCESS **************/


    postprocess_output<RealType>  postoutput;

    auto uT1_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT1.dat");
    auto uT2_gp  = std::make_shared< gnuplot_output_object<RealType> >("interface_uT2.dat");
    auto p_gp    = std::make_shared< gnuplot_output_object<RealType> >("interface_p.dat");

    tc.tic();
    RealType    H1_error = 0.0;
    RealType    L2_error = 0.0;
    RealType    L2_pressure_error = 0.0;
    RealType    l1_u_n_error = 0.0;
    RealType    l2_u_n_error = 0.0;
    RealType    linf_u_n_error = 0.0;
    size_t      counter_interface_pts = 0;
    RealType flux_interface = 0.0;
    RealType rise_vel0 = 0.0 , rise_vel1 = 0.0 , area_fin = 0.0 ;


    for (auto& cl : msh.cells)
    {
        vector_cell_basis<cuthho_poly_mesh<RealType>, RealType> cb(msh, cl, hdi.cell_degree());
        cell_basis<cuthho_poly_mesh<RealType>, RealType> pb(msh, cl, hdi.face_degree());
        auto cbs = cb.size();
        auto pbs = pb.size();

        Matrix<RealType, Dynamic, 1> vel_locdata_n, vel_locdata_p, vel_locdata;
        Matrix<RealType, Dynamic, 1> P_locdata_n, P_locdata_p, P_locdata;
        Matrix<RealType, Dynamic, 1> vel_cell_dofs_n, vel_cell_dofs_p, vel_cell_dofs;


        level_set_function.cell_assignment(cl);
        test_case.test_case_cell_assignment(cl) ;

        auto rhs_fun = test_case.rhs_fun;
        auto sol_vel = test_case.sol_vel;
        auto sol_p = test_case.sol_p;
        auto vel_grad = test_case.vel_grad;
        auto bcs_vel = test_case.bcs_vel;
        auto neumann_jump = test_case.neumann_jump;

        //assembler_sc.set_dir_func( bcs_vel);


        if (location(msh, cl) == element_location::ON_INTERFACE)
        {
            if( sc )
            {
                vel_locdata_n = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata_n = assembler.take_velocity(msh, cl, sol, element_location::IN_NEGATIVE_SIDE);
                vel_locdata_p = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata_n = assembler.take_pressure(msh,cl, sol, element_location::IN_NEGATIVE_SIDE);
                P_locdata_p = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }

            vel_cell_dofs_n = vel_locdata_n.head(cbs);
            vel_cell_dofs_p = vel_locdata_p.head(cbs);

            //---------------------- Updating velocity field by STE ----------------------

            if ( level_set_function.subcells.size()<1 )  // NOT AGGLO CELL
            {
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells.size() == 2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    if( level_set_function(ln_Qk) > 0.0 )
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        i_local++;
                    }
                    else
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        i_local++;
                    }
                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];

                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        if( level_set_function(ln_Qk) > 0.0 )
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_p;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);

                            i_local++;
                        }
                        else
                        {
                            auto phi_HHO = cb.eval_basis( ln_Qk );
                            auto vel = phi_HHO.transpose() * vel_cell_dofs_n;
                            velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                            velocity.sol_HHO.second(i_local,offset_old) = vel(1);

                            i_local++;
                        }
                    }

                } // FINE FOR
            } // FINE ELSE


            auto qps_n = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_NEGATIVE_SIDE);
            for (auto& qp : qps_n)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_n(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);


                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_n;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_n);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );


            }

            auto qps_p = integrate(msh, cl, 2*hdi.cell_degree(), element_location::IN_POSITIVE_SIDE);
            for (auto& qp : qps_p)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs_p(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs_p;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata_p);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            if(normal_analysis)
            {
                for(auto& interface_point : cl.user_data.interface)
                {
                    auto t_phi = cb.eval_basis( interface_point );
                    auto v = t_phi.transpose() * vel_cell_dofs_p;
                    auto n = level_set_function.normal( interface_point ) ;
                    auto v_n = v.dot(n);
                    l1_u_n_error += std::abs( v_n ) ;
                    l2_u_n_error += pow(v_n,2.0);
                    linf_u_n_error = std::max( linf_u_n_error , std::abs(v_n) );
                    counter_interface_pts++;
                }

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    RealType segment = ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    auto t_phi0 = cb.eval_basis( *interface_point );
                    auto v0 = t_phi0.transpose() * vel_cell_dofs_p;
                    auto n0 = level_set_function.normal( *interface_point ) ;
                    auto v_n0 = v0.dot(n0);

                    auto t_phi1 = cb.eval_basis( *(interface_point+1) );
                    auto v1 = t_phi1.transpose() * vel_cell_dofs_p;
                    auto n1 = level_set_function.normal( *(interface_point+1) ) ;
                    auto v_n1 = v1.dot(n1);

                    flux_interface += segment * 0.5*( v_n0 + v_n1 ) ;

                }

                auto qps = integrate( msh , cl , degree+1 , element_location::IN_NEGATIVE_SIDE);
                RealType partial_area = measure( msh, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                for(auto& qp:qps){
                    auto t_phi = cb.eval_basis( qp.first );
                    auto v = t_phi.transpose() * vel_cell_dofs_n;
                    rise_vel0 +=  qp.second * v[0];
                    rise_vel1 +=  qp.second * v[1];
                }


            }

        }
        else
        {
            if( sc )
            {
                vel_locdata = assembler_sc.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler_sc.take_pressure(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            else
            {
                vel_locdata = assembler.take_velocity(msh, cl, sol, element_location::IN_POSITIVE_SIDE);
                P_locdata = assembler.take_pressure(msh,cl, sol, element_location::IN_POSITIVE_SIDE);
            }
            vel_cell_dofs = vel_locdata.head(cbs);


            //---------------------- Updating velocity field by STE ----------------------

            if ( level_set_function.subcells.size()<1 ) // NOT AGGLO CELL
            {
                assert(level_set_function.agglo_LS_cl.user_data.offset_subcells.size()==2);
                assert( level_set_function.agglo_LS_cl.user_data.offset_subcells[0] == level_set_function.agglo_LS_cl.user_data.offset_subcells[1] );
                auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[0];
                auto cl_old = velocity.msh.cells[offset_old];
                auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                size_t i_local = 0;
                for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                {
                    auto phi_HHO = cb.eval_basis( ln_Qk );
                    auto vel = phi_HHO.transpose() * vel_cell_dofs;
                    velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                    velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                    i_local++;

                }

            }
            else // AGGLO CELL
            {
                for(size_t i_subcell = 0 ; i_subcell < level_set_function.agglo_LS_cl.user_data.offset_subcells.size() ; i_subcell++ )
                {
                    auto offset_old = level_set_function.agglo_LS_cl.user_data.offset_subcells[i_subcell];

                    auto cl_old = velocity.msh.cells[offset_old];
                    auto Lagrange_nodes_Qk = equidistriduted_nodes_ordered_bis<RealType,Mesh> (velocity.msh,cl_old,velocity.degree_FEM);
                    size_t i_local = 0;
                    for ( const auto & ln_Qk : Lagrange_nodes_Qk)
                    {
                        auto phi_HHO = cb.eval_basis( ln_Qk );
                        auto vel = phi_HHO.transpose() * vel_cell_dofs;
                        velocity.sol_HHO.first(i_local,offset_old) = vel(0);
                        velocity.sol_HHO.second(i_local,offset_old) = vel(1);
                        i_local++;

                    }

                }
            }






            auto qps = integrate(msh, cl, 2*hdi.cell_degree());
            for (auto& qp : qps)
            {
                /* Compute H1-error */
                auto t_dphi = cb.eval_gradients( qp.first );
                Matrix<RealType, 2, 2> grad = Matrix<RealType, 2, 2>::Zero();

                for (size_t i = 1; i < cbs; i++ )
                    grad += vel_cell_dofs(i) * t_dphi[i].block(0, 0, 2, 2);

                Matrix<RealType, 2, 2> grad_diff = vel_grad(qp.first) - grad;
                H1_error += qp.second * inner_product(grad_diff , grad_diff);

                /* Compute L2-error */
                auto t_phi = cb.eval_basis( qp.first );
                auto v = t_phi.transpose() * vel_cell_dofs;
                Matrix<RealType, 2, 1> sol_diff = sol_vel(qp.first) - v;
                L2_error += qp.second * sol_diff.dot(sol_diff);

                uT1_gp->add_data( qp.first, v(0) );
                uT2_gp->add_data( qp.first, v(1) );

                /* L2 - pressure - error */
                auto p_phi = pb.eval_basis( qp.first );
                RealType p_num = p_phi.dot(P_locdata);
                RealType p_diff = test_case.sol_p( qp.first ) - p_num;
                auto p_prova = test_case.sol_p( qp.first ) ;
                //std::cout<<"pressure ANAL  = "<<p_prova<<std::endl;
                L2_pressure_error += qp.second * p_diff * p_diff;

                p_gp->add_data( qp.first, p_num );
            }

            if(normal_analysis)
            {
                auto qps = integrate( msh , cl , degree+1 , element_location::IN_NEGATIVE_SIDE);

                RealType partial_area = measure( msh, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                for(auto& qp:qps){
                    auto t_phi = cb.eval_basis( qp.first );
                    auto v = t_phi.transpose() * vel_cell_dofs;
                    rise_vel0 +=  qp.second * v[0];
                    rise_vel1 +=  qp.second * v[1];
                }
            }
        }

    }



    //postoutput.add_object(uT1_gp);
    //postoutput.add_object(uT2_gp);
    //postoutput.add_object(p_gp);
    //postoutput.write();



    stokes_test_info<RealType> TI;
    TI.H1_vel = std::sqrt(H1_error);
    TI.L2_vel = std::sqrt(L2_error);
    TI.L2_p = std::sqrt(L2_pressure_error);

    if(normal_analysis)
    {
        TI.l1_normal_vel = l1_u_n_error/counter_interface_pts ;
        TI.l2_normal_vel = std::sqrt(l2_u_n_error/counter_interface_pts);
        TI.linf_normal_vel = linf_u_n_error ;
    }
    std::cout<<"Error H1(u) = "<<TI.H1_vel << " , error L2(u) = "<<TI.L2_vel << " , error L2(p) = "<<TI.L2_p << "."<<'\n'<< "Error l2(u*n) = "<<TI.l2_normal_vel << " , error linf(u*n) = "<<TI.linf_normal_vel<< "Flux interface = "<<flux_interface<<std::endl;

    std::cout << bold << green << "Energy-norm absolute error:           " << std::sqrt(H1_error) << std::endl;
    std::cout << bold << green << "L2-norm absolute error:               " << std::sqrt(L2_error) << std::endl;
    std::cout << bold << green << "Pressure L2-norm absolute error:      " << std::sqrt(L2_pressure_error) << std::endl;
    std::cout << bold << green << "l1-norm u*n error:               " << TI.l1_normal_vel << std::endl;
    std::cout << bold << green << "l2-norm u*n error:               " << TI.l2_normal_vel << std::endl;
    std::cout << bold << green << "linf-norm u*n error:               " << TI.linf_normal_vel<< std::endl;
    std::cout << bold << green << "Flux interface:               " << flux_interface << std::endl;
    std::cout << bold << green << "Rise velocity x :               " << rise_vel0/area_fin  << std::endl;
    std::cout << bold << green << "Rise velocity y :               " << rise_vel1/area_fin << std::endl;
    std::cout << bold << green << "|Rise velocity| :               " << std::abs(rise_vel0/area_fin) + std::abs(rise_vel1/area_fin) << std::endl;
    std::cout << bold << green << "Rise velocity :               " << rise_vel0/area_fin + rise_vel1/area_fin  << std::endl;

    if (0)
    {
        /////////////// compute condition number
        SparseMatrix<RealType> Mat;
        // Matrix<RealType, Dynamic, Dynamic> Mat;
        if (sc)
            Mat = assembler_sc.LHS;
        else
            Mat = assembler.LHS;


        // Add by Stefano
        Eigen::BDCSVD<Eigen::MatrixXd> SVD(Mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
        double cond = SVD.singularValues()(0) / SVD.singularValues()(SVD.singularValues().size()-1);
        std::cout<<"cond_numb = "<<cond<<std::endl;

        /*
        RealType sigma_max, sigma_min;

        // Construct matrix operation object using the wrapper class SparseSymMatProd
        Spectra::SparseSymMatProd<RealType> op(Mat);
        // Construct eigen solver object, requesting the largest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::LARGEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > max_eigs(&op, 1, 10);
        max_eigs.init();
        max_eigs.compute();
        if(max_eigs.info() == Spectra::SUCCESSFUL)
            sigma_max = max_eigs.eigenvalues()(0);


        // Construct eigen solver object, requesting the smallest eigenvalue
        Spectra::SymEigsSolver< RealType, Spectra::SMALLEST_MAGN,
                                Spectra::SparseSymMatProd<RealType> > min_eigs(&op, 1, 10);

        min_eigs.init();
        min_eigs.compute();
        if(min_eigs.info() == Spectra::SUCCESSFUL)
            sigma_min = min_eigs.eigenvalues()(0);

        // compute condition number
        RealType cond = sigma_max / sigma_min;
        */
        TI.cond = cond;
        //std::cout << "sigma_max = " << sigma_max << "   sigma_min = "
         //         << sigma_min << "  cond = " << cond
         //         << std::endl;
    }
    else
        TI.cond = 0.0;

    tc.toc();
    std::cout << bold << yellow << "Postprocessing: " << tc << " seconds" << reset << std::endl;



    return TI;
}


template< typename FiniteSpace , typename Mesh , typename T >
void check_inlet( const Mesh& msh , FiniteSpace& fe_data , bool bdry_bottom , bool bdry_right , bool bdry_up , bool bdry_left , T eps )
{
    std::cout<<"Checking inlet boundary condition for transport problem."<<std::endl;
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix = fe_data.connectivity_matrix ;


    for( const auto& cl : msh.cells )
    {
        size_t cell_offset = offset(msh, cl) ;
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++)
        {
            auto pt = pts[i];
            size_t asm_map = connectivity_matrix[cell_offset][i].first ;
            if( connectivity_matrix[cell_offset][i].second )
            {
                if(bdry_bottom && ( std::abs(pt.y()) < eps) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                if(bdry_right && (std::abs(pt.x()- 1.0) < eps) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                if(bdry_up && (std::abs(pt.y()- 1.0) < eps) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                if(bdry_left && (std::abs(pt.x()) < eps) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                else
                    fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE ;

            }
            else
                fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE ;



        }
    }

}

template< typename FiniteSpace , typename Mesh ,typename Vel_Field , typename T>
void check_inlet( const Mesh& msh , FiniteSpace& fe_data , const Vel_Field& u , T eps )
{
    std::cout<<"Checking inlet boundary condition for numerical flows."<<std::endl;
    std::vector< std::vector<std::pair<size_t,bool>>> connectivity_matrix = fe_data.connectivity_matrix ;


    for( const auto& cl : msh.cells )
    {
        size_t cell_offset = offset(msh, cl) ;
        auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
        for (size_t i = 0; i < fe_data.local_ndof; i++)
        {
            auto pt = pts[i];
            size_t asm_map = connectivity_matrix[cell_offset][i].first ;
            if( connectivity_matrix[cell_offset][i].second )
            {
                if( ( u(pt,msh,cl).second > eps ) && (pt.y() == 0.0) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                if( ( u(pt,msh,cl).first < -eps ) && (pt.x() == 1.0) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                if( ( u(pt,msh,cl).second < -eps ) && (pt.y() == 1.0) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                if( ( u(pt,msh,cl).first > eps ) && (pt.x() == 0.0) )
                    fe_data.Dirichlet_boundary_inlet[asm_map] = TRUE ;
                else
                    fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE ;

            }
            else
                fe_data.Dirichlet_boundary_inlet[asm_map] = FALSE ;



        }
    }

}





/// FATTO BY STEFANO
///// test_case_kink_velocity --> DISCRETE LEVEL SET
// !! available for circle_level_set only !!
// exact solution : u(r) sin(theta) in the whole domain for vel_component 1
//                 -u(r) cos(theta) in the whole domain for vel_component 2
//         with u(r) = r^6 / kappa_1 in Omega_1
//              u(r) = (r^6 - R^6)/kappa_2 + R^6/kappa_1 in Omega_2
//                   sin(x+y)     in the whole domain for p
// \kappa_1 , \kappa_2 given
template<typename T, typename Mesh, typename Function >
class test_case_eshelby: public test_case_stokes<T, Function , Mesh>
{
  public:
   test_case_eshelby(const Function & level_set__, params<T> parms_, bool sym_grad)
       : test_case_stokes<T, Function , Mesh>
       (level_set__, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // sol_vel
           Matrix<T, 2, 1> ret;
           T C = 2.0;
           T mid_point = 1.0/2.0;
           T x1 = pt.x() - mid_point ;
           T y1 = mid_point - pt.y() ;
           ret(0) = C*x1 ;
           ret(1) = C*y1 ;


           return ret;},
        [level_set__](const typename Mesh::point_type& pt) -> T { // p
            //return 1.0;

           T k = 1.0;
           T R = 1.0/3.0;
           if(level_set__(pt) < 0)
               return k / R - M_PI * R * k;
            else
                return -M_PI * R * k;

       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;
           T C = 2.0;
           T mid_point = 1.0/2.0;
           T x1 = pt.x() - mid_point ;
           T y1 = mid_point - pt.y() ;
           ret(0) = C*x1 ;
           ret(1) = C*y1 ;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           T C = 2.0;
           ret(0,0) = C*1.0;
           ret(0,1) = C*0.0;
           ret(1,0) = C*0.0;
           ret(1,1) = C*(-1.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,parms_,sym_grad](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Neu */
            Matrix<T, 2, 1> ret;
            if(sym_grad)
            {
                T gamma = 1.0;
                //T k = 1.0;
                //T R = 1.0/3.0;

                //T H = level_set__.normal(pt)
                ret(0) = 2.0*gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = 2.0*gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);

                //ret(0) = - k / R * level_set__.normal(pt)(0);
                //ret(1) = - k / R * level_set__.normal(pt)(1);

            }
            else
            {
                ret(0) = 0.0;
                ret(1) = 0.0;
            }
            return ret;})
       {}
};

template<typename Mesh, typename T, typename Function>
auto make_test_case_eshelby(const Mesh& msh, const Function& level_set_function, params<T> parms_, bool sym_grad)
{
   return test_case_eshelby<typename Mesh::coordinate_type, Mesh , Function>(level_set_function,parms_,sym_grad);
}

/// FATTO BY STEFANO
// Starting from an elliptic level set -> final circle equilibrium
// exact solution : u = 0
//                  constant = \kappa    in the whole domain for p
// \kappa  given

template<typename T, typename Mesh, typename Function >
class test_case_eshelby_2: public test_case_stokes<T, Function , Mesh>
{
  public:
   test_case_eshelby_2(const Function & level_set__, params<T> parms_, bool sym_grad)
       : test_case_stokes<T, Function , Mesh>
       (level_set__, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {
           // sol_vel
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;

           return ret;},
        [level_set__](const typename Mesh::point_type& pt) -> T { // p

           return 0.0;

       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           ret(0,0) = 0.0;
           ret(0,1) = 0.0;
           ret(1,0) = 0.0;
           ret(1,1) = (0.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,sym_grad](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Neu */
            Matrix<T, 2, 1> ret;
            if(sym_grad)
            {
                T gamma = 1.0;
                //T k = 1.0;
                //T R = 1.0/3.0;

                //T H = level_set__.normal(pt)

                ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);


                //ret(0) = - k / R * level_set__.normal(pt)(0);
                //ret(1) = - k / R * level_set__.normal(pt)(1);

            }
            else
            {
                T gamma = 1.0;

                ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);
            }
            return ret;})
       {}
};

template<typename Mesh, typename T, typename Function>
auto make_test_case_eshelby_2(const Mesh& msh, const Function& level_set_function, params<T> parms_, bool sym_grad)
{
   return test_case_eshelby_2<typename Mesh::coordinate_type, Mesh , Function>(level_set_function,parms_,sym_grad);
}



template<typename T, typename Mesh, typename Function >
class test_case_eshelby_2_prova: public test_case_stokes<T, Function , Mesh>
{

public:

    Mesh m_msh  ;
    typename Mesh::cell_type m_cl ;
//    Mesh* msh_pt ;
//    typename Mesh::cell_type* cl_pt ;
//    size_t i = 2;
    //std::shared_ptr<typename Mesh::cell_type> cl_pointer;

    explicit test_case_eshelby_2_prova( Function & level_set__, params<T> parms_, bool sym_grad)
       : test_case_stokes<T, Function , Mesh>
       (level_set__, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {
           // sol_vel
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;

           return ret;},
        [level_set__](const typename Mesh::point_type& pt) -> T { // p



           return 0.0;

       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           ret(0,0) = 0.0;
           ret(0,1) = 0.0;
           ret(1,0) = 0.0;
           ret(1,1) = (0.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,sym_grad,this](const typename Mesh::point_type& pt) mutable -> Eigen::Matrix<T, 2, 1> {/* Neu */
            Matrix<T, 2, 1> ret;
            if(sym_grad)
            {
                T gamma = 1.0;
                //T k = 1.0;
                //T R = 1.0/3.0;
                //cl = cl_pointer.get() ;
                //std::cout<<"SONO  IN NEUMANN CONDITION."<<std::endl;
//                std::cout<<"i = "<<i<<std::endl;
                //auto cl_uploaded = this->cl ;
//                i++;
//                std::cout<<"i = "<<i<<std::endl;
//                Mesh msh_prova = *msh_pt ;
//                typename Mesh::cell_type cl_prova = *cl_pt ;


//                std::cout<<"-----> test_case_eshelby_2_prova : CELL PROVA = "<<offset(msh_prova,cl_prova)<<std::endl;
                //if(i==3)
                //   this->cl = msh.cells[227];
                //std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(m_msh,m_cl)<<std::endl;
                /*
                auto cl_new = this->cl ;
                std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(msh,cl_new)<<std::endl;

                auto cl_new2 = upload_cl();
                std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(msh,cl_new2)<<std::endl;

                auto cl_new3 = upload_cl2();
                std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(msh,cl_new3)<<std::endl;
                */
                level_set__.cell_assignment(m_cl);
                //T H = level_set__.normal(pt)

                ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);


                //ret(0) = - k / R * level_set__.normal(pt)(0);
                //ret(1) = - k / R * level_set__.normal(pt)(1);

            }
            else
            {
                T gamma = 1.0;
                level_set__.cell_assignment(m_cl);
                ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);
            }
            return ret;})
       {}

    test_case_eshelby_2_prova(const test_case_eshelby_2_prova & other) : test_case_stokes<T, Function , Mesh>(other) {
        m_msh = other.m_msh;
        m_cl = other.m_cl;
    }

//    void test_case_cell_assignment(const Mesh& msh , const typename Mesh::cell_type& cl_new )
//    {
//        std::cout<<"sono qua 0"<<std::endl;
//        std::cout<<"-----> test_case_cell_assignment : CELL OLD = "<<offset(msh,cl)<<std::endl;
//        std::cout<<"sono qua 1"<<std::endl;
//        std::cout<<"-----> test_case_cell_assignment : CELL NEW = "<<offset(msh,cl_new)<<std::endl;
//        cl = cl_new ;
//        cl_pt = & cl;
//        //msh = msh ;
//        std::cout<<"----------------> test_case_cell_assignment : CELL NEW = "<<offset(msh,cl_new)<< " and CELL UPLOADED = "<<offset(msh,cl)<<std::endl;
//        std::cout<<"----------------> test_case_cell_assignment : CELL NEW PUNTATORE = "<<offset(msh,*cl_pt)<<std::endl;
//        i+=8;
//        //cl_pointer = std::make_shared<typename Mesh::cell_type>(cl_new);
//        //std::cout<<"----------------> test_case_cell_assignment : CELL POINTER = "<<offset(msh, cl_pointer.get())<< " and CELL UPLOADED = "<<offset(msh,cl)<<std::endl;
//        //level_set__.cell_assignment(cl_new);
//    }

    void test_case_cell_assignment(const typename Mesh::cell_type& cl_new )
    {
        m_cl = cl_new ;
    }

    void refresh_lambdas(Function & level_set__, params<T> parms_, bool sym_grad){

       this->neumann_jump = [level_set__,sym_grad,this](const typename Mesh::point_type& pt) mutable -> Eigen::Matrix<T, 2, 1> {/* Neu */
                    Matrix<T, 2, 1> ret;
                    if(sym_grad)
                    {
                        T gamma = 1.0;
                        //T k = 1.0;
                        //T R = 1.0/3.0;
                        //cl = cl_pointer.get() ;
                        //std::cout<<"SONO  IN NEUMANN CONDITION."<<std::endl;
        //                std::cout<<"i = "<<i<<std::endl;
                        //auto cl_uploaded = this->cl ;
        //                i++;
        //                std::cout<<"i = "<<i<<std::endl;
        //                Mesh msh_prova = *msh_pt ;
        //                typename Mesh::cell_type cl_prova = *cl_pt ;


        //                std::cout<<"-----> test_case_eshelby_2_prova : CELL PROVA = "<<offset(msh_prova,cl_prova)<<std::endl;
                        //if(i==3)
                        //   this->cl = msh.cells[227];
                        //std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(m_msh,m_cl)<<std::endl;
                        /*
                        auto cl_new = this->cl ;
                        std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(msh,cl_new)<<std::endl;

                        auto cl_new2 = upload_cl();
                        std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(msh,cl_new2)<<std::endl;

                        auto cl_new3 = upload_cl2();
                        std::cout<<"-----> test_case_eshelby_2_prova : CELL = "<<offset(msh,cl_new3)<<std::endl;
                        */
                        level_set__.cell_assignment(m_cl);
                        //T H = level_set__.normal(pt)

                        ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                        ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);


                        //ret(0) = - k / R * level_set__.normal(pt)(0);
                        //ret(1) = - k / R * level_set__.normal(pt)(1);

                    }
                    else
                    {
                        T gamma = 1.0;
                        level_set__.cell_assignment(m_cl);
                        ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                        ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);
                    }
           return ret;
       };

    }

    void test_case_mesh_assignment(const Mesh& msh_new )
    {

        //std::cout<<"-----> test_case_mesh_assignment "<<std::endl;
        m_msh = msh_new ;
//        msh_pt = & msh ;

    }

    typename Mesh::cell_type& upload_cl()
    {
        return m_cl ;
    }
    /*
    typename Mesh::cell_type upload_cl2()
    {
        return m_cl ;
    }
    */


};

template<typename Mesh, typename T, typename Function>
auto make_test_case_eshelby_2_prova(const Mesh& msh, Function& level_set_function, params<T> parms_, bool sym_grad)
{
   return test_case_eshelby_2_prova<typename Mesh::coordinate_type, Mesh , Function>(level_set_function,parms_,sym_grad);
}



template<typename T, typename Mesh, typename Function >
class test_case_eshelby_analytic: public test_case_stokes<T, Function , Mesh>
{
  public:
   test_case_eshelby_analytic(const Function & level_set__, params<T> parms_, bool sym_grad , T radius)
       : test_case_stokes<T, Function , Mesh>
       (level_set__, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {
           // sol_vel
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;

           return ret;},
        [level_set__](const typename Mesh::point_type& pt) -> T { // p

           return 0.0;

       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           ret(0,0) = 0.0;
           ret(0,1) = 0.0;
           ret(1,0) = 0.0;
           ret(1,1) = (0.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,parms_,sym_grad,radius](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Neu */
            Matrix<T, 2, 1> ret;
            if(sym_grad)
            {
                T gamma = 1.0;
                //T k = 1.0;
                //T R = 1.0/3.0;

                //T H = level_set__.normal(pt)
                //ret(0) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                //ret(1) = 2.0 * gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);

                ret(0) = gamma * radius * level_set__.normal(pt)(0);

                ret(1) = gamma * radius * level_set__.normal(pt)(1);

                //ret(0) = - k / R * level_set__.normal(pt)(0);
                //ret(1) = - k / R * level_set__.normal(pt)(1);

            }
            else
            {
                T gamma = 1.0;

                ret(0) =  gamma * radius * level_set__.normal(pt)(0);
                ret(1) =  gamma * radius * level_set__.normal(pt)(1);
            }
            return ret;})
       {}
};




template<typename Mesh, typename T, typename Function>
auto make_test_case_eshelby_analytic(const Mesh& msh, const Function& level_set_function, params<T> parms_, bool sym_grad, T radius)
{
   return test_case_eshelby_analytic<typename Mesh::coordinate_type, Mesh , Function>(level_set_function,parms_,sym_grad,radius);
}




// --> TEST CASE (ESHELBY PB WITH mu_1 = mu_2): it should be correct! W.r.t. test_case_eshelby_2_prova changes the pressure solution (now it's correct, before no)

template<typename T, typename Mesh, typename Function >
class test_case_eshelby_correct: public test_case_stokes<T, Function , Mesh>
{

public:

    Mesh m_msh  ;
    typename Mesh::cell_type m_cl ;
    T gamma = 1.0;

    explicit test_case_eshelby_correct( Function & level_set__, params<T> parms_, bool sym_grad, T gamma)
       : gamma(gamma), test_case_stokes<T, Function , Mesh>
       (level_set__, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {
           // sol_vel
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;

           return ret;},
        [level_set__,gamma,this](const typename Mesh::point_type& pt) mutable ->  T { // p

           //T gamma = 0.05 ; // 1.0 ;
           //T gamma = this->gamma;
           level_set__.cell_assignment(m_cl);
           T R = level_set__.radius ;
           //std::cout<<"pressure, cl= "<<offset(m_msh,m_cl) <<std::endl;
           //std::cout<<"The radius = "<<R<<" , the divergence = "<<level_set__.divergence(pt)<<std::endl;
           

            if( level_set__(pt) < 0 )
                return gamma / R - M_PI * R * gamma;
            else
                return -M_PI * R * gamma;


       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           ret(0,0) = 0.0;
           ret(0,1) = 0.0;
           ret(1,0) = 0.0;
           ret(1,1) = (0.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,sym_grad,gamma,this](const typename Mesh::point_type& pt) mutable -> Eigen::Matrix<T, 2, 1> {/* Neu */
            Matrix<T, 2, 1> ret;
            //T gamma = this->gamma;
            if(sym_grad)
            {
                //T gamma = 0.05 ; // 1.0 ;

                level_set__.cell_assignment(m_cl);
                //T H = level_set__.normal(pt)
                //std::cout<<"neumann cond, cl= "<<offset(m_msh,m_cl) <<std::endl;

                // NEW NEUMANN COND WITHOUT 2*
                ret(0) = gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);

                // TENTATIVO PER CAPIRE DOVE NASCE L'ERRORE
//                T R = level_set__.radius ;
//                ret(0) = - gamma / R * level_set__.normal(pt)(0);
//                ret(1) = - gamma / R * level_set__.normal(pt)(1);

            }
            else
            {
                //T gamma = 0.05 ; // 1.0 ;
                level_set__.cell_assignment(m_cl);
                //std::cout<<"neumann cond, cl= "<<offset(m_msh,m_cl) ;
                
                
                // NEW NEUMANN COND WITHOUT 2* (DA  RIMETTERE)
                ret(0) = gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) = gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);

                // TENTATIVO PER CAPIRE DOVE NASCE L'ERRORE
//                T R = level_set__.radius ;
//                ret(0) = - gamma / R * level_set__.normal(pt)(0);
//                ret(1) = - gamma / R * level_set__.normal(pt)(1);
                

            }
            return ret;})
       {}

    test_case_eshelby_correct(const test_case_eshelby_correct & other) : test_case_stokes<T, Function , Mesh>(other) {
        m_msh = other.m_msh;
        m_cl = other.m_cl;
        gamma = other.gamma;
    }


    void test_case_cell_assignment(const typename Mesh::cell_type& cl_new )
    {
        m_cl = cl_new ;
    }
    /*
    void refresh_lambdas(Function & level_set__, params<T> parms_, bool sym_grad){

       this->neumann_jump = [level_set__,sym_grad,this](const typename Mesh::point_type& pt) mutable -> Eigen::Matrix<T, 2, 1> {// Neu //

           //T gamma = this->gamma;
           Matrix<T, 2, 1> ret;
           if(sym_grad)
           {
               //T gamma = 0.05 ; // 1.0 ;


               level_set__.cell_assignment(m_cl);
               //T H = level_set__.normal(pt)
               //std::cout<<"gamma = "<<gamma<<std::endl;
               ret(0) = gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
               ret(1) = gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);

               // TENTATIVO PER CAPIRE DOVE NASCE L'ERRORE

               //T R = level_set__.radius ;
               //ret(0) = - gamma / R * level_set__.normal(pt)(0);
               //ret(1) = - gamma / R * level_set__.normal(pt)(1);
               //T k_curv = level_set__.divergence(pt) ;
               //T curvature_err = std::abs(std::abs(k_curv) -1.0/R ) ;

               //std::cout<<"R = "<<R<<" , level_set__.divergence(pt) = "<<k_curv<<std::endl;
               //std::cout<<"interface_point = "<<pt<<" , curvature = "<<k_curv<<" , 1/R = "<<-1.0/R<<" , diff = "<< curvature_err <<std::endl;
            }
            else
            {
                //T gamma = 0.05 ; // 1.0 ;
                level_set__.cell_assignment(m_cl);
                ret(0) =  gamma * level_set__.divergence(pt) * level_set__.normal(pt)(0);
                ret(1) =  gamma * level_set__.divergence(pt) * level_set__.normal(pt)(1);
                // TENTATIVO PER CAPIRE DOVE NASCE L'ERRORE
                //T R = level_set__.radius ;
                //ret(0) = - gamma / R * level_set__.normal(pt)(0);
                //ret(1) = - gamma / R * level_set__.normal(pt)(1);
            }

           return ret;
       };

        this->sol_p = [level_set__,this](const typename Mesh::point_type& pt) mutable -> T {// Pressure //

            //T gamma = this->gamma;
            //T gamma = 0.05 ; // 1.0 ;
            level_set__.cell_assignment(m_cl);
            T R = level_set__.radius ;
            //std::cout<<"gamma = "<<gamma<<std::endl;

            //std::cout<<"The radius = "<<R<<" , the divergence = "<<level_set__.divergence(pt)<<std::endl;

            if( level_set__(pt) < 0 )
                return gamma / R - M_PI * R * gamma;
            else
                return -M_PI * R * gamma;


        };

    }
    */
    void test_case_mesh_assignment(const Mesh& msh_new )
    {

        //std::cout<<"-----> test_case_mesh_assignment "<<std::endl;
        m_msh = msh_new ;
//        msh_pt = & msh ;

    }
    /*
    void test_case_gamma_setting(T gamma_n )
    {

        std::cout<<"-----> setting of gamma "<<std::endl;
        gamma = gamma_n ;

    }
    */
    typename Mesh::cell_type& upload_cl()
    {
        return m_cl ;
    }
    /*
    typename Mesh::cell_type upload_cl2()
    {
        return m_cl ;
    }
    */


};

template<typename Mesh, typename T, typename Function>
auto make_test_case_eshelby_correct(const Mesh& msh, Function& level_set_function, params<T> parms_, bool sym_grad, T gamma )
{
   return test_case_eshelby_correct<typename Mesh::coordinate_type, Mesh , Function>(level_set_function,parms_,sym_grad,gamma);
}


// --> TEST CASE (ESHELBY PB WITH mu_1 = mu_2): it should be correct! W.r.t. test_case_eshelby_2_prova changes the pressure solution (now it's correct, before no)

template<typename T, typename Mesh, typename Function >
class test_case_eshelby_correct_parametric: public test_case_stokes_ref_pts<T, Function , Mesh>
{

public:

    Mesh m_msh  ;
    typename Mesh::cell_type m_cl ;
    T gamma = 1.0;

    explicit test_case_eshelby_correct_parametric( Function & level_set__, params<T> parms_, bool sym_grad, T gamma)
       : gamma(gamma), test_case_stokes_ref_pts<T, Function , Mesh>
       (level_set__, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {
           // sol_vel
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;

           return ret;},
        [level_set__,gamma,this](const typename Mesh::point_type& pt) mutable ->  T { // p

           //T gamma = 0.05 ; // 1.0 ;
           //T gamma = this->gamma;
           level_set__.cell_assignment(m_cl);
           T R = level_set__.radius ;
           //std::cout<<"pressure, cl= "<<offset(m_msh,m_cl) <<std::endl;
           //std::cout<<"The radius = "<<R<<" , the divergence = "<<level_set__.divergence(pt)<<std::endl;
           

            if( level_set__(pt) < 0 )
                return gamma / R - M_PI * R * gamma;
            else
                return -M_PI * R * gamma;


       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           ret(0,0) = 0.0;
           ret(0,1) = 0.0;
           ret(1,0) = 0.0;
           ret(1,1) = (0.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,sym_grad,gamma,this](const T& pt, const std::vector<typename Mesh::point_type>& pts ) mutable -> Eigen::Matrix<T, 2, 1> {/* Neu */
//           , const std::vector<typename Mesh::point_type>& pts
//           auto pts =points(m_cl.user_data.integration_msh,m_cl.user_data.integration_msh.cells[0]);
           Matrix<T, 2, 1> ret;
            //T gamma = this->gamma;
            if(sym_grad)
            {
                level_set__.cell_assignment(m_cl);
                
                size_t degree = m_cl.user_data.integration_msh.degree_curve ;
                Interface_parametrisation_mesh1d curve(degree) ;
                
                ret(0) = gamma * curve.curvature(pt, pts , degree) * curve.normal(pt, pts , degree)(0);
                ret(1) = gamma * curve.curvature(pt, pts , degree) * curve.normal(pt, pts , degree)(1) ;
               
               
            }
            else
            {
                level_set__.cell_assignment(m_cl);
                
                 size_t degree = m_cl.user_data.integration_msh.degree_curve ;
                 Interface_parametrisation_mesh1d curve(degree) ;
                 ret(0) = gamma * curve.curvature(pt, pts , degree) * curve.normal(pt, pts , degree)(0);
                 ret(1) = gamma * curve.curvature(pt, pts , degree) * curve.normal(pt, pts , degree)(1) ;
                

            }
            return ret;})
       {}

    test_case_eshelby_correct_parametric(const test_case_eshelby_correct_parametric & other) : test_case_stokes_ref_pts<T, Function , Mesh>(other) {
        m_msh = other.m_msh;
        m_cl = other.m_cl;
        gamma = other.gamma;
    }


    void test_case_cell_assignment(const typename Mesh::cell_type& cl_new )
    {
        m_cl = cl_new ;
    }
    
    void test_case_mesh_assignment(const Mesh& msh_new )
    {

        //std::cout<<"-----> test_case_mesh_assignment "<<std::endl;
        m_msh = msh_new ;
//        msh_pt = & msh ;

    }
  
    typename Mesh::cell_type& upload_cl()
    {
        return m_cl ;
    }
    


};

template<typename Mesh, typename T, typename Function>
auto make_test_case_eshelby_correct_parametric(const Mesh& msh, Function& level_set_function, params<T> parms_, bool sym_grad, T gamma )
{
   return test_case_eshelby_correct_parametric<typename Mesh::coordinate_type, Mesh , Function>(level_set_function,parms_,sym_grad,gamma);
}


// --> TEST CASE (ESHELBY PB WITH mu_1 = mu_2): it should be correct! W.r.t. test_case_eshelby_2_prova changes the pressure solution (now it's correct, before no)

template<typename T, typename Mesh, typename Function ,  typename Para_Interface >
class test_case_eshelby_correct_parametric_cont: public test_case_stokes_ref_pts_cont<T, Function , Mesh,Para_Interface>
{

public:

    Mesh m_msh  ;
    typename Mesh::cell_type m_cl ;
    T gamma = 1.0;

    explicit test_case_eshelby_correct_parametric_cont( Function & level_set__, Para_Interface& parametric_curve_cont, params<T> parms_, bool sym_grad, T gamma)
       : gamma(gamma), test_case_stokes_ref_pts_cont<T, Function , Mesh,Para_Interface>
       (level_set__,parametric_curve_cont, parms_,
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {
           // sol_vel
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;

           return ret;},
        [level_set__,gamma,this](const typename Mesh::point_type& pt) mutable ->  T { // p

           level_set__.cell_assignment(m_cl);
           T R = level_set__.radius ;

            if( level_set__(pt) < 0 )
                return gamma / R - M_PI * R * gamma;
            else
                return -M_PI * R * gamma;


       },
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // rhs
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0 ;
            ret(1) = 0.0 ;
            return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> { // bcs
           Matrix<T, 2, 1> ret;

           ret(0) = 0.0;
           ret(1) = 0.0;
           return ret;},
        [](const typename Mesh::point_type& pt) -> auto { // grad

           Matrix<T, 2, 2> ret;
           ret(0,0) = 0.0;
           ret(0,1) = 0.0;
           ret(1,0) = 0.0;
           ret(1,1) = (0.0);
           return ret;},
        [](const typename Mesh::point_type& pt) -> Eigen::Matrix<T, 2, 1> {/* Dir */
            Matrix<T, 2, 1> ret;
            ret(0) = 0.0;
            ret(1) = 0.0;
            return ret;},
        [level_set__,parametric_curve_cont,sym_grad,gamma,this](const T& pt, const size_t& global_cl_i ) mutable -> Eigen::Matrix<T, 2, 1> {/* Neu */

           Matrix<T, 2, 1> ret;
           
            if(sym_grad)
            {
               
                ret(0) = gamma * parametric_curve_cont.curvature_cont(pt, global_cl_i) * parametric_curve_cont.normal_cont(pt, global_cl_i)(0);
                ret(1) = gamma * parametric_curve_cont.curvature_cont(pt, global_cl_i) * parametric_curve_cont.normal_cont(pt, global_cl_i)(1) ;
               
               
            }
            else
            {
                ret(0) = gamma * parametric_curve_cont.curvature_cont(pt, global_cl_i) * parametric_curve_cont.normal_cont(pt, global_cl_i)(0);
                ret(1) = gamma * parametric_curve_cont.curvature_cont(pt, global_cl_i) * parametric_curve_cont.normal_cont(pt, global_cl_i)(1) ;
                

            }
            return ret;})
       {}

    test_case_eshelby_correct_parametric_cont(const test_case_eshelby_correct_parametric_cont & other) : test_case_stokes_ref_pts_cont<T, Function , Mesh,Para_Interface>(other) {
        m_msh = other.m_msh;
        m_cl = other.m_cl;
        gamma = other.gamma;
    }


    void test_case_cell_assignment(const typename Mesh::cell_type& cl_new )
    {
        m_cl = cl_new ;
    }
    
    void test_case_mesh_assignment(const Mesh& msh_new )
    {

        m_msh = msh_new ;

    }
  
    typename Mesh::cell_type& upload_cl()
    {
        return m_cl ;
    }
    


};

template<typename Mesh, typename T, typename Function , typename Para_Interface >
auto make_test_case_eshelby_correct_parametric_cont(const Mesh& msh, Function& level_set_function, Para_Interface& parametric_curve_cont ,  params<T> parms_, bool sym_grad, T gamma )
{
   return test_case_eshelby_correct_parametric_cont<typename Mesh::coordinate_type, Mesh , Function,Para_Interface>(level_set_function,parametric_curve_cont,parms_,sym_grad,gamma);
}




// ------------------ CHECKING PARAMETRIC AND LEVEL SET CASES ------------------ //



template<typename Mesh, typename Curve ,  typename T  >
void
check_para_formulation( Mesh& msh_i, Curve& curve , size_t degree_curve,size_t degree_FEM, T radius, size_t n_int)
{
    
    typedef typename Mesh::point_type point_type;
    T tot = degree_curve ; // 100
    T tot_error = 100 ;
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para.dat");
    auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para.dat");
//    auto jacobian_plot = std::make_shared< gnuplot_output_object<double> >("jacobian_para.dat");
    for(auto& cl : msh_i.cells)
    {
        
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
             
             
            auto integration_msh = cl.user_data.integration_msh ;
        
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                for(int i = 0; i <= tot ; i++)
                {
                     T pos = 0.0+i/tot ;
                     auto p = curve(pos , pts , degree_curve ) ;
                     interface_gamma.push_back( p ) ;
                     point<T,2> curv_var0 = point_type(p(0), p(1));
                     interface_gamma_plot->add_data(curv_var0,0.0);
                     auto k = curve.curvature(pos, pts , degree_curve) ;
                     curvature_plot->add_data(curv_var0, k );
                     curvature_gamma.push_back( k ) ;
                     tangent_gamma.push_back( curve.tangent(pos, pts , degree_curve) ) ;
                     normal_gamma.push_back( curve.normal(pos, pts , degree_curve) ) ;
                    
//                    auto j = curve.jacobian(pos , pts , degree_curve ) ;
//                    point<T,2> pj = point_type(j(0), j(1));
//                    jacobian_plot->add_data(pj, 0.0 );
                }
                
                 
            }
             
             
        }
            
            
    }

     
    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
    postoutput.write();
    goal_quantities_time_fast_para(msh_i , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    
    

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T L1_divergence_error_para = 0.  ;
    T linf_divergence_error_para = -10. ;
//    T linf_divergence_error_para_bis = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            
            auto integration_msh = cl.user_data.integration_msh ;
            auto degree_int = 2*degree_curve ;
            auto qps = edge_quadrature<T>(degree_int);
//            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
            
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                for(auto& qp:qps)
                {
                 
                    auto t = 0.5 * qp.first.x() + 0.5;
                    auto k_curve = std::abs( curve.curvature(t , pts , degree_curve ) + 1.0/radius);
                    T jacobian = curve.jacobian( t , pts , degree_curve ) ;
                    auto w = 0.5 * qp.second * jacobian ;
                    L1_divergence_error_para += k_curve*w ;
//                    linf_divergence_error_para_bis = std::max(linf_divergence_error_para_bis , k_curve ) ;
                }
                for(int i = 0; i < tot_error ; i++)
                {
                    T pos = 0.0+i/tot_error ;
                    T val0 = curve.curvature(pos, pts , degree_curve) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                    
            
                }
                        
                            
            }
            
    
         }



     }

    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k0_curvature_para.dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para.dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);
    
    auto test_jacobian = std::make_shared< gnuplot_output_object<double> >("jacobian_para.dat");
    auto test_jacobian_cl = std::make_shared< gnuplot_output_object<double> >("jacobian_para_cells.dat");
    
    std::string filename_curv_var_inner_cl = "inner_cell_limit_para.dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);
    
    T distance_pts_para = 0.0;
    bool first_cut_cell_found = FALSE ;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    tot = 10 ; //degree_curve -1 ; // 10 ;
    for(auto& cl : msh_i.cells)
    {

         if(cl.user_data.location == element_location::ON_INTERFACE)
         {
//            std::cout<<"cell = "<<offset(msh_i, cl);
            auto integration_msh = cl.user_data.integration_msh ;
             
            if(!first_cut_cell_found)
            {
               
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                }
                
                size_t pos_index_bis = 0;
                
                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                {
                    auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                    
                    
//                    if( i_cell == 0)
//                        first_point = pts[0] ;
//                    if( i_cell == integration_msh.cells.size()-1)
//                        cell_end_point =  pts[1] ;
                  
                    for(int i = 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        
                        T val0 = curve.curvature(pos, pts , degree_curve) ;
//                        std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                        std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                        point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        
                        T pj = curve.jacobian(pos , pts , degree_curve ) ;
                        
                        if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0  )
                        {
                          
                            auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                            T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                            
                            test_inner_cell->add_data(curv_var, val0);
                            test_inner_cell->add_data(curv_var, valold);
                            if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                        }

                        
                        
                        if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                            test_curv_var_para->add_data(curv_var, val0);
                            test_jacobian_cl->add_data(curv_var,pj );
//                            std::cout<<"interface cell bdry -> YES "<<std::endl;
                        }
                        
                        test_curvature_para->add_data(curv_var, val0);
                        test_jacobian->add_data(curv_var,pj );
                        T dist ;
                        if(pos == 1)
                            dist = 0.0;
                        else
                            dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                        
                        distance_pts_para += dist ;
                                    
                            
                    }
                                
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {

                   
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
//                        std::cout<<"cell = "<<offset(msh_i, cl);
//                        std::cout<<"first_point =  "<<first_point<<std::endl;
//                        std::cout<<"*cl.user_data.interface.begin() =  "<<*cl.user_data.interface.begin()<<std::endl;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                        auto integration_msh = cl.user_data.integration_msh ;
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                        }
                        
                        size_t pos_index_bis = 0;
                        
                        for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                        {
                            auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                           
//                            if( i_cell == integration_msh.cells.size()-1)
//                                cell_end_point =  pts[1] ;
                            
                            for(int i = 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature(pos, pts , degree_curve) ;
                                
                                T pj = curve.jacobian(pos , pts , degree_curve ) ;
                               
//                                std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                                std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                                point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                
                                if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0 )
                                {
                                  
                                    auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                                    T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                                    
                                    test_inner_cell->add_data(curv_var, val0);
                                    test_inner_cell->add_data(curv_var, valold);
                                    if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                                }
                                
                                if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                                    test_curv_var_para->add_data(curv_var, val0);
                                    test_jacobian_cl->add_data(curv_var,pj );
//                                    std::cout<<"interface cell bdry -> YES "<<std::endl;
                                }
                                
                                test_curvature_para->add_data(curv_var, val0);
                                test_jacobian->add_data(curv_var,pj );
                                
                                T dist ;
                                if(pos == 1)
                                    dist = 0.0;
                                else
                                    dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                                
                                distance_pts_para += dist ;
                                            
                                    
                            }
                                        
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                    }
                    
                }
                
            }
            else
                break;
       
         }


    }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    
    postoutput_div_para.add_object(test_jacobian_cl);
    postoutput_div_para.add_object(test_jacobian);
    
    postoutput_div_para.add_object(test_inner_cell);
    
    postoutput_div_para.write();
    
    l1_divergence_error_para /= counter_interface_pts_para;

     l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
     std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
     std::cout<<bold<<yellow<<"The l1 error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
     std::cout<<"The l2 error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
     std::cout<<bold<<yellow<<"The linf error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
     
    std::cout<<bold<<yellow<<"The L1 error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << L1_divergence_error_para<<reset <<std::endl;
//    std::cout<<bold<<yellow<<"The linf error (ON INTEGRATION POINTS) of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para_bis<<reset <<std::endl;
    
}

template<typename Mesh, typename Curve ,  typename T  >
void
check_para_formulation_time( Mesh& msh_i, Curve& curve , size_t degree_curve,size_t degree_FEM, T radius,size_t time_step , size_t n_int)
{
    
    typedef typename Mesh::point_type point_type;
    T tot = degree_curve ; // 100
    T tot_error = 100 ;
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para.dat");
    auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para.dat");
//    auto jacobian_plot = std::make_shared< gnuplot_output_object<double> >("jacobian_para.dat");
    for(auto& cl : msh_i.cells)
    {
        
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
             
             
            auto integration_msh = cl.user_data.integration_msh ;
        
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                for(int i = 0; i <= tot ; i++)
                {
                     T pos = 0.0+i/tot ;
                     auto p = curve(pos , pts , degree_curve ) ;
                     interface_gamma.push_back( p ) ;
                     point<T,2> curv_var0 = point_type(p(0), p(1));
                     interface_gamma_plot->add_data(curv_var0,0.0);
                     auto k = curve.curvature(pos, pts , degree_curve) ;
                     curvature_plot->add_data(curv_var0, k );
                     curvature_gamma.push_back( k ) ;
                     tangent_gamma.push_back( curve.tangent(pos, pts , degree_curve) ) ;
                     normal_gamma.push_back( curve.normal(pos, pts , degree_curve) ) ;
                    
//                    auto j = curve.jacobian(pos , pts , degree_curve ) ;
//                    point<T,2> pj = point_type(j(0), j(1));
//                    jacobian_plot->add_data(pj, 0.0 );
                }
                
                 
            }
             
             
        }
            
            
    }

     
    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
    postoutput.write();
    goal_quantities_time_fast_para(msh_i , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    
    

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T L1_divergence_error_para = 0.  ;
    T linf_divergence_error_para = -10. ;
//    T linf_divergence_error_para_bis = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            
            auto integration_msh = cl.user_data.integration_msh ;
            auto degree_int = 2*degree_curve ;
            auto qps = edge_quadrature<T>(degree_int);
//            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
            
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                for(auto& qp:qps)
                {
                 
                    auto t = 0.5 * qp.first.x() + 0.5;
                    auto k_curve = std::abs( curve.curvature(t , pts , degree_curve ) + 1.0/radius);
                    T jacobian = curve.jacobian( t , pts , degree_curve ) ;
                    auto w = 0.5 * qp.second * jacobian ;
                    L1_divergence_error_para += k_curve*w ;
//                    linf_divergence_error_para_bis = std::max(linf_divergence_error_para_bis , k_curve ) ;
                }
                for(int i = 0; i < tot_error ; i++)
                {
                    T pos = 0.0+i/tot_error ;
                    T val0 = curve.curvature(pos, pts , degree_curve) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                    
            
                }
                        
                            
            }
            
    
         }



     }

    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k_curvature_para"+ std::to_string(time_step) + ".dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para"+ std::to_string(time_step) +".dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);
    
    std::string filename_jacobian = "jacobian_para"+ std::to_string(time_step) +".dat";
    std::string filename_jacobian_cl = "jacobian_para_cells"+ std::to_string(time_step) +".dat";
    auto test_jacobian = std::make_shared< gnuplot_output_object<double> >(filename_jacobian);
    auto test_jacobian_cl = std::make_shared< gnuplot_output_object<double> >(filename_jacobian_cl);
    
    
    std::string filename_curv_var_inner_cl = "inner_cell_limit_para"+ std::to_string(time_step) +".dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);
    
    
    
    T distance_pts_para = 0.0;
    bool first_cut_cell_found = FALSE ;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    tot = 10 ; //degree_curve -1 ; // 10 ;
    for(auto& cl : msh_i.cells)
    {

         if(cl.user_data.location == element_location::ON_INTERFACE)
         {
//            std::cout<<"cell = "<<offset(msh_i, cl);
            auto integration_msh = cl.user_data.integration_msh ;
            if(!first_cut_cell_found)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                }
                
                size_t pos_index_bis = 0;
                
                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                {
                    auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                    
//                    if( i_cell == 0)
//                        first_point = pts[0] ;
//                    if( i_cell == integration_msh.cells.size()-1)
//                        cell_end_point =  pts[1] ;
                  
                    for(int i = 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        
                        T val0 = curve.curvature(pos, pts , degree_curve) ;
//                        std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                        std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                        point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        
                        T pj = curve.jacobian(pos , pts , degree_curve ) ;
                        
                        if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0  )
                        {
                          
                            auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                            T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                            
                            test_inner_cell->add_data(curv_var, val0);
                            test_inner_cell->add_data(curv_var, valold);
                            if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                        }
                        
                        if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                            test_curv_var_para->add_data(curv_var, val0);
                            test_jacobian_cl->add_data(curv_var,pj );
//                            std::cout<<"interface cell bdry -> YES "<<std::endl;
                        }
                        
                        test_curvature_para->add_data(curv_var, val0);
                        test_jacobian->add_data(curv_var,pj );
                        T dist ;
                        if(pos == 1)
                            dist = 0.0;
                        else
                            dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                        
                        distance_pts_para += dist ;
                                    
                            
                    }
                                
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {

                   
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
//                        std::cout<<"cell = "<<offset(msh_i, cl);
//                        std::cout<<"first_point =  "<<first_point<<std::endl;
//                        std::cout<<"*cl.user_data.interface.begin() =  "<<*cl.user_data.interface.begin()<<std::endl;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                        auto integration_msh = cl.user_data.integration_msh ;
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                        }
                        
                        size_t pos_index_bis = 0;
                        
                        for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                        {
                            auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                           
//                            if( i_cell == integration_msh.cells.size()-1)
//                                cell_end_point =  pts[1] ;
                            
                            for(int i = 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature(pos, pts , degree_curve) ;
                                
                                T pj = curve.jacobian(pos , pts , degree_curve ) ;
                               
                                
//                                std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                                std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                                point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                
                                if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0 )
                                {
                                                                
                                    auto pts_old = points(integration_msh, integration_msh.cells[i_cell-1]);
                                    T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                                    test_inner_cell->add_data(curv_var, val0);
                                    test_inner_cell->add_data(curv_var, valold);
                                    if( pos_index_bis+1 < index_inner_cls.size() )
                                        pos_index_bis++;
                                }

                                
                                if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                                    test_curv_var_para->add_data(curv_var, val0);
                                    test_jacobian_cl->add_data(curv_var,pj );
//                                    std::cout<<"interface cell bdry -> YES "<<std::endl;
                                }
                                
                                test_curvature_para->add_data(curv_var, val0);
                                test_jacobian->add_data(curv_var,pj );
                                
                                T dist ;
                                if(pos == 1)
                                    dist = 0.0;
                                else
                                    dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                                
                                distance_pts_para += dist ;
                                            
                                    
                            }
                                        
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                    }
                    
                }
                
            }
            else
                break;
       
         }


    }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    
    postoutput_div_para.add_object(test_jacobian_cl);
    postoutput_div_para.add_object(test_jacobian);
    
    postoutput_div_para.add_object(test_inner_cell);
   
    postoutput_div_para.write();
    
    l1_divergence_error_para /= counter_interface_pts_para;

     l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
     std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
     std::cout<<bold<<yellow<<"The l1 error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
     std::cout<<"The l2 error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
     std::cout<<bold<<yellow<<"The linf error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
     
    std::cout<<bold<<yellow<<"The L1 error of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << L1_divergence_error_para<<reset <<std::endl;
//    std::cout<<bold<<yellow<<"The linf error (ON INTEGRATION POINTS) of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para_bis<<reset <<std::endl;
    
}


template<typename Mesh, typename Curve ,  typename T  >
void
check_para_formulation_n_der_cont( Mesh& msh_i, Curve& curve , size_t degree_curve,size_t degree_FEM, T radius , size_t n_int)
{
    
    typedef typename Mesh::point_type point_type;
    T tot = degree_curve ; // 100
    T tot_error = 100 ;
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para_cont.dat");
    auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para_der_cont.dat");
     
    for(auto& cl : msh_i.cells)
    {
        
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
             
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
        
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(int i = 0; i <= tot ; i++)
                {
                     T pos = 0.0+i/tot ;
                     auto p = curve(pos , pts , degree_curve ) ;
                     interface_gamma.push_back( p ) ;
                     point<T,2> curv_var0 = point_type(p(0), p(1));
                     interface_gamma_plot->add_data(curv_var0,0.0);
                    
                     auto k = curve.curvature_der_cont( pos, global_cl_i ) ;
                     curvature_plot->add_data(curv_var0, k );
                     curvature_gamma.push_back( k ) ;
                     tangent_gamma.push_back( curve.tangent_cont(pos, global_cl_i) ) ;
                     normal_gamma.push_back( curve.normal_cont(pos, global_cl_i) ) ;
                }
                
                 
            }
             
             
        }
            
            
    }

     
    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
    postoutput.write();
    goal_quantities_time_fast_para_cont(msh_i , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    
    

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T L1_divergence_error_para = 0.  ;
    T linf_divergence_error_para = -10. ;
//    T linf_divergence_error_para_bis = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            auto degree_int = 2*degree_curve ;
            auto qps = edge_quadrature<T>(degree_int);
//            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
            
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(auto& qp:qps)
                {
                 
                    auto t = 0.5 * qp.first.x() + 0.5;
                    auto k_curve = std::abs( curve.curvature_der_cont(t , global_cl_i ) + 1.0/radius);
                    T jacobian = curve.jacobian_cont( t , global_cl_i ) ;
                    auto w = 0.5 * qp.second * jacobian ;
                    L1_divergence_error_para += k_curve*w ;
//                    linf_divergence_error_para_bis = std::max(linf_divergence_error_para_bis , k_curve ) ;
                }
                for(int i = 0; i < tot_error ; i++)
                {
                    T pos = 0.0+i/tot_error ;
                    T val0 = curve.curvature_der_cont(pos, global_cl_i) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                    
            
                }
                        
                            
            }
            
    
         }



     }

    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k0_curvature_para_der_cont.dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para_der_cont.dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);
    
   std::string filename_curv_var_inner_cl = "inner_cell_limit_para_der_cont.dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);

    
    T distance_pts_para = 0.0;
    bool first_cut_cell_found = FALSE ;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    tot =  10 ; //degree_curve - 1 ; // 10
    std::cout<<"Plotting "<<tot<<" points for each integration mesh T_j."<<std::endl;
    for(auto& cl : msh_i.cells)
    {

         if(cl.user_data.location == element_location::ON_INTERFACE)
         {
//            std::cout<<"cell = "<<offset(msh_i, cl);
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            if(!first_cut_cell_found)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                }
                
                size_t pos_index_bis = 0;
                
                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                {
                    size_t global_cl_i = global_cells_i[i_cell] ;
//                    std::cout<<"i_cell = "<<i_cell<<" , global global_cl_i = "<<global_cl_i<<std::endl;
                    auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                    
//                    if( i_cell == 0)
//                        first_point = pts[0] ;
//                    if( i_cell == integration_msh.cells.size()-1)
//                        cell_end_point =  pts[1] ;
                  
                    for(int i = 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        
                        T val0 = curve.curvature_der_cont(pos, global_cl_i) ;
//                        std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                        std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                        point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0  )
                        {
                          
                            auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                            T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                            
                            test_inner_cell->add_data(curv_var, val0);
                            test_inner_cell->add_data(curv_var, valold);
                            if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                        }

                        
                        if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                            test_curv_var_para->add_data(curv_var, val0);
//                            std::cout<<"interface cell bdry -> YES "<<std::endl;
                        }
                        
                        test_curvature_para->add_data(curv_var, val0);
                        T dist ;
                        if(pos == 1)
                            dist = 0.0;
                        else
                            dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                        
                        distance_pts_para += dist ;
                                    
                            
                    }
                                
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {

                   
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
//                        std::cout<<"cell = "<<offset(msh_i, cl);
//                        std::cout<<"first_point =  "<<first_point<<std::endl;
//                        std::cout<<"*cl.user_data.interface.begin() =  "<<*cl.user_data.interface.begin()<<std::endl;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                        auto integration_msh = cl.user_data.integration_msh ;
                        auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                        }
                        size_t pos_index_bis = 0;
                        
                        for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                        {
                            auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                            size_t global_cl_i = global_cells_i[i_cell] ;

                                                   
                            
                            
                            for(int i = 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature_der_cont(pos, global_cl_i ) ;
//                                std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                                std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                                point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                                    test_curv_var_para->add_data(curv_var, val0);
//                                    std::cout<<"interface cell bdry -> YES "<<std::endl;
                                }
                                
                                if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0 )
                                {
                                  
                                    auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                                    T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                                    
                                    test_inner_cell->add_data(curv_var, val0);
                                    test_inner_cell->add_data(curv_var, valold);
                                    if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                                }
                                
                                test_curvature_para->add_data(curv_var, val0);

                                
                                T dist ;
                                if(pos == 1)
                                    dist = 0.0;
                                else
                                    dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                                
                                distance_pts_para += dist ;
                                            
                                    
                            }
                                        
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                    }
                    
                }
                
            }
            else
                break;
       
         }


     }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    postoutput_div_para.add_object(test_inner_cell);
    
     postoutput_div_para.write();
    
     l1_divergence_error_para /= counter_interface_pts_para;

     l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
     std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
     std::cout<<bold<<yellow<<"The l1 error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
     std::cout<<"The l2 error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
     std::cout<<bold<<yellow<<"The linf error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
     
    std::cout<<bold<<yellow<<"The L1 error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << L1_divergence_error_para<<reset <<std::endl;
//    std::cout<<bold<<yellow<<"The linf error (ON INTEGRATION POINTS) of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para_bis<<reset <<std::endl;
    
}


template<typename Mesh, typename Curve ,  typename T  >
void
check_para_formulation_n_der_cont_time( Mesh& msh_i, Curve& curve , size_t degree_curve,size_t degree_FEM, T radius , size_t time_step ,size_t n_int )
{
    
    typedef typename Mesh::point_type point_type;
    T tot = degree_curve ; // 100
    T tot_error = 100 ;
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para_der_cont.dat");
    auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para_der_cont.dat");
     
    for(auto& cl : msh_i.cells)
    {
        
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
             
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
        
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(int i = 0; i <= tot ; i++)
                {
                     T pos = 0.0+i/tot ;
                     auto p = curve(pos , pts , degree_curve ) ;
                     interface_gamma.push_back( p ) ;
                     point<T,2> curv_var0 = point_type(p(0), p(1));
                     interface_gamma_plot->add_data(curv_var0,0.0);
                    
                     auto k = curve.curvature_der_cont( pos, global_cl_i ) ;
                     curvature_plot->add_data(curv_var0, k );
                     curvature_gamma.push_back( k ) ;
                     tangent_gamma.push_back( curve.tangent_cont(pos, global_cl_i) ) ;
                     normal_gamma.push_back( curve.normal_cont(pos, global_cl_i) ) ;
                }
                
                 
            }
             
             
        }
            
            
    }

     
    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
    postoutput.write();
    goal_quantities_time_fast_para_cont(msh_i , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    
    

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T L1_divergence_error_para = 0.  ;
    T linf_divergence_error_para = -10. ;
//    T linf_divergence_error_para_bis = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            auto degree_int = 2*degree_curve ;
            auto qps = edge_quadrature<T>(degree_int);
//            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
            
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(auto& qp:qps)
                {
                 
                    auto t = 0.5 * qp.first.x() + 0.5;
                    auto k_curve = std::abs( curve.curvature_der_cont(t , global_cl_i ) + 1.0/radius);
                    T jacobian = curve.jacobian_cont( t , global_cl_i ) ;
                    auto w = 0.5 * qp.second * jacobian ;
                    L1_divergence_error_para += k_curve*w ;
//                    linf_divergence_error_para_bis = std::max(linf_divergence_error_para_bis , k_curve ) ;
                }
                for(int i = 0; i < tot_error ; i++)
                {
                    T pos = 0.0+i/tot_error ;
                    T val0 = curve.curvature_der_cont(pos, global_cl_i) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                    
            
                }
                        
                            
            }
            
    
         }



     }

    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k0_curvature_para_der_cont"+ std::to_string(time_step) +".dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para_der_cont"+ std::to_string(time_step) +".dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);
    
   std::string filename_curv_var_inner_cl = "inner_cell_limit_para_der_cont"+ std::to_string(time_step) +".dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);

    
    T distance_pts_para = 0.0;
    bool first_cut_cell_found = FALSE ;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    tot =  10 ; //degree_curve - 1 ; // 10
    std::cout<<"Plotting "<<tot<<" points for each integration mesh T_j."<<std::endl;
    for(auto& cl : msh_i.cells)
    {

         if(cl.user_data.location == element_location::ON_INTERFACE)
         {
//            std::cout<<"cell = "<<offset(msh_i, cl);
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            if(!first_cut_cell_found)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                }
                
                size_t pos_index_bis = 0;
                
                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                {
                    size_t global_cl_i = global_cells_i[i_cell] ;
//                    std::cout<<"i_cell = "<<i_cell<<" , global global_cl_i = "<<global_cl_i<<std::endl;
                    auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                    
//                    if( i_cell == 0)
//                        first_point = pts[0] ;
//                    if( i_cell == integration_msh.cells.size()-1)
//                        cell_end_point =  pts[1] ;
                  
                    for(int i = 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        
                        T val0 = curve.curvature_der_cont(pos, global_cl_i) ;
//                        std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                        std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                        point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0  )
                        {
                          
                            auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                            T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                            
                            test_inner_cell->add_data(curv_var, val0);
                            test_inner_cell->add_data(curv_var, valold);
                            if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                        }

                        
                        if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                            test_curv_var_para->add_data(curv_var, val0);
//                            std::cout<<"interface cell bdry -> YES "<<std::endl;
                        }
                        
                        test_curvature_para->add_data(curv_var, val0);
                        T dist ;
                        if(pos == 1)
                            dist = 0.0;
                        else
                            dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                        
                        distance_pts_para += dist ;
                                    
                            
                    }
                                
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {

                   
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
//                        std::cout<<"cell = "<<offset(msh_i, cl);
//                        std::cout<<"first_point =  "<<first_point<<std::endl;
//                        std::cout<<"*cl.user_data.interface.begin() =  "<<*cl.user_data.interface.begin()<<std::endl;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                        auto integration_msh = cl.user_data.integration_msh ;
                        auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                        }
                        size_t pos_index_bis = 0;
                        
                        for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                        {
                            auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                            size_t global_cl_i = global_cells_i[i_cell] ;

                            
                            for(int i = 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature_der_cont(pos, global_cl_i ) ;
//                                std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                                std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                                point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                                    test_curv_var_para->add_data(curv_var, val0);
//                                    std::cout<<"interface cell bdry -> YES "<<std::endl;
                                }
                                
                                if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0 )
                                {
                                  
                                    auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                                    T valold = curve.curvature(1.0, pts_old , degree_curve) ;
                                    
                                    test_inner_cell->add_data(curv_var, val0);
                                    test_inner_cell->add_data(curv_var, valold);
                                    if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                                }
                                
                                test_curvature_para->add_data(curv_var, val0);

                                
                                T dist ;
                                if(pos == 1)
                                    dist = 0.0;
                                else
                                    dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                                
                                distance_pts_para += dist ;
                                            
                                    
                            }
                                        
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                    }
                    
                }
                
            }
            else
                break;
       
         }


     }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    postoutput_div_para.add_object(test_inner_cell);
    
     postoutput_div_para.write();
    
     l1_divergence_error_para /= counter_interface_pts_para;

     l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
     std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
     std::cout<<bold<<yellow<<"The l1 error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
     std::cout<<"The l2 error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
     std::cout<<bold<<yellow<<"The linf error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
     
    std::cout<<bold<<yellow<<"The L1 error of the NORMAL DER-CONT CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << L1_divergence_error_para<<reset <<std::endl;
//    std::cout<<bold<<yellow<<"The linf error (ON INTEGRATION POINTS) of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para_bis<<reset <<std::endl;
    
}


template<typename Mesh, typename Curve ,  typename T  >
void
check_para_formulation_n_cont( Mesh& msh_i, Curve& curve , size_t degree_curve,size_t degree_FEM, T radius , size_t n_int)
{
    
    typedef typename Mesh::point_type point_type;
    T tot = degree_curve ; // 100
    T tot_error = 100 ;
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para_cont.dat");
//     auto interface_gamma_plot_new = std::make_shared< gnuplot_output_object<double> >("curve_interface_para_cont_NEW.dat");
    auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para_cont.dat");
    
     
    for(auto& cl : msh_i.cells)
    {
        
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
             
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
        
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(int i = 0; i <= tot ; i++)
                {
                     T pos = 0.0+i/tot ;
                     auto p = curve(pos , pts , degree_curve ) ;
                     interface_gamma.push_back( p ) ;
                     point<T,2> curv_var0 = point_type(p(0), p(1));
                     interface_gamma_plot->add_data(curv_var0,0.0);
                    
//                    auto pnew = curve(pos , global_cl_i ) ;
//                    point<T,2> curv_var0_new = point_type(pnew(0), pnew(1));
//                    interface_gamma_plot_new->add_data(curv_var0_new,0.0);
//                    std::cout<<"Difference para curve: p="<<p<<" , p_new="<<pnew<<" ->diff = "<<pnew - p<<std::endl;
                     auto k = curve.curvature_cont( pos, global_cl_i ) ;
                     curvature_plot->add_data(curv_var0, k );
                     curvature_gamma.push_back( k ) ;
                     tangent_gamma.push_back( curve.tangent_cont(pos, global_cl_i) ) ;
                     normal_gamma.push_back( curve.normal_cont(pos, global_cl_i) ) ;
                }
                
                 
            }
             
             
        }
            
            
    }

     
    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
//    postoutput.add_object(interface_gamma_plot_new);
    
    postoutput.write();
    goal_quantities_time_fast_para_cont(msh_i , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    
    

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T L1_divergence_error_para = 0.  ;
    T linf_divergence_error_para = -10. ;
//    T linf_divergence_error_para_bis = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            auto degree_int = 2*degree_curve ;
            auto qps = edge_quadrature<T>(degree_int);
//            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
            
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(auto& qp:qps)
                {
                 
                    auto t = 0.5 * qp.first.x() + 0.5;
                    auto k_curve = std::abs( curve.curvature_cont(t , global_cl_i ) + 1.0/radius);
                    T jacobian = curve.jacobian_cont( t , global_cl_i ) ;
                    auto w = 0.5 * qp.second * jacobian ;
                    L1_divergence_error_para += k_curve*w ;
//                    linf_divergence_error_para_bis = std::max(linf_divergence_error_para_bis , k_curve ) ;
                }
                for(int i = 0; i < tot_error ; i++)
                {
                    T pos = 0.0+i/tot_error ;
                    T val0 = curve.curvature_cont(pos, global_cl_i) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                    
            
                }
                        
                            
            }
            
    
         }



     }

    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k0_curvature_para_cont.dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para_cont.dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);
    
    auto test_jacobian = std::make_shared< gnuplot_output_object<double> >("jacobian_para_cont.dat");
    auto test_jacobian_cl = std::make_shared< gnuplot_output_object<double> >("jacobian_para_cont_cells.dat");
    
    std::string filename_curv_var_inner_cl = "inner_cell_limit_para_cont.dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);

    
    T distance_pts_para = 0.0;
    bool first_cut_cell_found = FALSE ;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    tot = 10 ; // degree_curve - 1 ; //degree_curve - 2 ; // 10
    for(auto& cl : msh_i.cells)
    {

         if(cl.user_data.location == element_location::ON_INTERFACE)
         {
//            std::cout<<"cell = "<<offset(msh_i, cl);
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            if(!first_cut_cell_found)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                }
                
                size_t pos_index_bis = 0;
                
                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                {
                    size_t global_cl_i = global_cells_i[i_cell] ;
//                    std::cout<<"i_cell = "<<i_cell<<" , global global_cl_i = "<<global_cl_i<<std::endl;
                    auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                    
//                    if( i_cell == 0)
//                        first_point = pts[0] ;
//                    if( i_cell == integration_msh.cells.size()-1)
//                        cell_end_point =  pts[1] ;
                  
                    for(int i = 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        
                        T val0 = curve.curvature_cont(pos, global_cl_i) ;
//                        std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
                        T pj = curve.jacobian_cont(pos , global_cl_i ) ;
                        
//                        std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                        point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        
                        if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0  )
                        {
                          
                            auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                            T valold = curve.curvature_cont(1.0, global_cl_i-1) ;
                            
                            test_inner_cell->add_data(curv_var, val0);
                            test_inner_cell->add_data(curv_var, valold);
                            if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                        }

                        
                        if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                            test_curv_var_para->add_data(curv_var, val0);
                            test_jacobian_cl->add_data(curv_var,pj );
//                            std::cout<<"interface cell bdry -> YES "<<std::endl;
                        }
                        
                        test_curvature_para->add_data(curv_var, val0);
                        test_jacobian->add_data(curv_var,pj );
                        T dist ;
                        if(pos == 1)
                            dist = 0.0;
                        else
                            dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                        
                        distance_pts_para += dist ;
                                    
                            
                    }
                                
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {

                   
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
//                        std::cout<<"cell = "<<offset(msh_i, cl);
//                        std::cout<<"first_point =  "<<first_point<<std::endl;
//                        std::cout<<"*cl.user_data.interface.begin() =  "<<*cl.user_data.interface.begin()<<std::endl;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                        auto integration_msh = cl.user_data.integration_msh ;
                        auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                        }
                        
                        size_t pos_index_bis = 0;

                        
                        for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                        {
                            auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                            size_t global_cl_i = global_cells_i[i_cell] ;
//                            std::cout<<"i_cell = "<<i_cell<<" , global global_cl_i = "<<global_cl_i<<std::endl;
//                            if( i_cell == integration_msh.cells.size()-1)
//                                cell_end_point =  pts[1] ;
                            
                            for(int i = 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature_cont(pos, global_cl_i ) ;
                                T pj = curve.jacobian_cont(pos , global_cl_i ) ;
                                
//                                std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                                std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                                point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0 )
                                {
                                                                 
//                                    auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                                    T valold = curve.curvature_cont(1.0, global_cl_i-1) ;
                                                                   
                                    test_inner_cell->add_data(curv_var, val0);
                                    test_inner_cell->add_data(curv_var, valold);
                                    if( pos_index_bis+1 < index_inner_cls.size() )
                                        pos_index_bis++;
                                }

                                
                                if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                                    test_curv_var_para->add_data(curv_var, val0);
                                    test_jacobian_cl->add_data(curv_var,pj );
//                                    std::cout<<"interface cell bdry -> YES "<<std::endl;
                                }
                                
                                test_curvature_para->add_data(curv_var, val0);
                                test_jacobian->add_data(curv_var,pj );
                                
                                T dist ;
                                if(pos == 1)
                                    dist = 0.0;
                                else
                                    dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                                
                                distance_pts_para += dist ;
                                            
                                    
                            }
                                        
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                    }
                    
                }
                
            }
            else
                break;
       
         }


     }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    
    postoutput_div_para.add_object(test_jacobian);
    postoutput_div_para.add_object(test_jacobian_cl);
    postoutput_div_para.add_object(test_inner_cell);
     
    postoutput_div_para.write();
    
     l1_divergence_error_para /= counter_interface_pts_para;

     l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
     std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
     std::cout<<bold<<yellow<<"The l1 error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
     std::cout<<"The l2 error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
     std::cout<<bold<<yellow<<"The linf error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
     
    std::cout<<bold<<yellow<<"The L1 error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << L1_divergence_error_para<<reset <<std::endl;
//    std::cout<<bold<<yellow<<"The linf error (ON INTEGRATION POINTS) of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para_bis<<reset <<std::endl;
    
}


template<typename Mesh, typename Curve ,  typename T  >
void
check_para_formulation_n_cont_time( Mesh& msh_i, Curve& curve , size_t degree_curve,size_t degree_FEM, T radius, size_t time_step , size_t n_int )
{
    
    typedef typename Mesh::point_type point_type;
    T tot = degree_curve ; // 100
    T tot_error = 100 ;
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para_cont.dat");
//     auto interface_gamma_plot_new = std::make_shared< gnuplot_output_object<double> >("curve_interface_para_cont_NEW.dat");
    auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para_cont.dat");
    
     
    for(auto& cl : msh_i.cells)
    {
        
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
             
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
        
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(int i = 0; i <= tot ; i++)
                {
                     T pos = 0.0+i/tot ;
                     auto p = curve(pos , pts , degree_curve ) ;
                     interface_gamma.push_back( p ) ;
                     point<T,2> curv_var0 = point_type(p(0), p(1));
                     interface_gamma_plot->add_data(curv_var0,0.0);
                    
//                    auto pnew = curve(pos , global_cl_i ) ;
//                    point<T,2> curv_var0_new = point_type(pnew(0), pnew(1));
//                    interface_gamma_plot_new->add_data(curv_var0_new,0.0);
//                    std::cout<<"Difference para curve: p="<<p<<" , p_new="<<pnew<<" ->diff = "<<pnew - p<<std::endl;
                     auto k = curve.curvature_cont( pos, global_cl_i ) ;
                     curvature_plot->add_data(curv_var0, k );
                     curvature_gamma.push_back( k ) ;
                     tangent_gamma.push_back( curve.tangent_cont(pos, global_cl_i) ) ;
                     normal_gamma.push_back( curve.normal_cont(pos, global_cl_i) ) ;
                }
                
                 
            }
             
             
        }
            
            
    }

     
    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
//    postoutput.add_object(interface_gamma_plot_new);
    
    postoutput.write();
    goal_quantities_time_fast_para_cont(msh_i , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    
    

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T L1_divergence_error_para = 0.  ;
    T linf_divergence_error_para = -10. ;
//    T linf_divergence_error_para_bis = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            auto degree_int = 2*degree_curve ;
            auto qps = edge_quadrature<T>(degree_int);
//            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
            
            for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
            {
                auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                size_t global_cl_i = global_cells_i[i_cell] ;
                
                for(auto& qp:qps)
                {
                 
                    auto t = 0.5 * qp.first.x() + 0.5;
                    auto k_curve = std::abs( curve.curvature_cont(t , global_cl_i ) + 1.0/radius);
                    T jacobian = curve.jacobian_cont( t , global_cl_i ) ;
                    auto w = 0.5 * qp.second * jacobian ;
                    L1_divergence_error_para += k_curve*w ;
//                    linf_divergence_error_para_bis = std::max(linf_divergence_error_para_bis , k_curve ) ;
                }
                for(int i = 0; i < tot_error ; i++)
                {
                    T pos = 0.0+i/tot_error ;
                    T val0 = curve.curvature_cont(pos, global_cl_i) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                    
            
                }
                        
                            
            }
            
    
         }



     }

    postprocess_output<double> postoutput_div_para;
    
    std::string filename_curvature_para = "k_curvature_para_cont"+ std::to_string(time_step) + ".dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para_cont"+ std::to_string(time_step) +".dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);
    
    std::string filename_jacobian = "jacobian_para_cont"+ std::to_string(time_step) +".dat";
    std::string filename_jacobian_cl = "jacobian_para_cont_cells"+ std::to_string(time_step) +".dat";
    auto test_jacobian = std::make_shared< gnuplot_output_object<double> >(filename_jacobian);
    auto test_jacobian_cl = std::make_shared< gnuplot_output_object<double> >(filename_jacobian_cl);
    
    std::string filename_curv_var_inner_cl = "inner_cell_limit_para_cont"+ std::to_string(time_step) +".dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);

    
    T distance_pts_para = 0.0;
    bool first_cut_cell_found = FALSE ;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    tot = 10 ; // degree_curve - 1 ; //degree_curve - 2 ; // 10
    for(auto& cl : msh_i.cells)
    {

         if(cl.user_data.location == element_location::ON_INTERFACE)
         {
//            std::cout<<"cell = "<<offset(msh_i, cl);
            auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
            auto integration_msh = cl.user_data.integration_msh ;
            if(!first_cut_cell_found)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                }
                               
                size_t pos_index_bis = 0;
                
                for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                {
                    size_t global_cl_i = global_cells_i[i_cell] ;
//                    std::cout<<"i_cell = "<<i_cell<<" , global global_cl_i = "<<global_cl_i<<std::endl;
                    auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                    
//                    if( i_cell == 0)
//                        first_point = pts[0] ;
//                    if( i_cell == integration_msh.cells.size()-1)
//                        cell_end_point =  pts[1] ;
                  
                    for(int i = 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        
                        T val0 = curve.curvature_cont(pos, global_cl_i) ;
//                        std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
                        T pj = curve.jacobian_cont(pos , global_cl_i ) ;

//                        std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                        point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        
                        if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0  )
                        {
                          
//                            auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                            T valold = curve.curvature_cont(1.0, global_cl_i-1) ;
                            
                            test_inner_cell->add_data(curv_var, val0);
                            test_inner_cell->add_data(curv_var, valold);
                            if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                        }

                        if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                            test_curv_var_para->add_data(curv_var, val0);
                            test_jacobian_cl->add_data(curv_var,pj );
//                            std::cout<<"interface cell bdry -> YES "<<std::endl;
                        }
                        
                        test_curvature_para->add_data(curv_var, val0);
                        test_jacobian->add_data(curv_var,pj );
                        T dist ;
                        if(pos == 1)
                            dist = 0.0;
                        else
                            dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                        
                        distance_pts_para += dist ;
                                    
                            
                    }
                                
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {

                   
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
//                        std::cout<<"cell = "<<offset(msh_i, cl);
//                        std::cout<<"first_point =  "<<first_point<<std::endl;
//                        std::cout<<"*cl.user_data.interface.begin() =  "<<*cl.user_data.interface.begin()<<std::endl;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                        auto integration_msh = cl.user_data.integration_msh ;
                        auto global_cells_i = curve.get_global_cells_interface(msh_i , cl);
                        
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(integration_msh.cells.size() ) / amount_sub_cls );
                        }
                                               
                        size_t pos_index_bis = 0;
                        
                        for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                        {
                            auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                            size_t global_cl_i = global_cells_i[i_cell] ;
//                            std::cout<<"i_cell = "<<i_cell<<" , global global_cl_i = "<<global_cl_i<<std::endl;
//                            if( i_cell == integration_msh.cells.size()-1)
//                                cell_end_point =  pts[1] ;
                            
                            for(int i = 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature_cont(pos, global_cl_i ) ;
                                T pj = curve.jacobian_cont(pos , global_cl_i ) ;
                                
//                                std::cout<<"pos = "<<pos<<" , pt = "<<curve(pos, pts , degree_curve)<<" , k = "<<val0<<std::endl;
//                                std::cout<<"distance_pts_para = "<<distance_pts_para<<std::endl;
                                point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                
                                if( agglo_cl && i_cell == index_inner_cls[pos_index_bis] && i == 0 )
                                {
                                                                 
//                                    auto pts_old = points(integration_msh,integration_msh.cells[i_cell-1]);
                                    T valold = curve.curvature_cont(1.0, global_cl_i-1) ;
                                                                   
                                    test_inner_cell->add_data(curv_var, val0);
                                    test_inner_cell->add_data(curv_var, valold);
                                    if( pos_index_bis+1 < index_inner_cls.size() )
                                        pos_index_bis++;
                                }
                                
                                if( (i_cell==0 && pos == 0.0) || ( i_cell==integration_msh.cells.size()-1 && pos == 1.0 ) ){
                                    test_curv_var_para->add_data(curv_var, val0);
                                    test_jacobian_cl->add_data(curv_var,pj );
//                                    std::cout<<"interface cell bdry -> YES "<<std::endl;
                                }
                                
                                test_curvature_para->add_data(curv_var, val0);
                                test_jacobian->add_data(curv_var,pj );
                                
                                T dist ;
                                if(pos == 1)
                                    dist = 0.0;
                                else
                                    dist = (curve(pos +1.0/tot, pts , degree_curve) - curve(pos, pts , degree_curve)).norm() ;
                                
                                distance_pts_para += dist ;
                                            
                                    
                            }
                                        
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
//                        std::cout<<"cell_end_point =  "<<cell_end_point<<std::endl;
                    }
                    
                }
                
            }
            else
                break;
       
         }


     }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    
//    postoutput_div_para.add_object(test_jacobian);
//    postoutput_div_para.add_object(test_jacobian_cl);
    postoutput_div_para.add_object(test_inner_cell);
    
    postoutput_div_para.write();
    
     l1_divergence_error_para /= counter_interface_pts_para;

     l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
     std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
     std::cout<<bold<<yellow<<"The l1 error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
     std::cout<<"The l2 error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
     std::cout<<bold<<yellow<<"The linf error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
     
    std::cout<<bold<<yellow<<"The L1 error of the CONTINUOUS CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << L1_divergence_error_para<<reset <<std::endl;
//    std::cout<<bold<<yellow<<"The linf error (ON INTEGRATION POINTS) of the CURVATURE (PARAMETRIC) at the INTERFACE, at INITIAL time is " << linf_divergence_error_para_bis<<reset <<std::endl;
    
}


template<typename Mesh,typename Level_Set,typename T >
void
check_goal_quantities( Mesh& msh_i , Level_Set& ls_cell , T& perimeter_initial, T& d_a, T& initial_area, T& centre_mass_x_inital , T&  centre_mass_y_inital , size_t degree_FEM , T& initial_mass , bool flower , T& l1_divergence_error , T& l2_divergence_error , T& linf_divergence_error , T& radius , T& L1_divergence_error , bool ellipse , size_t degree_curve , size_t n_int )
{
    
    
    typedef typename Mesh::point_type point_type;
   
    

    //postprocess_output<double> postoutput_vec;
    //auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);
    
    std::string filename_curv_var_inner_cl = "inner_cell_limit_curv_var_initial.dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    size_t counter_interface_pts = 0;

    // CHECKING OF AREA, MASS, CENTRE OF MASS, PERIMETER, CURVATURE ERRORS
    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            perimeter_initial += measure_interface(msh_i,cl,element_location::ON_INTERFACE);
            
            auto qps = integrate_interface(msh_i, cl, degree_FEM, element_location::ON_INTERFACE);
            for(auto& qp:qps){
                T val = std::abs( ls_cell.divergence(qp.first) + 1.0/radius );
                L1_divergence_error += qp.second * val ;
                linf_divergence_error = std::max(linf_divergence_error , val ) ;
                l1_divergence_error += val;
                counter_interface_pts++;
            }
            
                
            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
            {


//                T val0 = ls_cell.divergence( *interface_point );
//                T error_curvature = std::abs( val0 + 1.0/radius) ;
//                l1_divergence_error += error_curvature;
//                l2_divergence_error += pow(error_curvature,2) ;
//                linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                interface_points_plot.push_back(*(interface_point)) ;

//                counter_interface_pts++;

            }

            

        }
    }

    
    // PLOTTING OF THE CURVATURE IN A 2d FRAME
    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    
    // --------- CHECKING CURVATURE DISC GRAD CONT ----------
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                }
//                if( agglo_cl && amount_sub_cls == 2 )
//                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//                if( agglo_cl && amount_sub_cls == 3 ){
//                    index_inner_cls.push_back( (cl.user_data.interface.size() - 1)/amount_sub_cls );
//                    index_inner_cls.push_back( 2.0*(cl.user_data.interface.size() - 1)/amount_sub_cls );
//                }
                size_t pos_index = 0;
                size_t pos_index_bis = 0;
               
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                        test_curv_var_cell->add_data(curv_var, val0);
                    
                    
                     if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                     {
                         auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                         assert(offset_cells.size() == 2);
                         auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                         auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                         T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
                         T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
                         
                         test_inner_cell->add_data(curv_var, val_skeleton0);
                         test_inner_cell->add_data(curv_var, val_skeleton1);
                         if( pos_index_bis+1 < index_inner_cls.size() )
                             pos_index_bis++;
                     }

                    test_curv_var_divergence0->add_data(curv_var, val0);
                    if(*interface_point == *(cl.user_data.interface.end() -1))
                        distance_pts +=  0.0 ;
                    else
                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
                    pos_index++;
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
                        ls_cell.cell_assignment(cl);
                        
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                        }
                        size_t pos_index = 0;
                        size_t pos_index_bis = 0;
                        
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);
                            
                            if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                            {
                                auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                                assert(offset_cells.size() == 2);
                                auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                                auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                                T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
                                T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
                                
                                test_inner_cell->add_data(curv_var, val_skeleton0);
                                test_inner_cell->add_data(curv_var, val_skeleton1);
                                if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                            }
                            
                            
                            if(*interface_point == *(cl.user_data.interface.end() -1))
                                distance_pts += 0.0 ;
                            else
                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                             pos_index++;
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.add_object(test_inner_cell);
    
    postoutput_div2.write();

    
    
    // --------- CHECKING CURVATURE DISC ----------
    postprocess_output<T> postoutput_div_bis;
    std::string filename_curvature_k2 = "k0_curvature_disc_initial.dat";
    auto test_curv_var_divergence2 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k2);

    std::string filename_curv_var2 = "cell_limit_disc_initial.dat";
    auto test_curv_var_cell2 = std::make_shared< gnuplot_output_object<double> >(filename_curv_var2);
    
    std::string filename_curv_var_inner_cl2 = "inner_cell_limit_disc_initial.dat";
    auto test_inner_cell2 = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl2);

    
          
    bool first_cut_cell_found2 = FALSE ;
    T distance_pts2 = 0.0;
    point<T,2> first_point2 ;
    point<T,2> cell_end_point2;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found2)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                }
    
    
                size_t pos_index = 0;
                size_t pos_index_bis = 0;
                   
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T val0 = ls_cell.divergence_disc( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts2 , 0.0);
                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                        test_curv_var_cell2->add_data(curv_var, val0);
                        
                        
                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                    {
                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                        assert(offset_cells.size() == 2);
                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                        T val_skeleton0 = ls_cell.divergence_disc( *interface_point , subcl0 );
                        T val_skeleton1 = ls_cell.divergence_disc( *interface_point , subcl1 );
                             
                        test_inner_cell2->add_data(curv_var, val_skeleton0);
                        test_inner_cell2->add_data(curv_var, val_skeleton1);
                        if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                    }

                    
                    test_curv_var_divergence2->add_data(curv_var, val0);
                    if(*interface_point == *(cl.user_data.interface.end() -1))
                        distance_pts2 +=  0.0 ;
                    else
                        distance_pts2 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
                    pos_index++;
                }
                first_cut_cell_found2 = TRUE;
                first_point2 = *cl.user_data.interface.begin() ;
                cell_end_point2 = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found2 && !( first_point2 == cell_end_point2  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point2 == *cl.user_data.interface.begin() ) && !( first_point2 == cell_end_point2)  )
                    {
                        ls_cell.cell_assignment(cl);
                        
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                        }
                        size_t pos_index = 0;
                        size_t pos_index_bis = 0;
                            
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence_disc( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts2 , 0.0);
                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                                test_curv_var_cell2->add_data(curv_var, val0);

                            test_curv_var_divergence2->add_data(curv_var, val0);
                                
                            if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                            {
                                auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh, *interface_point,cl);
                                assert(offset_cells.size() == 2);
                                auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                                auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                                T val_skeleton0 = ls_cell.divergence_disc( *interface_point , subcl0 );
                                T val_skeleton1 = ls_cell.divergence_disc( *interface_point , subcl1 );
                                    
                                test_inner_cell2->add_data(curv_var, val_skeleton0);
                                test_inner_cell2->add_data(curv_var, val_skeleton1);
                                if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                            }
                                
                                
                            if(*interface_point == *(cl.user_data.interface.end() -1))
                                distance_pts2 += 0.0 ;
                            else
                                distance_pts2 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            pos_index++;
                        }
                        cell_end_point2 = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    


    postoutput_div_bis.add_object(test_curv_var_divergence2);
    postoutput_div_bis.add_object(test_curv_var_cell2);
    postoutput_div_bis.add_object(test_inner_cell2);
    
    postoutput_div_bis.write();
    
    
    

    
    if( !flower)  // Circular case (to calcualte the Curvature error I use the analytic radius)
    {
        l1_divergence_error /= counter_interface_pts;

//        l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
//        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;
        
        std::cout<<bold<<yellow<<"The L1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << L1_divergence_error<<reset <<std::endl;

    }

    std::cout <<bold<<yellow << '\n' << "Initial time, AREA  = "<< initial_area << reset << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    
    T perimeter_anal = 2.0*M_PI*radius ;
    std::cout<<"Error( perimetre NEW - perimeter_anal ) = " << perimeter_initial - perimeter_anal <<std::endl;
     
    
    


    if(flower || ellipse) // FLOWER O ELLIPSE CASE: the radius is calculated by the area conservation
    {
        std::cout<<"OLD radius = " << radius <<std::endl;
        l1_divergence_error = 0. , l2_divergence_error = 0. ;
        L1_divergence_error = 0. ;
        T linf_divergence_error = -10. ;
        radius = sqrt( initial_area/M_PI ) ;
        std::cout<<"FROM CONSERVATION OF AREA -> radius = " << radius <<std::endl;
        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl) ;

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                auto qps = integrate_interface(msh_i, cl, degree_FEM, element_location::ON_INTERFACE);
                for(auto& qp:qps){
                    T val = std::abs( std::abs(ls_cell.divergence(qp.first)) - 1.0/radius );
                    L1_divergence_error += qp.second * val ;
                    linf_divergence_error = std::max(linf_divergence_error , val ) ;
                    l1_divergence_error += val;
                   
                
                }

//                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                {
//
//
//                    T val0 = ls_cell.divergence( *interface_point );
//                    T error_curvature = std::abs( val0 + 1.0/radius) ;
//                    l1_divergence_error += error_curvature;
//                    l2_divergence_error += pow(error_curvature,2) ;
//                    linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;
//
//                }
            }
        }
        l1_divergence_error /= counter_interface_pts;

//        l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);

        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
//        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;
        std::cout<<bold<<yellow<<"The L1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << L1_divergence_error<<reset <<std::endl;
          
    }


}




template<typename Mesh,typename Level_Set,typename T , typename Velocity >
void
check_goal_quantities_final( Mesh& msh_i , Level_Set& ls_cell , Velocity& u_projected,  T& perimeter, T& d_a, T& area_fin, T& centre_mass_x , T&  centre_mass_y , size_t degree_FEM , T& mass_fin , size_t degree_velocity , T& l1_divergence_error_fin , T& l2_divergence_error_fin , T& linf_divergence_error_fin , T& radius , T& L1_divergence_error_fin , size_t time_step , T& rise_vel0 , T& rise_vel1 ,T& flux_interface ,size_t& counter_interface_pts_fin , size_t degree_curve , size_t n_int )
{
    
    // PLOTTING OF NORMAL
   typedef typename Mesh::point_type point_type;
           
    //postprocess_output<double> postoutput_vec;
    //auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

    

    std::vector<T>  val_u_n_fin ; //val_u_nx_fin , val_u_ny_fin ;
    std::vector< point<T, 2> > interface_points_plot_fin ;
    std::vector< std::pair<T,T> > vec_n ; // , velocity_interface , velocity_field , points_vel_field;



           

           for(auto& cl : msh_i.cells)
           {
               ls_cell.cell_assignment(cl);
               u_projected.cell_assignment(cl);

               if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
               {

                   T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                   area_fin += partial_area;

                   auto qps_fin = integrate( msh_i , cl , 2*degree_FEM , element_location::IN_NEGATIVE_SIDE);

                   for(auto& qp:qps_fin){
                       mass_fin += qp.second * ls_cell(qp.first);
                       centre_mass_x += qp.second * qp.first.x() ;
                       centre_mass_y += qp.second * qp.first.y() ;

                       rise_vel0 +=  qp.second * u_projected(qp.first).first;
                       rise_vel1 +=  qp.second * u_projected(qp.first).second;
                   }

               }
               if(cl.user_data.location == element_location::ON_INTERFACE)
               {

                   
                   auto qps = integrate_interface(msh_i, cl, degree_FEM, element_location::ON_INTERFACE);
                   for(auto& qp:qps){
                       T curv_err = std::abs(  ls_cell.divergence( qp.first )  + 1.0/radius ) ;
                       L1_divergence_error_fin += qp.second * curv_err ;
                       linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curv_err);
                       l1_divergence_error_fin += curv_err ;
                       counter_interface_pts_fin++;
                   }
                   
                   auto qps_un = integrate_interface(msh_i, cl, degree_FEM + degree_velocity , element_location::ON_INTERFACE);
                   for(auto& qp:qps_un){
                       T flux = u_projected(qp.first).first * ls_cell.normal(qp.first)(0) + u_projected(qp.first).second * ls_cell.normal(qp.first)(1) ;
                       flux_interface += qp.second * flux ;
                       
                       
                   }
                   
                   
                   perimeter += measure_interface(msh_i,cl,element_location::ON_INTERFACE);
                   
                   for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                   {
//                       T segment = ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                       perimeter += segment ;
//                       T val0 = ls_cell.divergence( *interface_point );
//                       T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
//                       l1_divergence_error_fin += curvature_error ;
//                       l2_divergence_error_fin += pow(curvature_error,2) ;
//                       linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);



                       Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                       std::pair<T,T> normal_vec_grad_cont = std::make_pair( normal_cont_grad(0) , normal_cont_grad(1) );

                       vec_n.push_back( normal_vec_grad_cont ) ;

                       T u_n_0 = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) ;
                       T u_n_1 = u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;

                       interface_points_plot_fin.push_back( *(interface_point) ) ;

                       val_u_n_fin.push_back( u_n_0 + u_n_1 );

                   }

                

               }
              

           }

     // --------- CHECKING CURVATURE DISC GRAD CONT (THE ONE USED INTO THE CODE) ----------
    postprocess_output<T> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
    std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);
    std::string filename_curv_var_inner_cl = "inner_cell_limit_curv_var_"+ std::to_string(time_step) +".dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);
          
    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            
            if(!first_cut_cell_found)
            {
                ls_cell.cell_assignment(cl);
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl  ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                }
    
    
                size_t pos_index = 0;
                size_t pos_index_bis = 0;
                   
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                        test_curv_var_cell->add_data(curv_var, val0);
                        
                        
                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                    {
                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                        assert(offset_cells.size() == 2);
                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                        T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
                        T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
                             
                        test_inner_cell->add_data(curv_var, val_skeleton0);
                        test_inner_cell->add_data(curv_var, val_skeleton1);
                        if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                    }

                    
                    test_curv_var_divergence0->add_data(curv_var, val0);
                    if(*interface_point == *(cl.user_data.interface.end() -1))
                        distance_pts +=  0.0 ;
                    else
                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
                    pos_index++;
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
                        ls_cell.cell_assignment(cl);
                        
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                        }
                        size_t pos_index = 0;
                        size_t pos_index_bis = 0;
                            
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);
                                
                            if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                            {
                                auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh, *interface_point,cl);
                                assert(offset_cells.size() == 2);
                                auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                                auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                                T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
                                T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
                                    
                                test_inner_cell->add_data(curv_var, val_skeleton0);
                                test_inner_cell->add_data(curv_var, val_skeleton1);
                                if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                            }
                                
                                
                            if(*interface_point == *(cl.user_data.interface.end() -1))
                                distance_pts += 0.0 ;
                            else
                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            pos_index++;
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    


    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.add_object(test_inner_cell);
    
    postoutput_div2.write();
    
    
    
    
    // --------- CHECKING CURVATURE DISC ----------
    postprocess_output<T> postoutput_div_bis;
    std::string filename_curvature_k2 = "k0_curvature_disc_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_divergence2 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k2);
    std::string filename_curv_var2 = "cell_limit_disc_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_cell2 = std::make_shared< gnuplot_output_object<double> >(filename_curv_var2);
    std::string filename_curv_var_inner_cl2 = "inner_cell_limit_disc_"+ std::to_string(time_step) +".dat";
    auto test_inner_cell2 = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl2);
          
    bool first_cut_cell_found2 = FALSE ;
    T distance_pts2 = 0.0;
    point<T,2> first_point2 ;
    point<T,2> cell_end_point2;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found2)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                }
    
    
                size_t pos_index = 0;
                size_t pos_index_bis = 0;
                   
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T val0 = ls_cell.divergence_disc( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts2 , 0.0);
                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                        test_curv_var_cell2->add_data(curv_var, val0);
                        
                        
                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                    {
                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                        assert(offset_cells.size() == 2);
                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                        T val_skeleton0 = ls_cell.divergence_disc( *interface_point , subcl0 );
                        T val_skeleton1 = ls_cell.divergence_disc( *interface_point , subcl1 );
                             
                        test_inner_cell2->add_data(curv_var, val_skeleton0);
                        test_inner_cell2->add_data(curv_var, val_skeleton1);
                        if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                    }

                    
                    test_curv_var_divergence2->add_data(curv_var, val0);
                    if(*interface_point == *(cl.user_data.interface.end() -1))
                        distance_pts2 +=  0.0 ;
                    else
                        distance_pts2 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
                    pos_index++;
                }
                first_cut_cell_found2 = TRUE;
                first_point2 = *cl.user_data.interface.begin() ;
                cell_end_point2 = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found2 && !( first_point2 == cell_end_point2  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point2 == *cl.user_data.interface.begin() ) && !( first_point2 == cell_end_point2)  )
                    {
                        ls_cell.cell_assignment(cl);
                        
                        bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                        }
                        size_t pos_index = 0;
                        size_t pos_index_bis = 0;
                            
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence_disc( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts2 , 0.0);
                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                                test_curv_var_cell2->add_data(curv_var, val0);

                            test_curv_var_divergence2->add_data(curv_var, val0);
                                
                            if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                            {
                                auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh, *interface_point,cl);
                                assert(offset_cells.size() == 2);
                                auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                                auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                                T val_skeleton0 = ls_cell.divergence_disc( *interface_point , subcl0 );
                                T val_skeleton1 = ls_cell.divergence_disc( *interface_point , subcl1 );
                                    
                                test_inner_cell2->add_data(curv_var, val_skeleton0);
                                test_inner_cell2->add_data(curv_var, val_skeleton1);
                                if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                            }
                                
                                
                            if(*interface_point == *(cl.user_data.interface.end() -1))
                                distance_pts2 += 0.0 ;
                            else
                                distance_pts2 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            pos_index++;
                        }
                        cell_end_point2 = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    


    postoutput_div_bis.add_object(test_curv_var_divergence2);
    postoutput_div_bis.add_object(test_curv_var_cell2);
    postoutput_div_bis.add_object(test_inner_cell2);
    
    postoutput_div_bis.write();
    
    
    
    goal_quantities_time_fast(msh_i , interface_points_plot_fin , val_u_n_fin  , vec_n , time_step);

   
           //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , vec_n , velocity_interface , velocity_field , points_vel_field , time_step ) ;
           //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;

           //if(time_step == T_N)
           //    testing_level_set_time(msh,level_set_function, tot_time,time_step);

           
    
}

template<typename Mesh,typename Level_Set , typename Para_Interface, typename T , typename Velocity >
void
check_goal_quantities_final_para( Mesh& msh_i ,Level_Set& ls_cell ,  Para_Interface& para_interface , Velocity& u_projected,  T& perimeter, T& d_a, T& area_fin, T& centre_mass_x , T&  centre_mass_y , size_t degree_FEM , T& mass_fin , size_t degree_velocity , T& l1_divergence_error_fin , T& l2_divergence_error_fin , T& linf_divergence_error_fin , T& radius , T& L1_divergence_error_fin , size_t time_step , T& rise_vel0 , T& rise_vel1 ,T& flux_interface ,size_t& counter_interface_pts_fin , size_t degree_curve , size_t n_int )
{
    
    // PLOTTING OF NORMAL
   typedef typename Mesh::point_type point_type;
           
    //postprocess_output<double> postoutput_vec;
    //auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

    

    std::vector<T>  val_u_n_fin ; //val_u_nx_fin , val_u_ny_fin ;
    std::vector< point<T, 2> > interface_points_plot_fin ;
    std::vector< std::pair<T,T> > vec_n ; // , velocity_interface , velocity_field , points_vel_field;
    
    T tot_error = 100 ;


           

           for(auto& cl : msh_i.cells)
           {
               ls_cell.cell_assignment(cl);
               u_projected.cell_assignment(cl);

               if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
               {

                   T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                   area_fin += partial_area;

                   auto qps_fin = integrate( msh_i , cl , 2*degree_FEM , element_location::IN_NEGATIVE_SIDE);
                

                   for(auto& qp:qps_fin){
                       mass_fin += qp.second * ls_cell(qp.first);
                       centre_mass_x += qp.second * qp.first.x() ;
                       centre_mass_y += qp.second * qp.first.y() ;

                       rise_vel0 +=  qp.second * u_projected(qp.first).first;
                       rise_vel1 +=  qp.second * u_projected(qp.first).second;
                   }

               }
               if(cl.user_data.location == element_location::ON_INTERFACE)
               {

                   
//                   auto qps = integrate_interface(msh_i, cl, degree_FEM, element_location::ON_INTERFACE);
                   
                   
                   auto global_cells_i = para_interface.get_global_cells_interface(msh_i , cl);
                   auto integration_msh = cl.user_data.integration_msh ;
                   auto degree_int = 2*degree_curve; // 3*degree_curve -1;
                   auto qps = edge_quadrature<T>(degree_int);
                   //            auto qps += integrate_interface(msh_i, cl, degree_curve, element_location::ON_INTERFACE) ;
                               
                   for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                    {
                        auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                        size_t global_cl_i = global_cells_i[i_cell] ;
                                   
                        for(auto& qp:qps)
                        {
                            auto t = 0.5 * qp.first.x() + 0.5;
                            auto curv_err = std::abs( para_interface.curvature_cont(t , global_cl_i ) + 1.0/radius);
                            T jacobian = para_interface.jacobian_cont( t , global_cl_i ) ;
                            auto w = 0.5 * qp.second * jacobian ;
                            L1_divergence_error_fin += curv_err*w ;
                            
                   
                        }
                        for(int i = 0; i < tot_error ; i++)
                        {
                            T pos = 0.0+i/tot_error ;
                            T val0 = para_interface.curvature_cont(pos, global_cl_i) ;
                            T error_curvature = std::abs( val0 + 1.0/radius) ;
                            
                            linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  error_curvature);
                            l1_divergence_error_fin += error_curvature ;
                            counter_interface_pts_fin++;
                                
                        
                            }
                    }
                   
//                   auto qps_un = integrate_interface(msh_i, cl, degree_FEM + degree_velocity , element_location::ON_INTERFACE);
//                   for(auto& qp:qps_un){
//                       T flux = u_projected(qp.first).first * ls_cell.normal(qp.first)(0) + u_projected(qp.first).second * ls_cell.normal(qp.first)(1) ;
//                       flux_interface += qp.second * flux ;
//
//
//                   }
                   
                   auto qps_un = edge_quadrature<T>(degree_int + degree_curve - 1+ degree_velocity);

                    for (size_t i_cell = 0; i_cell < integration_msh.cells.size(); i_cell++)
                    {
                        auto pts = points(integration_msh,integration_msh.cells[i_cell]);
                        size_t global_cl_i = global_cells_i[i_cell] ;

                        for(auto& qp:qps_un)
                        {
                            auto t = 0.5 * qp.first.x() + 0.5;

                            T jacobian = para_interface.jacobian_cont( t , global_cl_i ) ;
                            auto w = 0.5 * qp.second * jacobian ;

                            auto p = para_interface(t , global_cl_i ) ;
                            auto pt = typename Mesh::point_type(p(0) , p(1) ) ;
                            T flux = u_projected(pt).first * para_interface.normal_cont(t , global_cl_i)(0) + u_projected(pt).second * para_interface.normal_cont(t , global_cl_i)(1) ;
                            flux_interface += w * flux ;

                        }
                    }
                   
                   
                   perimeter += measure_interface(msh_i,cl,element_location::ON_INTERFACE);
                   
                   for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                   {
//                       T segment = ( *(interface_point+1) - *interface_point ).to_vector().norm();
//                       perimeter += segment ;
//                       T val0 = ls_cell.divergence( *interface_point );
//                       T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
//                       l1_divergence_error_fin += curvature_error ;
//                       l2_divergence_error_fin += pow(curvature_error,2) ;
//                       linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);



                       Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                       std::pair<T,T> normal_vec_grad_cont = std::make_pair( normal_cont_grad(0) , normal_cont_grad(1) );

                       vec_n.push_back( normal_vec_grad_cont ) ;

                       T u_n_0 = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) ;
                       T u_n_1 = u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;

                       interface_points_plot_fin.push_back( *(interface_point) ) ;

                       val_u_n_fin.push_back( u_n_0 + u_n_1 );

                   }

                

               }
              

           }

     // --------- CHECKING CURVATURE DISC GRAD CONT (THE ONE USED INTO THE CODE) ----------
    postprocess_output<T> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
    std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);
    std::string filename_curv_var_inner_cl = "inner_cell_limit_curv_var_"+ std::to_string(time_step) +".dat";
    auto test_inner_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl);
          
    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            
            if(!first_cut_cell_found)
            {
                ls_cell.cell_assignment(cl);
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl  ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                }
    
    
                size_t pos_index = 0;
                size_t pos_index_bis = 0;
                   
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                        test_curv_var_cell->add_data(curv_var, val0);
                        
                        
                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                    {
                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                        assert(offset_cells.size() == 2);
                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                        T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
                        T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
                             
                        test_inner_cell->add_data(curv_var, val_skeleton0);
                        test_inner_cell->add_data(curv_var, val_skeleton1);
                        if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                    }

                    
                    test_curv_var_divergence0->add_data(curv_var, val0);
                    if(*interface_point == *(cl.user_data.interface.end() -1))
                        distance_pts +=  0.0 ;
                    else
                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
                    pos_index++;
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point == *cl.user_data.interface.begin() ) && !( first_point == cell_end_point)  )
                    {
                        ls_cell.cell_assignment(cl);
                        
                         bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                        }
                        size_t pos_index = 0;
                        size_t pos_index_bis = 0;
                            
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);
                                
                            if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                            {
                                auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh, *interface_point,cl);
                                assert(offset_cells.size() == 2);
                                auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                                auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                                T val_skeleton0 = ls_cell.divergence( *interface_point , subcl0 );
                                T val_skeleton1 = ls_cell.divergence( *interface_point , subcl1 );
                                    
                                test_inner_cell->add_data(curv_var, val_skeleton0);
                                test_inner_cell->add_data(curv_var, val_skeleton1);
                                if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                            }
                                
                                
                            if(*interface_point == *(cl.user_data.interface.end() -1))
                                distance_pts += 0.0 ;
                            else
                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            pos_index++;
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    


    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.add_object(test_inner_cell);
    
    postoutput_div2.write();
    
    
    
    
    // --------- CHECKING CURVATURE DISC ----------
    postprocess_output<T> postoutput_div_bis;
    std::string filename_curvature_k2 = "k0_curvature_disc_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_divergence2 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k2);
    std::string filename_curv_var2 = "cell_limit_disc_" + std::to_string(time_step) + ".dat";
    auto test_curv_var_cell2 = std::make_shared< gnuplot_output_object<double> >(filename_curv_var2);
    std::string filename_curv_var_inner_cl2 = "inner_cell_limit_disc_"+ std::to_string(time_step) +".dat";
    auto test_inner_cell2 = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_inner_cl2);
          
    bool first_cut_cell_found2 = FALSE ;
    T distance_pts2 = 0.0;
    point<T,2> first_point2 ;
    point<T,2> cell_end_point2;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found2)
            {
                 bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                std::vector< size_t > index_inner_cls ;
                if( agglo_cl ){
                    for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                        index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                }
    
    
                size_t pos_index = 0;
                size_t pos_index_bis = 0;
                   
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T val0 = ls_cell.divergence_disc( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts2 , 0.0);
                    if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                        test_curv_var_cell2->add_data(curv_var, val0);
                        
                        
                    if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                    {
                        auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh,*interface_point,cl);
                        assert(offset_cells.size() == 2);
                        auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                        auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                        T val_skeleton0 = ls_cell.divergence_disc( *interface_point , subcl0 );
                        T val_skeleton1 = ls_cell.divergence_disc( *interface_point , subcl1 );
                             
                        test_inner_cell2->add_data(curv_var, val_skeleton0);
                        test_inner_cell2->add_data(curv_var, val_skeleton1);
                        if( pos_index_bis+1 < index_inner_cls.size() )
                            pos_index_bis++;
                    }

                    
                    test_curv_var_divergence2->add_data(curv_var, val0);
                    if(*interface_point == *(cl.user_data.interface.end() -1))
                        distance_pts2 +=  0.0 ;
                    else
                        distance_pts2 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    // In the case in which *interface_point == *(cl.user_data.interface.end() -1) I'm in the skeleton and it means that the next point it will be in the same abscisse.
                    pos_index++;
                }
                first_cut_cell_found2 = TRUE;
                first_point2 = *cl.user_data.interface.begin() ;
                cell_end_point2 = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found2 && !( first_point2 == cell_end_point2  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point2 == *cl.user_data.interface.begin() ) && !( first_point2 == cell_end_point2)  )
                    {
                        ls_cell.cell_assignment(cl);
                        
                        bool agglo_cl = cl.user_data.highlight && ( (cl.user_data.interface.size() > pow(2,n_int)*degree_curve +1)) ;
                        size_t amount_sub_cls = cl.user_data.offset_subcells.size();
                        std::vector< size_t > index_inner_cls ;
                        if( agglo_cl ){
                            for(size_t i_cl = 1 ; i_cl < amount_sub_cls ; i_cl++)
                                index_inner_cls.push_back( i_cl*(cl.user_data.interface.size() - 1)/amount_sub_cls );
                        }
                        size_t pos_index = 0;
                        size_t pos_index_bis = 0;
                            
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence_disc( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts2 , 0.0);
                            if( interface_point == cl.user_data.interface.begin() || interface_point == (cl.user_data.interface.end()-1) )
                                test_curv_var_cell2->add_data(curv_var, val0);

                            test_curv_var_divergence2->add_data(curv_var, val0);
                                
                            if( agglo_cl && pos_index == index_inner_cls[pos_index_bis])
                            {
                                auto offset_cells = pt_in_subcell_skeleton(ls_cell.level_set.msh, *interface_point,cl);
                                assert(offset_cells.size() == 2);
                                auto subcl0 = ls_cell.level_set.msh.cells[offset_cells[0]];
                                auto subcl1 = ls_cell.level_set.msh.cells[offset_cells[1]];
                                T val_skeleton0 = ls_cell.divergence_disc( *interface_point , subcl0 );
                                T val_skeleton1 = ls_cell.divergence_disc( *interface_point , subcl1 );
                                    
                                test_inner_cell2->add_data(curv_var, val_skeleton0);
                                test_inner_cell2->add_data(curv_var, val_skeleton1);
                                if( pos_index_bis+1 < index_inner_cls.size() )
                                    pos_index_bis++;
                            }
                                
                                
                            if(*interface_point == *(cl.user_data.interface.end() -1))
                                distance_pts2 += 0.0 ;
                            else
                                distance_pts2 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            pos_index++;
                        }
                        cell_end_point2 = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    


    postoutput_div_bis.add_object(test_curv_var_divergence2);
    postoutput_div_bis.add_object(test_curv_var_cell2);
    postoutput_div_bis.add_object(test_inner_cell2);
    
    postoutput_div_bis.write();
    
    
    
    goal_quantities_time_fast(msh_i , interface_points_plot_fin , val_u_n_fin  , vec_n , time_step);

   
           //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , vec_n , velocity_interface , velocity_field , points_vel_field , time_step ) ;
           //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;

           //if(time_step == T_N)
           //    testing_level_set_time(msh,level_set_function, tot_time,time_step);

           
    
}


/////////////////////////   AUTOMATIC TESTS  //////////////////////////


void convergence_test(void)
{
    using T = double;

    std::vector<size_t> mesh_sizes, pol_orders;

    // meshes
    mesh_sizes.push_back(8);
    mesh_sizes.push_back(16);
    mesh_sizes.push_back(32);
    mesh_sizes.push_back(64);
    // mesh_sizes.push_back(128);
    // mesh_sizes.push_back(256);

    // polynomial orders
    pol_orders.push_back(0);
    pol_orders.push_back(1);
    pol_orders.push_back(2);
    pol_orders.push_back(3);


    // export to files ...
    std::vector<std::string> files;
    files.push_back("./output/test_k0.txt");
    files.push_back("./output/test_k1.txt");
    files.push_back("./output/test_k2.txt");
    files.push_back("./output/test_k3.txt");

    for (std::vector<size_t>::iterator it = pol_orders.begin(); it != pol_orders.end(); it++)
    {
        size_t k = *it;

        std::cout << "start tests for k = " << k << std::endl;

        // init the file
        std::ofstream output;
        output.open (files.at(*it), std::ios::in | std::ios::trunc);
        if (!output.is_open())
            throw std::logic_error("file not open");

        // output << "N\th\tH1\tordre1\tL2\tordre2" << std::endl;
        output << "N\th\tH1\tordre1\tL2\tordre2\tLp\tordre3\tcond" << std::endl;

        // convergence tests
        T previous_H1 = 0.0;
        T previous_L2 = 0.0;
        T previous_p = 0.0;
        T previous_h = 0.0;
        for (std::vector<size_t>::iterator it_msh = mesh_sizes.begin();
             it_msh != mesh_sizes.end(); it_msh++)
        {
            size_t N = *it_msh;

            // init mesh (with agglomeration)
            mesh_init_params<T> mip;
            mip.Nx = N;
            mip.Ny = N;
            cuthho_poly_mesh<T> msh(mip);
            size_t int_refsteps = 4;
            T radius = 1.0/3.0;
            //auto circle_level_set_function = circle_level_set<T>(radius, 0.5, 0.5);

            // auto level_set_function = flower_level_set<T>(0.31, 0.5, 0.5, 4, 0.04);
            auto level_set_function = circle_level_set<T>(radius, 0.5, 0.5);
            // auto level_set_function = square_level_set<T>(1.05, -0.05, -0.05, 1.05);
            // auto level_set_function = square_level_set<T>(1.0, -0.0, -0.0, 1.0);
            //auto level_set_function = square_level_set<T>(0.76, 0.24, 0.24, 0.76);
            detect_node_position(msh, level_set_function);
            detect_cut_faces(msh, level_set_function);
            if(1)  // AGGLOMERATION
            {
                detect_cut_cells(msh, level_set_function);
                detect_cell_agglo_set(msh, level_set_function);
                make_neighbors_info_cartesian(msh);
                refine_interface(msh, level_set_function, int_refsteps);
                make_agglomeration(msh, level_set_function);
            }
            else  // NODE DISPLACEMENT
            {
                move_nodes(msh, level_set_function);
                detect_cut_faces(msh, level_set_function); //do it again to update intersection points
                detect_cut_cells(msh, level_set_function);
                refine_interface(msh, level_set_function, int_refsteps);
            }

            // compute solution/errors
            stokes_test_info<T> TI;

            if(1)
            {
                // auto test_case = make_test_case_stokes_1(msh, level_set_function);
                //auto test_case = make_test_case_stokes_2(msh, level_set_function);
                T gamma = 1.0 ; //1.0 ; //0.05 ;
                auto test_case = make_test_case_static_bubble(msh, radius, 0.5, 0.5, gamma , level_set_function) ;  // DELETED TO CHECK FAST IMPLEMENTATION
                //TI = run_cuthho_fictdom(msh, k, test_case);
                auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);
                TI = run_cuthho_interface(msh, k, method, test_case);
            }

            // report info in the file
            T h = 1.0/N;
            if (it_msh == mesh_sizes.begin())
            {
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << "."
                       << "\t" << TI.L2_vel << "\t" << "." << "\t" << TI.L2_p
                       << "\t" << "." << "\t" << TI.cond
                       << std::endl;
            }
            else
            {
                T orderH = log(previous_H1 / TI.H1_vel) / log(previous_h / h);
                T orderL = log(previous_L2 / TI.L2_vel) / log(previous_h / h);
                T orderp = log(previous_p / TI.L2_p) / log(previous_h / h);
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << orderH
                       << "\t" << TI.L2_vel << "\t" << orderL << "\t" << TI.L2_p
                       << "\t" << orderp << "\t" << TI.cond
                       << std::endl;
            }
            previous_H1 = TI.H1_vel;
            previous_L2 = TI.L2_vel;
            previous_p = TI.L2_p;
            previous_h = h;
        }
        // close the file
        output.close();
    }

    // update the gnuplot curves
    //system("gnuplot './output/gnuplot_script_stokes.txt'");

    // update the .pdf file
    //system("pdflatex ./output/autom_tests_stokes.tex");

    // open the .pdf file
    //system("xdg-open ./autom_tests_stokes.pdf");
}


// Analysis made by Stefano to check optimal u*n error. Analytical level set implementation.
void convergence_test_normal_error(size_t degree_curve , size_t int_refsteps)
{
    using T = double;

    std::vector<size_t> mesh_sizes, pol_orders;

    // meshes
    mesh_sizes.push_back(8);
    mesh_sizes.push_back(16);
    mesh_sizes.push_back(32);
    mesh_sizes.push_back(64);
    // mesh_sizes.push_back(128);
    // mesh_sizes.push_back(256);

    // polynomial orders
    pol_orders.push_back(0);
    pol_orders.push_back(1);
    pol_orders.push_back(2);
    pol_orders.push_back(3);


    // export to files ...
    std::vector<std::string> files;
    files.push_back("./output/test_k0.txt");
    files.push_back("./output/test_k1.txt");
    files.push_back("./output/test_k2.txt");
    files.push_back("./output/test_k3.txt");

    for (std::vector<size_t>::iterator it = pol_orders.begin(); it != pol_orders.end(); it++)
    {
        size_t k = *it;

        std::cout << "start tests for k = " << k << std::endl;

        // init the file
        std::ofstream output;
        output.open (files.at(*it), std::ios::in | std::ios::trunc);
        if (!output.is_open())
            throw std::logic_error("file not open");

        // output << "N\th\tH1\tordre1\tL2\tordre2" << std::endl;
        output << "N\th\tH1\tordre1\tL2\tordre2\tLp\tordre3\tcond\tl2_u_n\tordre4\tlinf_u_n\tordre5" << std::endl;

        // convergence tests
        T previous_H1 = 0.0;
        T previous_L2 = 0.0;
        T previous_p = 0.0;
        T previous_h = 0.0;
        T previous_l2_un = 0.0 ;
        T previous_linf_un = 0.0 ;
        for (std::vector<size_t>::iterator it_msh = mesh_sizes.begin();
             it_msh != mesh_sizes.end(); it_msh++)
        {
            size_t N = *it_msh;

            // init mesh (with agglomeration)
            mesh_init_params<T> mip;
            mip.Nx = N;
            mip.Ny = N;
            cuthho_poly_mesh<T> msh(mip);
            typedef cuthho_poly_mesh<T> Mesh;
//            size_t int_refsteps = 1;
            std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;
            T radius = 1.0/3.0;
            //auto circle_level_set_function = circle_level_set<T>(radius, 0.5, 0.5);

            // auto level_set_function = flower_level_set<T>(0.31, 0.5, 0.5, 4, 0.04);
            auto level_set_function = circle_level_set<T>(radius, 0.5, 0.5);
            // auto level_set_function = square_level_set<T>(1.05, -0.05, -0.05, 1.05);
            // auto level_set_function = square_level_set<T>(1.0, -0.0, -0.0, 1.0);
            //auto level_set_function = square_level_set<T>(0.76, 0.24, 0.24, 0.76);
            
//            T degree_curve = 2 ;
            auto curve = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
            std::cout<<"Parametric Interface: degree = "<<degree_curve<<std::endl;
            
            
            detect_node_position(msh, level_set_function);
            detect_cut_faces(msh, level_set_function);
            if(1)  // AGGLOMERATION
            {
                std::cout<<"Funziona solo per degree curve PARI, altrimenti modificare refine_interface_pro3_curve_para anche per analytical level set"<<std::endl;
                detect_cut_cells(msh, level_set_function);
//                refine_interface_pro3_curve_para(msh, level_set_function, int_refsteps,degree_curve);
                set_integration_mesh(msh,degree_curve) ; // NON FUNZIONA PER TUTTI I VAL DI INT_REF
                detect_cell_agglo_set(msh, level_set_function);
                make_neighbors_info_cartesian(msh);
                refine_interface(msh, level_set_function, int_refsteps);
                make_agglomeration(msh, level_set_function);
                set_integration_mesh(msh,degree_curve) ; // NON FUNZIONA PER TUTTI I VAL DI INT_REF
                
            }
            else  // NODE DISPLACEMENT
            {
                move_nodes(msh, level_set_function);
                detect_cut_faces(msh, level_set_function); //do it again to update intersection points
                detect_cut_cells(msh, level_set_function);
                refine_interface(msh, level_set_function, int_refsteps);
            }

            // compute solution/errors
            stokes_test_info<T> TI;

            if(1)
            {
                // auto test_case = make_test_case_stokes_1(msh, level_set_function);
                //auto test_case = make_test_case_stokes_2(msh, level_set_function);
                T gamma = 1.0 ; // 0.05  // IT WAS make_test_case_static_bubble (CHECKING ERROR)
                auto test_case = make_test_case_static_bubble(msh, radius, 0.5, 0.5, gamma , level_set_function) ;
                //TI = run_cuthho_fictdom(msh, k, test_case);
                auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);
                bool normal_analysis =  true ;
                TI = run_cuthho_interface(msh, k, method, test_case , normal_analysis );
            }

            // report info in the file
            T h = 1.0/N;


            if (it_msh == mesh_sizes.begin())
            {
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << "."
                       << "\t" << TI.L2_vel << "\t" << "." << "\t" << TI.L2_p
                       << "\t" << "." << "\t" << TI.cond   << "\t" << TI.l2_normal_vel
                       << "\t" << "." << "\t" << TI.linf_normal_vel << "\t" << "."
                       << std::endl;
            }
            else
            {
                T orderH = log(previous_H1 / TI.H1_vel) / log(previous_h / h);
                T orderL = log(previous_L2 / TI.L2_vel) / log(previous_h / h);
                T orderp = log(previous_p / TI.L2_p) / log(previous_h / h);
                T orderl2_un = log(previous_l2_un / TI.l2_normal_vel) / log(previous_h / h);
                T orderlinf_un = log(previous_linf_un / TI.linf_normal_vel) / log(previous_h / h);

                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << orderH
                       << "\t" << TI.L2_vel << "\t" << orderL << "\t" << TI.L2_p
                       << "\t" << orderp << "\t" << TI.cond   << "\t" << TI.l2_normal_vel
                       << "\t" << orderl2_un << "\t" << TI.linf_normal_vel << "\t" << orderlinf_un
                       << std::endl;
            }
            previous_H1 = TI.H1_vel;
            previous_L2 = TI.L2_vel;
            previous_p = TI.L2_p;
            previous_h = h;
            previous_l2_un = TI.l2_normal_vel ;
            previous_linf_un = TI.linf_normal_vel ;
        }
        // close the file
        output.close();
    }

    // update the gnuplot curves
    system("gnuplot './output/gnuplot_script_stokes.txt'");

    // update the .pdf file
    system("pdflatex ./output/autom_tests_stokes.tex");

    // open the .pdf file
    system("xdg-open ./autom_tests_stokes.pdf");
}

void convergence_test_normal_error_numerical_ls_test_best_ls(size_t degree_FEM, size_t degree_curve, size_t int_refsteps)
{
    using T = double;

    std::vector<size_t> mesh_sizes, pol_orders;

    // meshes
    mesh_sizes.push_back(8);
    mesh_sizes.push_back(16);
    mesh_sizes.push_back(32);
//    mesh_sizes.push_back(64);
    // mesh_sizes.push_back(128);
    // mesh_sizes.push_back(256);

    // polynomial orders
//    pol_orders.push_back(0);
    pol_orders.push_back(1);
//    pol_orders.push_back(2);
    //pol_orders.push_back(3);


    // export to files ...
    std::vector<std::string> files;
    files.push_back("./output/test_k0.txt");
    files.push_back("./output/test_k1.txt");
    files.push_back("./output/test_k2.txt");
    files.push_back("./output/test_k3.txt");

    for (std::vector<size_t>::iterator it = pol_orders.begin(); it != pol_orders.end(); it++)
    {
        size_t k = *it;

        std::cout << "start tests for k = " << k << std::endl;

        // init the file
        std::ofstream output;
        output.open (files.at(*it), std::ios::in | std::ios::trunc);
        if (!output.is_open())
            throw std::logic_error("file not open");

        // output << "N\th\tH1\tordre1\tL2\tordre2" << std::endl;
        output << "N\th\tH1\tordre1\tL2\tordre2\tLp\tordre3\tcond\tl1_u_n\tordre4\tL1_u_n\tordre5\tlinf_u_n\tordre6" << std::endl;

        // convergence tests
        T previous_H1 = 0.0;
        T previous_L2 = 0.0;
        T previous_p = 0.0;
        T previous_h = 0.0;
        T previous_l1_un = 0.0 ;
        T previous_l2_un = 0.0 ;
        T previous_linf_un = 0.0 ;

        for (std::vector<size_t>::iterator it_msh = mesh_sizes.begin();
             it_msh != mesh_sizes.end(); it_msh++)
        {
            size_t N = *it_msh;

            // init mesh (with agglomeration)
            mesh_init_params<T> mip;
            mip.Nx = N;
            mip.Ny = N;
            cuthho_poly_mesh<T> msh(mip);
            typedef cuthho_poly_mesh<T> Mesh;
            offset_definition(msh);     // For Original Mesh
            
//            size_t int_refsteps = 3 ;
            std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

            /************** FINITE ELEMENT INITIALIZATION **************/
//            size_t degree_FEM = 2 ;
            auto fe_data = Finite_Element<T,Mesh>( msh , degree_FEM , mip ) ;
            typedef Finite_Element<T,Mesh> FiniteSpace;
            std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;
            
            /**************************************TRANSPORT PROBLEM METHOD *****************************************/
            auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
            //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

            size_t  degree_gradient = degree_FEM ;
            auto fe_data_gradient = Finite_Element<T,Mesh>( msh , degree_gradient , mip ) ;
            auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;

            size_t  degree_div = degree_FEM - 1 ;
            std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
            auto fe_data_div = Finite_Element<T,Mesh>( msh , degree_div , mip ) ;
            auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;

            
             /************** PARAMETRIC INTERFACE  **************/
//            T degree_curve = 2 ;
            auto curve = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
            std::cout<<"Parametric Interface: degree = "<<degree_curve<<std::endl;
            /************** ANALYTIC LEVEL SET FUNCTION  **************/
            T radius = 1.0/3.0;
            T x_centre = 0.5 ;
            T y_centre = 0.5 ;
            auto level_set_function_anal = circle_level_set<T>(radius, x_centre, y_centre);
            typedef  circle_level_set<T> Fonction;
            
//            radius = 0.31 ;
//            auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04);
//            typedef  flower_level_set<T> Fonction;
            
            
            // auto level_set_function_anal = square_level_set<T>(1.05, -0.05, -0.05, 1.05);
            // auto level_set_function_anal = square_level_set<T>(1.0, -0.0, -0.0, 1.0);
            //auto level_set_function_anal = square_level_set<T>(0.76, 0.24, 0.24, 0.76);

            /************** LEVEL SET FUNCTION DISCRETISATION **************/
            
//            auto level_set_function = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );
//            typedef Level_set_berstein< Mesh , Fonction , FiniteSpace , T > Level_Set;
//
//            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            
            auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
                  //---> CHECK POI SE SERVE O MENO!!!!! (L'HO MESSO ANCHE NEL MAIN FINALE)
            level_set_function.gradient_continuous_setting() ;
            typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;


            

            //testing_level_set(msh, level_set_function, level_set_function_anal);
            offset_definition(msh);     // For Agglomerated Mesh
            detect_node_position3(msh, level_set_function);
            detect_cut_faces3(msh, level_set_function);
            if(1)  // AGGLOMERATION
            {
                detect_cut_cells3(msh, level_set_function);
                refine_interface_pro3_curve_para(msh, level_set_function, int_refsteps,degree_curve);
                set_integration_mesh(msh,degree_curve) ;
                detect_cell_agglo_set(msh, level_set_function);
                make_neighbors_info_cartesian(msh);
                //refine_interface_pro3(msh, level_set_function, int_refsteps);
                
                std::cout<<"WARNING: in agglomerated cells the integrations points are saved at priori (for a high degree). COMPUTATIONALLY USELESS."<<std::endl;
                make_agglomeration_no_double_points(msh, level_set_function,degree_curve);
                set_integration_mesh(msh,degree_curve) ;
            }
            else  // NODE DISPLACEMENT
            {
                move_nodes(msh, level_set_function);
                detect_cut_faces3(msh, level_set_function); //do it again to update intersection points
                detect_cut_cells3(msh, level_set_function);
                refine_interface_pro3_curve_para(msh, level_set_function, int_refsteps,degree_curve);
            }

            /************** UPDATING  LEVEL SET   **************/
//             level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//
//            auto ls_cell = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);
//            auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);
//            auto ls_cell = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);
            
            
            level_set_function.gradient_continuous_setting() ;
            auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh );
            ls_cell.radius = radius ;
            //ls_cell.agglo_msh = msh ;



            // CHECK DIVERGENCE ERROR OVER THE INTERFACE
            postprocess_output<double> postoutput_div2;
            std::string filename_curvature_k0 = "./output/k_HHO("+ std::to_string(k) +")_mesh_"+ std::to_string(N) +".dat";
            auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
            std::string filename_curvature_k1 = "./output/global_curvature_HHO("+ std::to_string(k) +")_mesh_"+ std::to_string(N) +".dat";
            auto test_global_curvature = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k1);
            std::string filename_curv_var = "./output/cell_limit_HHO("+ std::to_string(k) +")_mesh_"+ std::to_string(N) +".dat";
            auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);


            T l1_divergence_error = 0. ;
            T linf_divergence_error = -10.0 ;
            T L1_divergence_error = 0. ;
            size_t counter_interface_pts = 0;

            for(auto& cl : msh.cells)
            {


                ls_cell.cell_assignment(cl);
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    auto qps = integrate_interface(msh, cl, degree_FEM, element_location::ON_INTERFACE);
                    for(auto& qp:qps){
                        T val = std::abs( std::abs(ls_cell.divergence(qp.first)) - 1.0/radius );
                        L1_divergence_error += qp.second * val ;
                        linf_divergence_error = std::max(linf_divergence_error , val ) ;
                        l1_divergence_error += val;
                        counter_interface_pts++;
                    }
                }
                auto pts = points(msh,cl) ;
                for(auto& pt : pts){
                    T k = ls_cell.divergence( pt ) ;
                    test_global_curvature->add_data( pt , k );
                }
            }

            bool first_cut_cell_found = FALSE ;
            T distance_pts = 0.0;
            point<T,2> first_point ;
            point<T,2> cell_end_point;
            typedef typename Mesh::point_type point_type;
            for(auto& cl : msh.cells)
            {

                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    if(!first_cut_cell_found)
                    {
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                        {
                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        first_cut_cell_found = TRUE;
                        first_point = *cl.user_data.interface.begin() ;
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }
                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                    {
                        for(auto& cl : msh.cells)
                        {
                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                            {
                                ls_cell.cell_assignment(cl);
                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                                {

                                    T val0 = ls_cell.divergence( *interface_point );

                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                                    if( interface_point == cl.user_data.interface.begin() )
                                        test_curv_var_cell->add_data(curv_var, val0);

                                    test_curv_var_divergence0->add_data(curv_var, val0);

                                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                                }
                                cell_end_point = *(cl.user_data.interface.end() -1) ;
                            }

                        }

                    }
                    else
                        break;

                }


            }
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_cell);
            postoutput_div2.add_object(test_global_curvature);

            //postoutput_div2.write();

            l1_divergence_error /= counter_interface_pts;
           
            std::cout<<"Implemented number of interface points is " << counter_interface_pts << std::endl;
            std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at t = 0 is " << l1_divergence_error <<std::endl;
           
            std::cout<<"The l^inf error of the CURVATURE at the INTERFACE, at t = 0 is " << linf_divergence_error <<std::endl;
            std::cout<<"The L1 error of the CURVATURE at the INTERFACE, at t = 0 is " << L1_divergence_error <<std::endl;


            bool l2proj_para = false ;
            bool l2proj = false ;
            bool avg = true ;
            
            Interface_parametrisation_mesh1d_global<Mesh> para_curve_cont(msh,degree_curve);
            para_curve_cont.make_L2_proj_para_derivative(msh);

            //--------------------- L2 global Normal from LS  ----------------------- //
            if(l2proj)
                para_curve_cont.make_L2_proj_para_normal(msh,ls_cell);
                   
            //---------------------------- Avg Normal from LS  ---------------------------- //
            if(avg)
                 para_curve_cont.make_avg_L2_local_proj_para_normal(msh, ls_cell);
            
             //------------- L2 cont curvature from parametric interface  r ---------- //
             if(l2proj_para)
                 para_curve_cont.make_L2_proj_para_curvature(msh);

              
             //-------------------- L2 global Curvature from LS  -------------------- //
             if(l2proj)
                 para_curve_cont.make_L2_proj_para_curvature(msh,ls_cell);
            
             //------------------- Avg Curvature from LS  ------------------------ //
             if(avg)
                 para_curve_cont.make_avg_L2_local_proj_para_curvature(msh, ls_cell);
            
       
            check_para_formulation_n_cont(msh,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
            
            


            // compute solution/errors
            stokes_test_info<T> TI;

            if(1)
            {
                // auto test_case = make_test_case_stokes_1(msh, level_set_function);
                //auto test_case = make_test_case_stokes_2(msh, level_set_function);
                auto prm = params<T>();
                prm.kappa_1 = 1.0;
                prm.kappa_2 = 1.0;
                //auto test_case = make_test_case_static_bubble(msh, radius, 0.5, 0.5, 0.05);
                //auto test_case = make_test_case_static_bubble_numerical_ls(msh, ls_cell,prm) ;
                T gamma = 1.0 ; //  1.0 ; // 0.05
                std::cout<<"test case: Eshelby, with gamma = "<<gamma<<std::endl;
                
//                auto test_case = make_test_case_eshelby_correct(msh, ls_cell, prm, true,gamma);
//                auto method = make_sym_gradrec_stokes_interface_method(msh, 1.0, 0.0, test_case, true);
                 
                // ************ Test Case Parametric Discontinuous ************
//                auto test_case = make_test_case_eshelby_correct_parametric(msh, ls_cell,  prm , true,gamma);
//                auto method = make_sym_gradrec_stokes_interface_method_ref_pts(msh, 1.0, 0.0, test_case, true);
                
                // ************ Test Case Parametric Continuous ************
                auto test_case = make_test_case_eshelby_correct_parametric_cont( msh, ls_cell , para_curve_cont, prm , true , gamma );
                auto method = make_sym_gradrec_stokes_interface_method_ref_pts_cont(msh, 1.0, 0.0, test_case, true);

                
                bool normal_analysis =  true ;
                //TI = run_cuthho_interface(msh, k, method, test_case , normal_analysis );
                TI = run_cuthho_interface_numerical_ls(msh, k, method, test_case , ls_cell ,  normal_analysis );
            }

            // report info in the file
            T h = 1.0/N;


            if (it_msh == mesh_sizes.begin())
            {
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << "."
                       << "\t" << TI.L2_vel << "\t" << "." << "\t" << TI.L2_p
                       << "\t" << "." << "\t" << TI.cond  << "\t" << TI.l1_normal_vel
                       << "\t" << "." << "\t" << TI.flux_interface << "\t" << "."
                       << "\t" << TI.linf_normal_vel << "\t" << "." << std::endl;
            }
            else
            {
                T orderH = log(previous_H1 / TI.H1_vel) / log(previous_h / h);
                T orderL = log(previous_L2 / TI.L2_vel) / log(previous_h / h);
                T orderp = log(previous_p / TI.L2_p) / log(previous_h / h);
                T orderl1_un = log(previous_l1_un / TI.l1_normal_vel) / log(previous_h / h);
                T orderl2_un = log(previous_l2_un / TI.flux_interface) / log(previous_h / h);
                T orderlinf_un = log(previous_linf_un / TI.linf_normal_vel) / log(previous_h / h);

                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << orderH
                       << "\t" << TI.L2_vel << "\t" << orderL << "\t" << TI.L2_p
                       << "\t" << orderp << "\t" << TI.cond << "\t" << TI.l1_normal_vel
                       << "\t" << orderl1_un   << "\t" << TI.flux_interface
                       << "\t" << orderl2_un << "\t" << TI.linf_normal_vel << "\t" << orderlinf_un
                       << std::endl;
            }
            previous_H1 = TI.H1_vel;
            previous_L2 = TI.L2_vel;
            previous_p = TI.L2_p;
            previous_h = h;
            previous_l1_un = TI.l1_normal_vel ;
            previous_l2_un = TI.flux_interface ;
            previous_linf_un = TI.linf_normal_vel ;
        }
        // close the file
        output.close();
    }

    // update the gnuplot curves
    //system("gnuplot './output/gnuplot_script_stokes.txt'");

    // update the .pdf file
    //system("pdflatex ./output/autom_tests_stokes.tex");

    // open the .pdf file
    //system("xdg-open ./autom_tests_stokes.pdf");
}

// Analysis made by Stefano to check optimal u*n error. Numerical level set implementation.
void convergence_test_normal_error_numerical_ls(size_t degree_FEM, size_t degree_curve, size_t int_refsteps)
{
    using T = double;

    std::vector<size_t> mesh_sizes, pol_orders;

    // meshes
    mesh_sizes.push_back(8);
    mesh_sizes.push_back(16);
    mesh_sizes.push_back(32);
    mesh_sizes.push_back(64);
    // mesh_sizes.push_back(128);
    // mesh_sizes.push_back(256);

    // polynomial orders
    pol_orders.push_back(0);
    pol_orders.push_back(1);
    pol_orders.push_back(2);
    //pol_orders.push_back(3);


    // export to files ...
    std::vector<std::string> files;
    files.push_back("./output/test_k0.txt");
    files.push_back("./output/test_k1.txt");
    files.push_back("./output/test_k2.txt");
    files.push_back("./output/test_k3.txt");

    for (std::vector<size_t>::iterator it = pol_orders.begin(); it != pol_orders.end(); it++)
    {
        size_t k = *it;

        std::cout << "start tests for k = " << k << std::endl;

        // init the file
        std::ofstream output;
        output.open (files.at(*it), std::ios::in | std::ios::trunc);
        if (!output.is_open())
            throw std::logic_error("file not open");

        // output << "N\th\tH1\tordre1\tL2\tordre2" << std::endl;
        output << "N\th\tH1\tordre1\tL2\tordre2\tLp\tordre3\tcond\tl1_u_n\tordre4\tL1_u_n\tordre5\tlinf_u_n\tordre6" << std::endl;

        // convergence tests
        T previous_H1 = 0.0;
        T previous_L2 = 0.0;
        T previous_p = 0.0;
        T previous_h = 0.0;
        T previous_l1_un = 0.0 ;
        T previous_l2_un = 0.0 ;
        T previous_linf_un = 0.0 ;

        for (std::vector<size_t>::iterator it_msh = mesh_sizes.begin();
             it_msh != mesh_sizes.end(); it_msh++)
        {
            size_t N = *it_msh;

            // init mesh (with agglomeration)
            mesh_init_params<T> mip;
            mip.Nx = N;
            mip.Ny = N;
            cuthho_poly_mesh<T> msh(mip);
            typedef cuthho_poly_mesh<T> Mesh;
            offset_definition(msh);     // For Original Mesh
            offset_definition(msh);     // For Agglomerated Mesh
//            size_t int_refsteps = 3 ;
            std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

            /************** FINITE ELEMENT INITIALIZATION **************/
//            size_t degree_FEM = 2 ;
            auto fe_data = Finite_Element<T,Mesh>( msh , degree_FEM , mip ) ;
            typedef Finite_Element<T,Mesh> FiniteSpace;
            std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;
            
//            T degree_curve = 4 ;
            auto curve = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
            std::cout<<"Parametric Interface: degree = "<<degree_curve<<std::endl;
            /************** ANALYTIC LEVEL SET FUNCTION  **************/
            T radius = 1.0/3.0;
            T x_centre = 0.5 ;
            T y_centre = 0.5 ;
            auto level_set_function_anal = circle_level_set<T>(radius, x_centre, y_centre);
            typedef  circle_level_set<T> Fonction;
            // auto level_set_function = flower_level_set<T>(0.31, 0.5, 0.5, 4, 0.04);
            //auto level_set_function = circle_level_set<T>(radius, 0.5, 0.5);
            // auto level_set_function = square_level_set<T>(1.05, -0.05, -0.05, 1.05);
            // auto level_set_function = square_level_set<T>(1.0, -0.0, -0.0, 1.0);
            //auto level_set_function = square_level_set<T>(0.76, 0.24, 0.24, 0.76);

            /************** LEVEL SET FUNCTION DISCRETISATION **************/
            // Bernstein-Vandermonde interpolation (order available 1,2,3) -> 0 TO BE CHECKED
            //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

            // FOR CONTINUOUS GRADIENT IMPLEMENTATION
            auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
        //---> CHECK POI SE SERVE O MENO!!!!! (L'HO MESSO ANCHE NEL MAIN FINALE)
            level_set_function.gradient_continuous_setting() ;

            //testing_level_set(msh, level_set_function, level_set_function_anal);

            detect_node_position3(msh, level_set_function);
            detect_cut_faces3(msh, level_set_function);
            if(1)  // AGGLOMERATION
            {
                detect_cut_cells3(msh, level_set_function);
                refine_interface_pro3_curve_para(msh, level_set_function, int_refsteps,degree_curve);
                set_integration_mesh(msh,degree_curve) ;
                detect_cell_agglo_set(msh, level_set_function);
                make_neighbors_info_cartesian(msh);
                //refine_interface_pro3(msh, level_set_function, int_refsteps);
                
                std::cout<<"WARNING: in agglomerated cells the integrations points are saved at priori (for a high degree). COMPUTATIONALLY USELESS."<<std::endl;
                make_agglomeration_no_double_points(msh, level_set_function,degree_curve);
                set_integration_mesh(msh,degree_curve) ;
            }
            else  // NODE DISPLACEMENT
            {
                move_nodes(msh, level_set_function);
                detect_cut_faces3(msh, level_set_function); //do it again to update intersection points
                detect_cut_cells3(msh, level_set_function);
                refine_interface_pro3_curve_para(msh, level_set_function, int_refsteps,degree_curve);
            }

            /************** UPDATING  LEVEL SET   **************/
            // FOR CONTINUOUS GRADIENT IMPLEMENTATION
            level_set_function.gradient_continuous_setting() ;

            //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
            // FOR CONTINUOUS GRADIENT IMPLEMENTATION
            typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;

            //auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh );

            // FOR CONTINUOUS GRADIENT IMPLEMENTATION
            auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh );

            ls_cell.radius = radius ;
            //ls_cell.agglo_msh = msh ;



            // CHECK DIVERGENCE ERROR OVER THE INTERFACE
            postprocess_output<double> postoutput_div2;
            std::string filename_curvature_k0 = "./output/k_HHO("+ std::to_string(k) +")_mesh_"+ std::to_string(N) +".dat";
            auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
            std::string filename_curvature_k1 = "./output/global_curvature_HHO("+ std::to_string(k) +")_mesh_"+ std::to_string(N) +".dat";
            auto test_global_curvature = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k1);

            std::string filename_curv_var = "./output/cell_limit_HHO("+ std::to_string(k) +")_mesh_"+ std::to_string(N) +".dat";
            auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);


            T l1_divergence_error = 0. ;
            T linf_divergence_error = -10.0 ;
            T L1_divergence_error = 0. ;
            size_t counter_interface_pts = 0;

            for(auto& cl : msh.cells)
            {


                ls_cell.cell_assignment(cl);
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    auto qps = integrate_interface(msh, cl, degree_FEM, element_location::ON_INTERFACE);
                    for(auto& qp:qps){
                        T val = std::abs( std::abs(ls_cell.divergence(qp.first)) - 1.0/radius );
                        L1_divergence_error += qp.second * val ;
                        linf_divergence_error = std::max(linf_divergence_error , val ) ;
                        l1_divergence_error += val;
                        counter_interface_pts++;
                    }
                }
                auto pts = points(msh,cl) ;
                for(auto& pt : pts){
                    T k = ls_cell.divergence( pt ) ;
                    test_global_curvature->add_data( pt , k );
                }
            }

            bool first_cut_cell_found = FALSE ;
            T distance_pts = 0.0;
            point<T,2> first_point ;
            point<T,2> cell_end_point;
            typedef typename Mesh::point_type point_type;
            for(auto& cl : msh.cells)
            {

                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    if(!first_cut_cell_found)
                    {
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                        {
                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        first_cut_cell_found = TRUE;
                        first_point = *cl.user_data.interface.begin() ;
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }
                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                    {
                        for(auto& cl : msh.cells)
                        {
                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                            {
                                ls_cell.cell_assignment(cl);
                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                                {

                                    T val0 = ls_cell.divergence( *interface_point );

                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                                    if( interface_point == cl.user_data.interface.begin() )
                                        test_curv_var_cell->add_data(curv_var, val0);

                                    test_curv_var_divergence0->add_data(curv_var, val0);

                                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                                }
                                cell_end_point = *(cl.user_data.interface.end() -1) ;
                            }

                        }

                    }
                    else
                        break;

                }


            }
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_cell);
            postoutput_div2.add_object(test_global_curvature);

            postoutput_div2.write();

            l1_divergence_error /= counter_interface_pts;
           
            std::cout<<"Implemented number of interface points is " << counter_interface_pts << std::endl;
            std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at t = 0 is " << l1_divergence_error <<std::endl;
           
            std::cout<<"The l^inf error of the CURVATURE at the INTERFACE, at t = 0 is " << linf_divergence_error <<std::endl;
            std::cout<<"The L1 error of the CURVATURE at the INTERFACE, at t = 0 is " << L1_divergence_error <<std::endl;





            // compute solution/errors
            stokes_test_info<T> TI;

            if(1)
            {
                // auto test_case = make_test_case_stokes_1(msh, level_set_function);
                //auto test_case = make_test_case_stokes_2(msh, level_set_function);
                auto prm = params<T>();
                prm.kappa_1 = 1.0;
                prm.kappa_2 = 1.0;
                //auto test_case = make_test_case_static_bubble(msh, radius, 0.5, 0.5, 0.05);
                //auto test_case = make_test_case_static_bubble_numerical_ls(msh, ls_cell,prm) ;
                T gamma = 1.0 ; //  1.0 ; // 0.05
                std::cout<<"test case: Eshelby, with gamma = "<<gamma<<std::endl;
                auto test_case = make_test_case_eshelby_correct(msh, ls_cell, prm, true,gamma);
                //test_case.test_case_gamma_setting( gamma );
                //TI = run_cuthho_fictdom(msh, k, test_case);
                //auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);
                auto method = make_sym_gradrec_stokes_interface_method(msh, 1.0, 0.0, test_case, true);
                bool normal_analysis =  true ;
                //TI = run_cuthho_interface(msh, k, method, test_case , normal_analysis );
                TI = run_cuthho_interface_numerical_ls(msh, k, method, test_case , ls_cell ,  normal_analysis );
            }

            // report info in the file
            T h = 1.0/N;


            if (it_msh == mesh_sizes.begin())
            {
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << "."
                       << "\t" << TI.L2_vel << "\t" << "." << "\t" << TI.L2_p
                       << "\t" << "." << "\t" << TI.cond  << "\t" << TI.l1_normal_vel
                       << "\t" << "." << "\t" << TI.flux_interface << "\t" << "."
                       << "\t" << TI.linf_normal_vel << "\t" << "." << std::endl;
            }
            else
            {
                T orderH = log(previous_H1 / TI.H1_vel) / log(previous_h / h);
                T orderL = log(previous_L2 / TI.L2_vel) / log(previous_h / h);
                T orderp = log(previous_p / TI.L2_p) / log(previous_h / h);
                T orderl1_un = log(previous_l1_un / TI.l1_normal_vel) / log(previous_h / h);
                T orderl2_un = log(previous_l2_un / TI.flux_interface) / log(previous_h / h);
                T orderlinf_un = log(previous_linf_un / TI.linf_normal_vel) / log(previous_h / h);

                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << orderH
                       << "\t" << TI.L2_vel << "\t" << orderL << "\t" << TI.L2_p
                       << "\t" << orderp << "\t" << TI.cond << "\t" << TI.l1_normal_vel
                       << "\t" << orderl1_un   << "\t" << TI.flux_interface
                       << "\t" << orderl2_un << "\t" << TI.linf_normal_vel << "\t" << orderlinf_un
                       << std::endl;
            }
            previous_H1 = TI.H1_vel;
            previous_L2 = TI.L2_vel;
            previous_p = TI.L2_p;
            previous_h = h;
            previous_l1_un = TI.l1_normal_vel ;
            previous_l2_un = TI.flux_interface ;
            previous_linf_un = TI.linf_normal_vel ;
        }
        // close the file
        output.close();
    }

    // update the gnuplot curves
    //system("gnuplot './output/gnuplot_script_stokes.txt'");

    // update the .pdf file
    //system("pdflatex ./output/autom_tests_stokes.tex");

    // open the .pdf file
    //system("xdg-open ./autom_tests_stokes.pdf");
}

void convergence_test_normal_error_case2(void)
{
    using T = double;

    std::vector<size_t> mesh_sizes, pol_orders;

    size_t degree_FEM = 3 ;
    size_t int_refsteps = 4;
    size_t  degree_gradient = degree_FEM  ;
    size_t  degree_div = degree_FEM ;

    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;

    // meshes
    mesh_sizes.push_back(8);
    mesh_sizes.push_back(16);
    mesh_sizes.push_back(32);
    //mesh_sizes.push_back(64);
    // mesh_sizes.push_back(128);
    // mesh_sizes.push_back(256);

    // polynomial orders
    pol_orders.push_back(0);
    pol_orders.push_back(1);
    pol_orders.push_back(2);
    //pol_orders.push_back(3);


    // export to files ...
    std::vector<std::string> files;
    files.push_back("./output/test_k0.txt");
    files.push_back("./output/test_k1.txt");
    files.push_back("./output/test_k2.txt");
    files.push_back("./output/test_k3.txt");

    for (std::vector<size_t>::iterator it = pol_orders.begin(); it != pol_orders.end(); it++)
    {
        size_t k = *it;

        std::cout << "start tests for k = " << k << std::endl;

        // init the file
        std::ofstream output;
        output.open (files.at(*it), std::ios::in | std::ios::trunc);
        if (!output.is_open())
            throw std::logic_error("file not open");

        // output << "N\th\tH1\tordre1\tL2\tordre2" << std::endl;
        output << "N\th\tH1\tordre1\tL2\tordre2\tLp\tordre3\tcond\tl1_u_n\tordre4\tlinf_u_n\tordre5\tl1_curv\tlinf_curv\tl1_u_nFEM\tordre6\tlinf_u_nFEM\tordre7" << std::endl;

        // convergence tests
        T previous_H1 = 0.0;
        T previous_L2 = 0.0;
        T previous_p = 0.0;
        T previous_h = 0.0;
        T previous_l1_un = 0.0 ;
        T previous_linf_un = 0.0 ;
        T previous_l1_unFEM = 0.0 ;
        T previous_linf_unFEM = 0.0 ;

        for (std::vector<size_t>::iterator it_msh = mesh_sizes.begin();
             it_msh != mesh_sizes.end(); it_msh++)
        {
            size_t N = *it_msh;

            // init mesh (with agglomeration)
            mesh_init_params<T> mip;
            mip.Nx = N;
            mip.Ny = N;
            cuthho_poly_mesh<T> msh(mip);
            typedef cuthho_poly_mesh<T> Mesh;
            offset_definition(msh);     // For Original Mesh
            offset_definition(msh);     // For Agglomerated Mesh

            std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

            /************** FINITE ELEMENT INITIALIZATION **************/

            auto fe_data = Finite_Element<T,Mesh>( msh , degree_FEM , mip ) ;
            typedef Finite_Element<T,Mesh> FiniteSpace;
            std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

            /**************  VELOCITY FIELD  INITIALISATION  **************/


            auto fe_data_Lagrange = Finite_Element<T,Mesh>( msh , degree_velocity , mip ) ;

            std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
            auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );

            /************** ANALYTIC LEVEL SET FUNCTION  **************/
            T radius = 1.0/3.0;
            T x_centre = 0.5 ;
            T y_centre = 0.5 ;
            auto level_set_function_anal = circle_level_set<T>(radius, x_centre, y_centre);
            typedef  circle_level_set<T> Fonction;
            // auto level_set_function = flower_level_set<T>(0.31, 0.5, 0.5, 4, 0.04);
            //auto level_set_function = circle_level_set<T>(radius, 0.5, 0.5);
            // auto level_set_function = square_level_set<T>(1.05, -0.05, -0.05, 1.05);
            // auto level_set_function = square_level_set<T>(1.0, -0.0, -0.0, 1.0);
            //auto level_set_function = square_level_set<T>(0.76, 0.24, 0.24, 0.76);

            /**************************************TRANSPORT PROBLEM METHOD *****************************************/
            auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
            //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;


            auto fe_data_gradient = Finite_Element<T,Mesh>( msh , degree_gradient , mip ) ;
            auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;


            std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
            auto fe_data_div = Finite_Element<T,Mesh>( msh , degree_div , mip ) ;
            auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


            /************** LEVEL SET FUNCTION DISCRETISATION **************/
           auto level_set_function = Level_set_berstein_curvature2< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );


            // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;
            //level_set_function.divergence_continuous_setting_avg() ;

            //testing_level_set(msh, level_set_function, level_set_function_anal);

            detect_node_position3(msh, level_set_function);
            detect_cut_faces3(msh, level_set_function);
            if(1)  // AGGLOMERATION
            {
                detect_cut_cells3(msh, level_set_function);
                detect_cell_agglo_set(msh, level_set_function);
                make_neighbors_info_cartesian(msh);
                refine_interface_pro3(msh, level_set_function, int_refsteps);
                std::cout<<"WARNING: in agglomerated cells the integrations points are saved at priori (for a high degree). COMPUTATIONALLY USELESS."<<std::endl;
                make_agglomeration(msh, level_set_function);
            }
            else  // NODE DISPLACEMENT
            {
                move_nodes(msh, level_set_function);
                detect_cut_faces3(msh, level_set_function); //do it again to update intersection points
                detect_cut_cells3(msh, level_set_function);
                refine_interface_pro3(msh, level_set_function, int_refsteps);
            }

            u_projected.set_agglo_mesh( msh );

            /************** UPDATING  LEVEL SET   **************/
             // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div) ;
            //level_set_function.divergence_continuous_setting_avg() ;

            typedef Level_set_berstein_curvature2< Mesh , Fonction , FiniteSpace , T > Level_Set;

            //auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh );

            // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\

            // IF grad disc -> normal disc -> divergence cont -> grad cont -> norm cont (from the disc)
            auto ls_cell = LS_cell_high_order_grad_cont_div_cont2< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);
            // IF grad disc -> normal disc -> divergence cont
            //auto ls_cell = LS_cell_high_order_grad_disc_div_cont2< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);

            ls_cell.radius = radius ;




            // CHECK DIVERGENCE ERROR OVER THE INTERFACE
            postprocess_output<double> postoutput_div2;
            std::string filename_curvature_k0 = "k_curvature_interface.dat";
            auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
            std::string filename_curvature_k1 = "global_curvature.dat";
            auto test_global_curvature = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k1);

            std::string filename_curv_var = "cell_limit_curv_var_interface.dat";
            auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);


            T l1_divergence_error = 0. , l2_divergence_error = 0. ;
            T divergence_error_max = -10.0 ;
            size_t counter_interface_pts = 0;

            for(auto& cl : msh.cells)
            {


                ls_cell.cell_assignment(cl);
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {


                        T val0 = ls_cell.divergence( *interface_point );
                        T curvature_err = std::abs( std::abs(val0) - 1.0/radius );
                        //std::cout<<"interface_point = "<<*interface_point<<" , curvature = "<<val0<<" , 1/R = "<<-1.0/radius<<" , diff = "<< curvature_err <<std::endl;
                        l1_divergence_error += curvature_err ;
                        l2_divergence_error += pow( curvature_err, 2.0 ) ;
                        divergence_error_max = std::max(divergence_error_max , curvature_err );
                        counter_interface_pts++;

                    }
                }
                auto pts = points(msh,cl) ;
                for(auto& pt : pts){
                    T k = ls_cell.divergence( pt ) ;
                    test_global_curvature->add_data( pt , k );
                }
            }

            bool first_cut_cell_found = FALSE ;
            T distance_pts = 0.0;
            point<T,2> first_point ;
            point<T,2> cell_end_point;
            typedef typename Mesh::point_type point_type;
            for(auto& cl : msh.cells)
            {

                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    if(!first_cut_cell_found)
                    {
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                        {
                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        first_cut_cell_found = TRUE;
                        first_point = *cl.user_data.interface.begin() ;
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }
                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                    {
                        for(auto& cl : msh.cells)
                        {
                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                            {
                                ls_cell.cell_assignment(cl);
                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                                {

                                    T val0 = ls_cell.divergence( *interface_point );

                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                                    if( interface_point == cl.user_data.interface.begin() )
                                        test_curv_var_cell->add_data(curv_var, val0);

                                    test_curv_var_divergence0->add_data(curv_var, val0);

                                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                                }
                                cell_end_point = *(cl.user_data.interface.end() -1) ;
                            }

                        }

                    }
                    else
                        break;

                }


            }
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_cell);
            postoutput_div2.add_object(test_global_curvature);

            postoutput_div2.write();

            l1_divergence_error /= counter_interface_pts;
            l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
            std::cout<<"Implemented number of interface points is " << counter_interface_pts << std::endl;
            std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at t = 0 is " << l1_divergence_error <<std::endl;
            std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at t = 0 is " << l2_divergence_error <<std::endl;
            std::cout<<"The l^inf error of the CURVATURE at the INTERFACE, at t = 0 is " << divergence_error_max <<std::endl;





            // compute solution/errors
            stokes_test_info<T> TI;

            if(1)
            {
                // auto test_case = make_test_case_stokes_1(msh, level_set_function);
                //auto test_case = make_test_case_stokes_2(msh, level_set_function);
                auto prm = params<T>();
                prm.kappa_1 = 1.0;
                prm.kappa_2 = 1.0;
                //auto test_case = make_test_case_static_bubble(msh, radius, 0.5, 0.5, 0.05);
                //auto test_case = make_test_case_static_bubble_numerical_ls(msh, ls_cell,prm) ;
                T gamma = 1.0 ; // 0.05
                std::cout<<"test case: Eshelby, with gamma = "<<gamma<<std::endl;
                auto test_case = make_test_case_eshelby_correct(msh, ls_cell, prm, true,gamma);
                //test_case.test_case_gamma_setting( gamma );
                //TI = run_cuthho_fictdom(msh, k, test_case);
                //auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);
                auto method = make_sym_gradrec_stokes_interface_method(msh, 1.0, 0.0, test_case, true);
                bool normal_analysis =  true ;
                //TI = run_cuthho_interface(msh, k, method, test_case , normal_analysis );
                //TI = run_cuthho_interface_numerical_ls(msh, k, method, test_case , ls_cell ,  normal_analysis );
                TI = run_cuthho_interface_numerical_ls_velocity(msh, k, method, test_case , ls_cell  , u_projected ,normal_analysis );
                u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );


            }
            //T max_u_n_val = 0.0 ;
            T max_u_n_val_abs = 0.0 ;
            T l1_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        //if( std::abs(u_n_val) == max_u_n_val_abs )
                         //   max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        counter_interface_pts ++ ;

                    }
                }
            }
            l1_normal_interface_status /= counter_interface_pts;




            // report info in the file
            T h = 1.0/N;


            if (it_msh == mesh_sizes.begin())
            {
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << "."
                       << "\t" << TI.L2_vel << "\t" << "." << "\t" << TI.L2_p
                       << "\t" << "." << "\t" << TI.cond  << "\t" << TI.l1_normal_vel
                       << "\t" << "." << "\t" << TI.linf_normal_vel << "\t" << "." << "\t" << l1_divergence_error << "\t" << divergence_error_max << "\t" << l1_normal_interface_status << "\t" << "." << "\t" << max_u_n_val_abs << std::endl;
            }
            else
            {
                T orderH = log(previous_H1 / TI.H1_vel) / log(previous_h / h);
                T orderL = log(previous_L2 / TI.L2_vel) / log(previous_h / h);
                T orderp = log(previous_p / TI.L2_p) / log(previous_h / h);
                T orderl1_un = log(previous_l1_un / TI.l1_normal_vel) / log(previous_h / h);
                //T orderl2_un = log(previous_l2_un / TI.l2_normal_vel) / log(previous_h / h);
                T orderlinf_un = log(previous_linf_un / TI.linf_normal_vel) / log(previous_h / h);

                T orderl1_unFEM = log(previous_l1_unFEM / l1_normal_interface_status) / log(previous_h / h);
                T orderlinf_unFEM = log(previous_linf_unFEM / max_u_n_val_abs) / log(previous_h / h);

                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << orderH
                       << "\t" << TI.L2_vel << "\t" << orderL << "\t" << TI.L2_p
                       << "\t" << orderp << "\t" << TI.cond << "\t" << TI.l1_normal_vel
                       << "\t" << orderl1_un   << "\t"  << TI.linf_normal_vel << "\t" << orderlinf_un << "\t" << l1_divergence_error << "\t" << divergence_error_max << "\t" << l1_normal_interface_status
                       << "\t" << orderl1_unFEM   << "\t"  << max_u_n_val_abs << "\t" << orderlinf_unFEM << std::endl;
            }
            previous_H1 = TI.H1_vel;
            previous_L2 = TI.L2_vel;
            previous_p = TI.L2_p;
            previous_h = h;
            previous_l1_un = TI.l1_normal_vel ;
            previous_linf_un = TI.linf_normal_vel ;
            previous_l1_unFEM = l1_normal_interface_status ;
            previous_linf_unFEM = max_u_n_val_abs ;
        }
        // close the file
        output.close();
    }

    // update the gnuplot curves
    //system("gnuplot './output/gnuplot_script_stokes.txt'");

    // update the .pdf file
    //system("pdflatex ./output/autom_tests_stokes.tex");

    // open the .pdf file
    //system("xdg-open ./autom_tests_stokes.pdf");
}

// Analysis made by Stefano to check optimal u*n error. Numerical level set implementation.
// CURVATURE DEFINE AS CASE 1 (fixed point iteration)
void convergence_test_normal_error_case1(void)
{
    using T = double;

    std::vector<size_t> mesh_sizes, pol_orders;

    size_t degree_FEM = 2 ;
    size_t int_refsteps = 4;
    size_t  degree_gradient = degree_FEM  ;
    size_t  degree_div = degree_FEM ;

    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;

    // meshes
    //mesh_sizes.push_back(8);
    mesh_sizes.push_back(16);
    //mesh_sizes.push_back(32);
    //mesh_sizes.push_back(64);
    // mesh_sizes.push_back(128);
    // mesh_sizes.push_back(256);

    // polynomial orders
    //pol_orders.push_back(0);
    pol_orders.push_back(1);
    //pol_orders.push_back(2);
    //pol_orders.push_back(3);


    // export to files ...
    std::vector<std::string> files;
    files.push_back("./output/test_k0.txt");
    files.push_back("./output/test_k1.txt");
    files.push_back("./output/test_k2.txt");
    files.push_back("./output/test_k3.txt");

    for (std::vector<size_t>::iterator it = pol_orders.begin(); it != pol_orders.end(); it++)
    {
        size_t k = *it;

        std::cout << "start tests for k = " << k << std::endl;

        // init the file
        std::ofstream output;
        output.open (files.at(*it), std::ios::in | std::ios::trunc);
        if (!output.is_open())
            throw std::logic_error("file not open");

        // output << "N\th\tH1\tordre1\tL2\tordre2" << std::endl;
        output << "N\th\tH1\tordre1\tL2\tordre2\tLp\tordre3\tcond\tl1_u_n\tordre4\tlinf_u_n\tordre5\tl1_curv\tlinf_curv\tl1_u_nFEM\tordre6\tlinf_u_nFEM\tordre7" << std::endl;

        // convergence tests
        T previous_H1 = 0.0;
        T previous_L2 = 0.0;
        T previous_p = 0.0;
        T previous_h = 0.0;
        T previous_l1_un = 0.0 ;
        T previous_linf_un = 0.0 ;
        T previous_l1_unFEM = 0.0 ;
        T previous_linf_unFEM = 0.0 ;

        for (std::vector<size_t>::iterator it_msh = mesh_sizes.begin();
             it_msh != mesh_sizes.end(); it_msh++)
        {
            size_t N = *it_msh;

            // init mesh (with agglomeration)
            mesh_init_params<T> mip;
            mip.Nx = N;
            mip.Ny = N;
            cuthho_poly_mesh<T> msh(mip);
            typedef cuthho_poly_mesh<T> Mesh;
            offset_definition(msh);     // For Original Mesh
            offset_definition(msh);     // For Agglomerated Mesh

            std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

            /************** FINITE ELEMENT INITIALIZATION **************/

            auto fe_data = Finite_Element<T,Mesh>( msh , degree_FEM , mip ) ;
            typedef Finite_Element<T,Mesh> FiniteSpace;
            std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

            /**************  VELOCITY FIELD  INITIALISATION  **************/


            auto fe_data_Lagrange = Finite_Element<T,Mesh>( msh , degree_velocity , mip ) ;

            std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
            auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );

            /************** ANALYTIC LEVEL SET FUNCTION  **************/
            T radius = 1.0/3.0;
            T x_centre = 0.5 ;
            T y_centre = 0.5 ;
            auto level_set_function_anal = circle_level_set<T>(radius, x_centre, y_centre);
            typedef  circle_level_set<T> Fonction;
            // auto level_set_function = flower_level_set<T>(0.31, 0.5, 0.5, 4, 0.04);
            //auto level_set_function = circle_level_set<T>(radius, 0.5, 0.5);
            // auto level_set_function = square_level_set<T>(1.05, -0.05, -0.05, 1.05);
            // auto level_set_function = square_level_set<T>(1.0, -0.0, -0.0, 1.0);
            //auto level_set_function = square_level_set<T>(0.76, 0.24, 0.24, 0.76);

            /**************************************TRANSPORT PROBLEM METHOD *****************************************/
            auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
            //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;


            auto fe_data_gradient = Finite_Element<T,Mesh>( msh , degree_gradient , mip ) ;
            auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;


            std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
            auto fe_data_div = Finite_Element<T,Mesh>( msh , degree_div , mip ) ;
            auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


            /************** LEVEL SET FUNCTION DISCRETISATION **************/
           auto level_set_function = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );


            // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

            //testing_level_set(msh, level_set_function, level_set_function_anal);

            detect_node_position3(msh, level_set_function);
            detect_cut_faces3(msh, level_set_function);
            if(1)  // AGGLOMERATION
            {
                detect_cut_cells3(msh, level_set_function);
                detect_cell_agglo_set(msh, level_set_function);
                make_neighbors_info_cartesian(msh);
                refine_interface_pro3(msh, level_set_function, int_refsteps);
                std::cout<<"WARNING: in agglomerated cells the integrations points are saved at priori (for a high degree). COMPUTATIONALLY USELESS."<<std::endl;
                make_agglomeration(msh, level_set_function);
            }
            else  // NODE DISPLACEMENT
            {
                move_nodes(msh, level_set_function);
                detect_cut_faces3(msh, level_set_function); //do it again to update intersection points
                detect_cut_cells3(msh, level_set_function);
                refine_interface_pro3(msh, level_set_function, int_refsteps);
            }

            u_projected.set_agglo_mesh( msh );

            /************** UPDATING  LEVEL SET   **************/
             // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

            typedef Level_set_berstein< Mesh , Fonction , FiniteSpace , T > Level_Set;

            //auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh );

            // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\
            // IF grad cont -> normal cont -> (divergence disc) -> divergence cont
            //auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);

            // IF grad cont -> normal cont -> divergence disc
            auto ls_cell = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);

            // IF grad disc -> normal disc -> divergence disc
            //auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh);

            ls_cell.radius = radius ;




            // CHECK DIVERGENCE ERROR OVER THE INTERFACE
            postprocess_output<double> postoutput_div2;
            std::string filename_curvature_k0 = "k_curvature_interface.dat";
            auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
            std::string filename_curvature_k1 = "global_curvature.dat";
            auto test_global_curvature = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k1);

            std::string filename_curv_var = "cell_limit_curv_var_interface.dat";
            auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);


            T l1_divergence_error = 0. , l2_divergence_error = 0. ;
            T divergence_error_max = -10.0 ;
            size_t counter_interface_pts = 0;

            for(auto& cl : msh.cells)
            {


                ls_cell.cell_assignment(cl);
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {


                        T val0 = ls_cell.divergence( *interface_point );
                        T curvature_err = std::abs( std::abs(val0) - 1.0/radius );
                        //std::cout<<"interface_point = "<<*interface_point<<" , curvature = "<<val0<<" , 1/R = "<<-1.0/radius<<" , diff = "<< curvature_err <<std::endl;
                        l1_divergence_error += curvature_err ;
                        l2_divergence_error += pow( curvature_err, 2.0 ) ;
                        divergence_error_max = std::max(divergence_error_max , curvature_err );
                        counter_interface_pts++;

                    }
                }
                auto pts = points(msh,cl) ;
                for(auto& pt : pts){
                    T k = ls_cell.divergence( pt ) ;
                    test_global_curvature->add_data( pt , k );
                }
            }

            bool first_cut_cell_found = FALSE ;
            T distance_pts = 0.0;
            point<T,2> first_point ;
            point<T,2> cell_end_point;
            typedef typename Mesh::point_type point_type;
            for(auto& cl : msh.cells)
            {

                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    if(!first_cut_cell_found)
                    {
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                        {
                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        first_cut_cell_found = TRUE;
                        first_point = *cl.user_data.interface.begin() ;
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }
                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                    {
                        for(auto& cl : msh.cells)
                        {
                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                            {
                                ls_cell.cell_assignment(cl);
                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                                {

                                    T val0 = ls_cell.divergence( *interface_point );

                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                                    if( interface_point == cl.user_data.interface.begin() )
                                        test_curv_var_cell->add_data(curv_var, val0);

                                    test_curv_var_divergence0->add_data(curv_var, val0);

                                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                                }
                                cell_end_point = *(cl.user_data.interface.end() -1) ;
                            }

                        }

                    }
                    else
                        break;

                }


            }
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_cell);
            postoutput_div2.add_object(test_global_curvature);

            postoutput_div2.write();

            l1_divergence_error /= counter_interface_pts;
            l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
            std::cout<<"Implemented number of interface points is " << counter_interface_pts << std::endl;
            std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at t = 0 is " << l1_divergence_error <<std::endl;
            std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at t = 0 is " << l2_divergence_error <<std::endl;
            std::cout<<"The l^inf error of the CURVATURE at the INTERFACE, at t = 0 is " << divergence_error_max <<std::endl;





            // compute solution/errors
            stokes_test_info<T> TI;

            if(1)
            {
                // auto test_case = make_test_case_stokes_1(msh, level_set_function);
                //auto test_case = make_test_case_stokes_2(msh, level_set_function);
                auto prm = params<T>();
                prm.kappa_1 = 1.0;
                prm.kappa_2 = 1.0;
                //auto test_case = make_test_case_static_bubble(msh, radius, 0.5, 0.5, 0.05);
                //auto test_case = make_test_case_static_bubble_numerical_ls(msh, ls_cell,prm) ;
                T gamma = 1.0 ; // 0.05
                std::cout<<"test case: Eshelby, with gamma = "<<gamma<<std::endl;
                auto test_case = make_test_case_eshelby_correct(msh, ls_cell, prm, true,gamma);
                //test_case.test_case_gamma_setting( gamma );
                //TI = run_cuthho_fictdom(msh, k, test_case);
                //auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);
                auto method = make_sym_gradrec_stokes_interface_method(msh, 1.0, 0.0, test_case, true);
                bool normal_analysis =  true ;
                //TI = run_cuthho_interface(msh, k, method, test_case , normal_analysis );
                //TI = run_cuthho_interface_numerical_ls(msh, k, method, test_case , ls_cell ,  normal_analysis );
                TI = run_cuthho_interface_numerical_ls_velocity(msh, k, method, test_case , ls_cell  , u_projected ,normal_analysis );
                u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );


            }
            T max_u_n_val = 0.0 ;
            T max_u_n_val_abs = 0.0 ;
            T l1_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        //if( std::abs(u_n_val) == max_u_n_val_abs )
                         //   max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        counter_interface_pts ++ ;

                    }
                }
            }
            l1_normal_interface_status /= counter_interface_pts;




            // report info in the file
            T h = 1.0/N;


            if (it_msh == mesh_sizes.begin())
            {
                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << "."
                       << "\t" << TI.L2_vel << "\t" << "." << "\t" << TI.L2_p
                       << "\t" << "." << "\t" << TI.cond  << "\t" << TI.l1_normal_vel
                       << "\t" << "." << "\t" << TI.linf_normal_vel << "\t" << "." << "\t" << l1_divergence_error << "\t" << divergence_error_max << "\t" << l1_normal_interface_status << "\t" << "." << "\t" << max_u_n_val_abs << std::endl;
            }
            else
            {
                T orderH = log(previous_H1 / TI.H1_vel) / log(previous_h / h);
                T orderL = log(previous_L2 / TI.L2_vel) / log(previous_h / h);
                T orderp = log(previous_p / TI.L2_p) / log(previous_h / h);
                T orderl1_un = log(previous_l1_un / TI.l1_normal_vel) / log(previous_h / h);
                //T orderl2_un = log(previous_l2_un / TI.l2_normal_vel) / log(previous_h / h);
                T orderlinf_un = log(previous_linf_un / TI.linf_normal_vel) / log(previous_h / h);

                T orderl1_unFEM = log(previous_l1_unFEM / l1_normal_interface_status) / log(previous_h / h);
                T orderlinf_unFEM = log(previous_linf_unFEM / max_u_n_val_abs) / log(previous_h / h);

                output << N << "\t" << h << "\t" << TI.H1_vel << "\t" << orderH
                       << "\t" << TI.L2_vel << "\t" << orderL << "\t" << TI.L2_p
                       << "\t" << orderp << "\t" << TI.cond << "\t" << TI.l1_normal_vel
                       << "\t" << orderl1_un   << "\t"  << TI.linf_normal_vel << "\t" << orderlinf_un << "\t" << l1_divergence_error << "\t" << divergence_error_max << "\t" << l1_normal_interface_status
                       << "\t" << orderl1_unFEM   << "\t"  << max_u_n_val_abs << "\t" << orderlinf_unFEM << std::endl;
            }
            previous_H1 = TI.H1_vel;
            previous_L2 = TI.L2_vel;
            previous_p = TI.L2_p;
            previous_h = h;
            previous_l1_un = TI.l1_normal_vel ;
            previous_linf_un = TI.linf_normal_vel ;
            previous_l1_unFEM = l1_normal_interface_status ;
            previous_linf_unFEM = max_u_n_val_abs ;
        }
        // close the file
        output.close();
    }

    // update the gnuplot curves
    //system("gnuplot './output/gnuplot_script_stokes.txt'");

    // update the .pdf file
    //system("pdflatex ./output/autom_tests_stokes.tex");

    // open the .pdf file
    //system("xdg-open ./autom_tests_stokes.pdf");
}

//////////////////////////////////////////////////////////////////////////////////////////////////     MAIN      ////////////////////////////////////////////////////////////////////////////////////////////////////


// ---------------------------- GUILLAUME OLD MAIN (ANALYTICAL LS)--------------------------
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;

    /* k <deg>:     method degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:M:N:r:ifDAd")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    timecounter tc;

    /************** BUILD MESH **************/
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;
    /************** LEVEL SET FUNCTION **************/
    RealType radius = 1.0/3.0;
    auto level_set_function = circle_level_set<RealType>(radius, 0.5, 0.5);
    // auto level_set_function = line_level_set<RealType>(0.5);
    // auto level_set_function = flower_level_set<RealType>(0.31, 0.5, 0.5, 4, 0.04);
    /************** DO cutHHO MESH PROCESSING **************/

    tc.tic();
    detect_node_position(msh, level_set_function);
    detect_cut_faces(msh, level_set_function);

    if (agglomeration)
    {
        detect_cut_cells(msh, level_set_function);
        detect_cell_agglo_set(msh, level_set_function);
        make_neighbors_info_cartesian(msh);
        // make_neighbors_info(msh);
        refine_interface(msh, level_set_function, int_refsteps);
        make_agglomeration(msh, level_set_function);
    }
    else
    {
        move_nodes(msh, level_set_function);
        detect_cut_faces(msh, level_set_function); //do it again to update intersection points
        detect_cut_cells(msh, level_set_function);
        refine_interface(msh, level_set_function, int_refsteps);
    }


    tc.toc();
    std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh);
        output_mesh_info(msh, level_set_function);
    }

    output_mesh_info(msh, level_set_function);

    // auto test_case = make_test_case_stokes_1(msh, level_set_function);
    //auto test_case = make_test_case_stokes_2(msh, level_set_function);
    auto test_case = make_test_case_static_bubble(msh, radius , 0.5, 0.5 , 1.0,level_set_function); // DELETED TO CHECK FAST IMPLEMENTATION

    auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);

    if (solve_interface)
        run_cuthho_interface(msh, degree, method, test_case);

    if (solve_fictdom)
        run_cuthho_fictdom(msh, degree, test_case);


    return 0;
}
#endif





// Velocity Field from HHO STOKES -> FIRST ATTEMPS
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);
    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;




    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
     typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    RealType radius_a = 1.0/6.0; // I PUT 1.0/9.0 and 1.0/6.0, IT WAS 1.0/3.0
    RealType radius_b = 1.0/12.0;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);

    //auto level_set_function = circle_level_set<RealType>(radius, x_centre, y_centre );
    //auto level_set_function = flower_level_set<RealType>(0.31, 0.5, 0.5, 4, 0.04);
    // auto level_set_function = line_level_set<RealType>(0.5);

     std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;


    RealType radius = sqrt( radius_a * radius_b ) ;
    // auto level_set_function_anal = flower_level_set<RealType>(0.31, 0.5, 0.5, 4, 0.04);//(0.11, 0.1, 0.1, 4, 0.04);
    //  auto level_set_function_anal=square_level_set<RealType>(0.6,0.4,0.4,0.6);

    typedef RealType T;
    typedef  elliptic_level_set<T> Fonction;
    //typedef  circle_level_set<T> Fonction;
    //typedef  flower_level_set<T> Fonction; //DA RIMETTERE POI PER LA DISCRETA
    //typedef line_level_set<T> Fonction;
    // typedef square_level_set<T> Fonction;

     /**************  VELOCITY FIELD   **************/ // JUST TO CHECK IMPLEMENTATION
    /*
    T u_0 = 1.00 ;
    T u_1 = 0.00 ;
    auto u = linear_velocity_field<RealType>(0,u_0,0,u_1); // analytic velocity (0,0,0,0)
    typedef linear_velocity_field<RealType> Velocity;
    std::cout<<yellow<<bold<<"--> USING LAGRANGIAN HIGH ORDER VELOCITY FIELD"<<reset<<std::endl;
    auto u_projected = projection_velocity_high_order <Mesh,Velocity,FiniteSpace,T> (fe_data , u , msh);
    */


    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;


    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    //level_set_function.smooth_cut_off( C , x_centre , y_centre , radius );
    //level_set_function.cut_off( C );

     T C ;

    if(cut_off_active){
        T r0 = radius_a + (x_centre - radius_a + 2.0/16.0)/2.0;
        C = r0*r0 - radius_a*radius_a ;
        level_set_function.cut_off( C );
        std::cout<<bold<<yellow<<"----> USING CUT_OFF!!!!! "<<reset<<std::endl;
        std::cout<<"C = "<<C<<std::endl;
    }
    else{
        C = 0.2;  // Imposed max value at the boundary
        level_set_function.smooth_cut_off( C , x_centre , y_centre , radius , radius_a, radius_b);
        std::cout<<bold<<yellow<<"----> USING SMOOTH!!!!! "<<reset<<std::endl;
        std::cout<<"C = "<<C<<std::endl;
    }

    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;


    testing_level_set(msh,level_set_function,level_set_function_anal);

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    /// Initialisation area , mass -> I calculate them just the first and last time step.
    T initial_area = 0. , initial_mass = 0.;
    T area_previous_time = 0. , mass_previous_time = 0. , dt = 0. ;

    /// DATA CHECK INITIALISATION
    T d_a = 0. ; // It is related to area-> calculated just first and last time
    T error_normal_global = 0. ;
    T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;


    /// ERROR FEM (transport problem) wrt ANALYTICAL SOLUTION
    //T l1_L1_error = 0 , l2_L1_error = 0 , linf_L1_error = 0;
    //T l1_L2_error = 0 ,  l2_L2_error = 0 , linf_L2_error = 0;
    //T l1_Linf_error = 0 ,  l2_Linf_error = 0 , linf_Linf_error = 0;

    //T l1_W11_error = 0 , l2_W11_error = 0 , linf_W11_error = 0;
    //T l1_W12_error = 0 ,  l2_W12_error = 0 , linf_W12_error = 0;
    //T l1_W1inf_error = 0 ,  l2_W1inf_error = 0 , linf_W1inf_error = 0;


    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);





        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        detect_node_position2(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces2(msh_i, level_set_function); // In cuthho_geom

        if (agglomeration)
        {
            detect_cut_cells2(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro(msh_i, level_set_function, int_refsteps);
            //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            std::cout<<"I m here 0"<<std::endl;
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            std::cout<<"I m here 1"<<std::endl;
        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells2(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            refine_interface_pro(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0)
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
            //output_mesh_info2(msh_i, level_set_function);

        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS

        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0. , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        T error_normal_global0 = 0. ;
        T diff_interface_normal = 0. ;
        size_t counter_interface_pts = 0;
        T divergence_error_inital = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        postprocess_output<double> postoutput_div2;
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_initial.dat");


        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                // NORMAL ERROR ON THE INTERFACE POINTS: diff_interface_normal
                for(auto& interface_point : cl.user_data.interface)
                {
                    counter_interface_pts++;
                    T val = ls_cell.divergence( interface_point );
                    divergence_error_inital += pow((std::abs(val) - 1.0/radius),2) ;
                    std::cout<<"Divergence value in pt = "<<interface_point<<" is "<<val<<std::endl;
                    test_interface_divergence2->add_data(interface_point,val);
                }

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                }



            }

        }

        postoutput_div2.add_object(test_interface_divergence2);
        postoutput_div2.write();

        divergence_error_inital /= counter_interface_pts;
        divergence_error_inital = sqrt(divergence_error_inital);
        std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error_inital <<std::endl;
        std::cout<<"number of interface points is "<<counter_interface_pts<<std::endl;


        std::cout << bold << yellow << "Area at time step: "<<time_step*dt<<" is "<<reset<< area0  << reset << std::endl;
        std::cout << bold << yellow << "Internal mass at time step: "<<time_step*dt<<" is "<<reset<< mass0  << reset << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << bold << yellow << "CENTRE OF MASS at time step: " <<reset <<time_step*dt<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<yellow<<bold<<"The PERIMETER, at time "<<reset<< dt*time_step <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<<reset<< dt*time_step <<" is " << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<time_step*dt<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<time_step*dt<<" is "<<reset<< diff_mass  << reset << std::endl;
            std::cout << bold << yellow << "TRANSLATION OF THE CENTRE OF MASS at time step: " <<reset <<time_step*dt<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;

            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< dt*(time_step) <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }

        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);

        auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);


        auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh );



        if(solve_interface){
            run_cuthho_interface_velocity(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case);




        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION
        std::cout<<yellow<<bold<<"------------------>>>>NOTICE: TO PASS FROM HHO TO FEM IM USING SMOOTH OPERATOR. IMPLEMENT L2 PROJECTION!!!"<<reset<<std::endl;
        u_projected.converting_into_FE_formulation(u_projected.sol_HHO);

        testing_velocity_field(msh , u_projected) ;

        T eps = 1.0 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 1*1e-3;
        dt = std::min(dt1 , dt2);
        std::cout<<"I USE dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;

        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);

        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position2(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces2(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells2(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro(msh_i2, level_set_function, int_refsteps);
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells2(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2(msh_i2, level_set_function); // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;

            /// DATA CHECK INITIALISATION
            postprocess_output<double> postoutput_div;
            auto test_interface_divergence  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_u_const.dat");

            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;
            counter_interface_pts = 0;
            T perimeter = 0. ;
            T divergence_error_fin = 0. ;


            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    for(auto& interface_point : cl.user_data.interface)
                    {
                        counter_interface_pts++;
                        T val = ls_cell.divergence( interface_point );
                        std::cout<<"Divergence value in pt = "<<interface_point<<" is "<<val<<std::endl;

                        divergence_error_fin += pow((std::abs(val) - 1.0/radius),2);

                        test_interface_divergence->add_data(interface_point,val);

                    }



                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                    }
                }

            }

            postoutput_div.add_object(test_interface_divergence);
            postoutput_div.write();

            divergence_error_fin /= counter_interface_pts;
            divergence_error_fin = sqrt(divergence_error_fin);
            std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error_fin <<std::endl;

            std::cout<<"number of interface points is "<<counter_interface_pts<<std::endl;

            std::cout<< bold << yellow<<"The PERIMETER, at time "<<reset<< dt*(time_step+1) <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< dt*(time_step+1) <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

             std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< dt*(time_step+1)<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout << bold << yellow << "Area at time step: " <<(time_step+1)*dt<<" is "<< reset<< area_fin << std::endl;
            std::cout << bold << yellow << "Internal mass at time step: "<<(time_step+1)*dt<<" is "<<reset<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<(T_N+1)*(dt)<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<(T_N+1)*(dt)<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << bold << yellow << "CENTRE OF MASS at time step: "<<(T_N+1)*dt<<" is "<<reset<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << bold << yellow << "TRANSLATION OF THE CENTRE OF MASS at time step: " <<reset <<(T_N+1)*dt<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;

            /// ERROR CHECK WITH ANALYTICAL SOLUTION
            /*
            T x_deviation = u_0*(time_step+1)*dt;
            T y_deviation = u_1*(time_step+1)*dt;
            auto analytic_level_set_post_FE = circle_level_set<RealType>(radius, x_centre + x_deviation, y_centre + y_deviation );
            auto level_set_final = Level_set_berstein_high_order_interpolation < Mesh , Fonction , FiniteSpace , T > (fe_data , analytic_level_set_post_FE , msh);
            level_set_final.cut_off( C );
            testing_level_set2(msh,level_set_function,level_set_final);
            T L1_err_par = Lp_space_error_FEM( level_set_final , level_set_function,msh,degree_FEM,1.0);

            T L2_err_par = Lp_space_error_FEM( level_set_final , level_set_function,msh,degree_FEM,2.0);

            T Linf_err_par = Linf_error_FEM( level_set_final , level_set_function , msh,degree_FEM);

            std::cout << bold << yellow << "L1-space error at time "<<(time_step+1)*(dt)<<" IS "<< reset<< L1_err_par << std::endl;
            std::cout << bold << yellow << "L2-space error at time "<<(time_step+1)*(dt)<<" IS "<< reset<< L2_err_par << std::endl;
            std::cout << bold << yellow << "Linf-space error at time "<<(time_step+1)*(dt)<<" IS "<< reset<< Linf_err_par << std::endl;

            */


        } // END OF T = FINAL TIME


    } // End of the temporal loop


    return 0;
}
#endif


// Interface Stokes Problem: DIRICHLET BDRY ON ALL THE BOUNDARY
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);
    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;

    /*
#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells_size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
             }
    );
#else
    std::cout<<" I m in sequential zone"<<std::endl;
    for (size_t cell_ind = 0; cell_ind < msh.cells.size(); cell_ind++)
    {
        auto& cell = msh.cells[cell_ind];
    }
#endif
    */

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle_new = false , circle_old = false , ellipse_new = false , ellipse_old = true ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    RealType C ;
    if(circle_old)
    {
        radius = 1.0/9.0;
    }

    if(circle_new)
    {
        radius = 1.0/9.0;
    }
    if(ellipse_old)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }
    if(ellipse_new)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }


    /// THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);

    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );

    //auto level_set_function_anal = elliptic_level_set_new<RealType>( radius_a, radius_b, x_centre, y_centre , 1.0/16.0 );

    T h = std::max( fe_data.hx , fe_data.hy) ;
    //auto level_set_function_anal = circle_level_set_new<RealType>(radius, x_centre, y_centre , 4.0*h );



    typedef  elliptic_level_set<T> Fonction;
    //typedef  circle_level_set<T> Fonction;
    //typedef  circle_level_set_new <T> Fonction;
    //typedef  elliptic_level_set_new <T> Fonction;



    /**************  VELOCITY FIELD   **************/ // JUST TO CHECK IMPLEMENTATION

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh );

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;


    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    //level_set_function.smooth_cut_off( C , x_centre , y_centre , radius );
    //level_set_function.cut_off( C );


    //testing_level_set(msh,level_set_function,level_set_function_anal);

    T r0 , rad_max ;

    if( circle_old || ellipse_old )
    {

        if( circle_old ) // FOR CIRCLE
        {
            r0 = radius + (x_centre - radius + 2.0/16.0)/2.0;
            //r0 = radius + h*sqrt(2.0);
            C = r0*r0 - radius*radius ;
        }
        if( ellipse_old )  // FOR ELLIPSE
        {
            rad_max = std::max(radius_a,radius_b) ;
            T r0 = rad_max + (x_centre - rad_max + 2.0/16.0)/2.0;
            //r0 = rad_max + h*sqrt(2.0);
            C = r0*r0*radius_b*radius_b - radius_a*radius_a*radius_b*radius_b;
        }

        T C_bis = std::abs(level_set_function.phi_min) ;
        if( C_bis > C)
            C = C_bis;

        if(cut_off_active)
        {
            level_set_function.cut_off( C );
            std::cout<<bold<<yellow<<"----> USING CUT_OFF!!!!! "<<reset<<std::endl;
            std::cout<<"C = "<<C<<std::endl;
        }
        else
        {
            //C = 0.2;  // Imposed max value at the boundary
            T delta = r0/8.0;
            std::cout<<"r_max = "<<rad_max<<" , r0 = "<<r0<<" , delta = "<<delta<<" , max (hx,hy) = "<< h <<std::endl;
            if( circle_old ) // FOR CIRCLE
            {
                std::cout<<"Value in alfa in position radius R  = "<<( radius - r0)/delta << " -> its approximation error = "<< 1.0 - (1.0 - tanh((radius - r0 )/delta) )/2.0<<std::endl;
                T pos_bdry = std::min(x_centre , y_centre) ;
                std::cout<<"value in alfa in the boundary = "<<(pos_bdry - r0)/delta<< " -> its approximation error = "<< (1.0 - tanh((pos_bdry - r0 )/delta) )/2.0<<std::endl;

            }
            if( ellipse_old ) // FOR CIRCLE
            {
                std::cout<<"Value in alfa in position radius r_a  = "<<( radius_a - r0)/delta << " -> its approximation error = "<< 1.0 - (1.0 - tanh((radius_a - r0 )/delta) )/2.0<<std::endl;
                std::cout<<"Value in alfa in position radius r_b  = "<<( radius_b - r0)/delta << " -> its approximation error = "<< 1.0 - (1.0 - tanh((radius_b - r0 )/delta) )/2.0<<std::endl;
                T pos_bdry = std::min(x_centre , y_centre) ;
                std::cout<<"value in alfa in the boundary = "<<(pos_bdry - r0)/delta<< " -> its approximation error = "<< (1.0 - tanh((pos_bdry - r0 )/delta) )/2.0<<std::endl;

            }

            level_set_function.smooth_cut_off( C , r0 , delta, x_centre , y_centre , radius ,radius_a ,radius_b );
            std::cout<<bold<<yellow<<"----> USING SMOOTH!!!!! "<<reset<<std::endl;
            std::cout<<"C = "<<C<<std::endl;
        }

    }


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;


    testing_level_set(msh,level_set_function,level_set_function_anal);

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    /// Initialisation area , mass -> I calculate them just the first and last time step.
    T initial_area = 0. , initial_mass = 0.;
    T area_previous_time = 0. , mass_previous_time = 0. , dt = 0. ;

    /// DATA CHECK INITIALISATION
    T d_a = 0. ; // It is related to area-> calculated just first and last time
    T error_normal_global = 0. ;
    T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;


    /// ERROR FEM (transport problem) wrt ANALYTICAL SOLUTION
    //T l1_L1_error = 0 , l2_L1_error = 0 , linf_L1_error = 0;
    //T l1_L2_error = 0 ,  l2_L2_error = 0 , linf_L2_error = 0;
    //T l1_Linf_error = 0 ,  l2_Linf_error = 0 , linf_Linf_error = 0;

    //T l1_W11_error = 0 , l2_W11_error = 0 , linf_W11_error = 0;
    //T l1_W12_error = 0 ,  l2_W12_error = 0 , linf_W12_error = 0;
    //T l1_W1inf_error = 0 ,  l2_W1inf_error = 0 , linf_W1inf_error = 0;
    //size_t time_step = 0;
    T check = 10.0;
    T time_pos = 0.;

    T tot_time = 0.;
    //while(check > 0.0112265)
    //{
    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);


        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        detect_node_position2(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces2(msh_i, level_set_function); // In cuthho_geom

        if (agglomeration)
        {
            detect_cut_cells2(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro(msh_i, level_set_function, int_refsteps);
            //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells2(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
            //output_mesh_info2(msh_i, level_set_function);

        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);


        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS

        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0. , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;
        T divergence_error = 0.;
        // PLOTTING OF NORMAL


        postprocess_output<double> postoutput_vec;
        auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

        postprocess_output<double> postoutput_div2;
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_initial.dat");


        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val = ls_cell.divergence( *interface_point );
                    divergence_error += pow((std::abs(val) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));

                    interface_normals.push_back( normal_vec ) ;

                    if( time_step == 0 )
                    {
                        vec_normal->add_data(*interface_point,normal_vec);
                        test_interface_divergence2->add_data(*interface_point , val);
                    }

                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));

                interface_normals.push_back( normal_vec ) ;

                if( time_step == 0 )
                {

                    vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val );
                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }

        }

        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal);
            postoutput_vec.write();

        }

        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 2 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 4 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 6 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 8 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }



        divergence_error /= counter_interface_pts;
        divergence_error = sqrt(divergence_error);
        std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }

        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        if(check < 1e-15 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }

        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);

        auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);


        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);


        if(solve_interface){
            run_cuthho_interface_velocity(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case);




        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION
        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }

        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;
        /*
        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        */

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = std::min(1e-3 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order)
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;
        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position2(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces2(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells2(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells2(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;
            T divergence_error_fin = 0.;

            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_final.dat");

            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ;

            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val = ls_cell.divergence( *interface_point );
                        divergence_error_fin += pow((std::abs(val) - 1.0/radius),2) ;
                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));

                        interface_normals_fin.push_back( normal_vec ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        test_interface_divergence_fin->add_data( *interface_point , val);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );


                        counter_interface_pts++;
                    }

                    T val = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin += pow((std::abs(val) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));

                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));

                    interface_normals_fin.push_back( normal_vec ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence_fin->add_data( *(cl.user_data.interface.end()-1) ,val );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    counter_interface_pts++;

                }

            }

            postoutput_div2.add_object(test_interface_divergence_fin);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.write();

            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }

            divergence_error_fin /= counter_interface_pts;
            divergence_error_fin = sqrt(divergence_error_fin);
            std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;




        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif





// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);
    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;

    /*
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
             }
    );
    */
    /*
#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells_size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
             }
    );
#else
    std::cout<<" I m in sequential zone"<<std::endl;
    for (size_t cell_ind = 0; cell_ind < msh.cells.size(); cell_ind++)
    {
        auto& cell = msh.cells[cell_ind];
    }
#endif
    */

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = false , ellipse = true ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    RealType C ;

    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }



    /// THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    typedef  elliptic_level_set<T> Fonction;

    T h = std::max( fe_data.hx , fe_data.hy) ;



    /**************  VELOCITY FIELD  INITIALISATION  **************/

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;


    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    //level_set_function.coefficients_mapping_quadratic( );




    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;


    testing_level_set(msh,level_set_function);

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T area_previous_time = 0. , mass_previous_time = 0. , dt = 0. ;

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    T error_normal_global = 0. ;
    T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;

    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    //while(check > 0.0112265)
    //{
    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {



        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);


        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        detect_node_position2(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces2(msh_i, level_set_function); // In cuthho_geom

        if (agglomeration)
        {
            detect_cut_cells2(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro(msh_i, level_set_function, int_refsteps);
            //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells2(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2(msh_i, level_set_function);
            //output_mesh_info2(msh_i, level_set_function);

        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);


        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0. , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;
        T divergence_error = 0.;
        // PLOTTING OF NORMAL


        postprocess_output<double> postoutput_vec;
        auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

        postprocess_output<double> postoutput_div2;
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_initial.dat");


        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val = ls_cell.divergence( *interface_point );
                    divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals.push_back( normal_vec ) ;

                    if( time_step == 0 )
                    {

                        vec_normal->add_data(*interface_point,normal_vec);
                        test_interface_divergence2->add_data(*interface_point , val);
                    }

                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                interface_normals.push_back( normal_vec ) ;

                if( time_step == 0 )
                {

                    vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val );
                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }

        }

        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal);
            postoutput_vec.write();

        }
        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;

        testing_level_set_time(msh,level_set_function,tot_time);
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error /= counter_interface_pts;
        divergence_error = sqrt(divergence_error);
        std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }

        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        if(check < 1e-5 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }

        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);

        auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);


        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);


        if(solve_interface){
            run_cuthho_interface_velocity(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case);




        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION
        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }

        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );

        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;
        /*
        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        */

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = std::min(4e-4 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

         testing_level_set2(msh,level_set_function);
        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position2(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces2(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells2(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells2(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;
            T divergence_error_fin = 0.;

            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_final.dat");

            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ;

            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val = ls_cell.divergence( *interface_point );
                        divergence_error_fin += pow((std::abs(val) - 1.0/radius),2) ;
                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        interface_normals_fin.push_back( normal_vec ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        test_interface_divergence_fin->add_data( *interface_point , val);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );


                        counter_interface_pts++;
                    }

                    T val = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin += pow((std::abs(val) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));

                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals_fin.push_back( normal_vec ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence_fin->add_data( *(cl.user_data.interface.end()-1) ,val );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    counter_interface_pts++;

                }

            }

            postoutput_div2.add_object(test_interface_divergence_fin);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.write();
            goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
            testing_level_set_time(msh,level_set_function, tot_time);
            /*
            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }
            */
            divergence_error_fin /= counter_interface_pts;
            divergence_error_fin = sqrt(divergence_error_fin);
            std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;




        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif




// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS -> NEW INTERFACE = 1/2 (IT HAS ISSUES)
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);
    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;

    /*
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::task_scheduler_init init(1);
    //tbb::task_scheduler_init init(tbb::task_scheduler_init::default_num_threads());
    tc.tic();
    size_t n_cells = msh.cells.size();
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cl = msh.cells[cell_ind];
            auto qps = equidistriduted_nodes_ordered_bis<RealType>(msh, cl , 2) ;
            //std::cout<<"CELL = "<<offset(msh,cell)<<std::endl;
             }
    );
    tc.toc();
    std::cout << bold << yellow << "PARALLEL LOOP: " << tc << " seconds" << reset <<'\n'<< std::endl;

    tc.tic();
    for(auto& cl : msh.cells){
        auto qps = equidistriduted_nodes_ordered_bis<RealType>(msh, cl , 2) ;
    }


    tc.toc();
    std::cout << bold << yellow << "SEQUENTIAL LOOP: " << tc << " seconds" << reset <<'\n'<< std::endl;
    */


    /************** FINITE ELEMENT INITIALIZATION **************/
    std::cout<<"--> Finite_Element è ancora lineare!"<<std::endl;
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }



    /// THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.
    timecounter tc_agglo;
    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    typedef  circle_level_set<T> Fonction;

    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;

    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre , 2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/

    tc_agglo.tic();
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
    tc_agglo.toc();

    std::cout << bold << yellow << "VELOCITY FIELD: " << tc_agglo << " seconds" << reset << std::endl;
    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;

    tc_agglo.tic();
    auto level_set_function_parallel = L2projected_level_set_high_order_parallelize< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    tc_agglo.toc();

    std::cout << bold << yellow << "L2projected_level_set_high_order_parallelize: " << tc_agglo << " seconds" << reset << std::endl;

    tc_agglo.tic();
    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    tc_agglo.toc();

    std::cout << bold << yellow << "Level_set_berstein_high_order_interpolation: " << tc_agglo << " seconds" << reset << std::endl;



    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;

    tc_agglo.tic();
    testing_level_set(msh,level_set_function);
    tc_agglo.toc();

    std::cout << bold << yellow << "testing_level_set: " << tc_agglo << " seconds" << reset << std::endl;
    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T  dt = 0. ; // area_previous_time = 0. , mass_previous_time = 0. ,

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    //T error_normal_global = 0. ;
    //T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;

    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    tc_agglo.tic();
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );
    tc_agglo.toc();

    std::cout << bold << yellow << "check_inlet: " << tc_agglo << " seconds" << reset << std::endl;

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        tc_agglo.tic();
        level_set_function_parallel.normal_continuous_setting();
        tc_agglo.toc();
        std::cout << bold << yellow << "normal_continuous_setting PARALLEL: " << tc_agglo << " seconds" << reset << std::endl;

        tc_agglo.tic();
        // Updating continuous normal function
        level_set_function.normal_continuous_setting();

        tc_agglo.toc();
        std::cout << bold << yellow << "normal_continuous_setting: " << tc_agglo << " seconds" << reset << std::endl;

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);




        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        // The sequential detect_node_position3 is fastern than the parallel one: DIMOSTRATO.
        //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom

        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        //std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"FINE DETECT CELLS."<<std::endl;

            tc_agglo.tic();
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            tc_agglo.toc();
            std::cout << bold << yellow << "detect_cell_agglo_set: " << tc_agglo << " seconds" << reset << std::endl;
            tc_agglo.tic();
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            tc_agglo.toc();
            std::cout << bold << yellow << "make_neighbors_info_cartesian: " << tc_agglo << " seconds" << reset << std::endl;
            tc_agglo.tic();
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            tc_agglo.toc();
            std::cout << bold << yellow << "refine_interface_pro3: " << tc_agglo << " seconds" << reset << std::endl;
            //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            tc_agglo.tic();
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            tc_agglo.toc();

            std::cout << bold << yellow << "make_agglomeration: " << tc_agglo << " seconds" << reset << std::endl;
        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "-----> TIME -----> cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }


        //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom

        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2(msh_i, level_set_function);
            //output_mesh_info2(msh_i, level_set_function);



        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        // typedef L2projected_level_set_high_order_parallelize< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0.; // , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        //T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;
        T divergence_error = 0.;
        // PLOTTING OF NORMAL


        postprocess_output<double> postoutput_vec;
        auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

        auto vec_normal_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Continuos_Stokes.dat");

        postprocess_output<double> postoutput_div2;
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_initial.dat");


        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals , interface_normals_cont ;


        tc_agglo.tic();
        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val = ls_cell.divergence( *interface_point );
                    divergence_error += pow((std::abs(val) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals.push_back( normal_vec ) ;

                    /// COSE  PER NORMALE CONTINUA
                    /*
                    Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*interface_point);
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;
                    std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                    interface_normals_cont.push_back( normal_vec_cont ) ;
                    vec_normal_cont->add_data(*interface_point,normal_vec_cont);
                    */
                    if( time_step == 0 )
                    {

                        vec_normal->add_data(*interface_point,normal_vec);
                        test_interface_divergence2->add_data(*interface_point , val);
                    }

                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                divergence_error += pow((std::abs(val) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                interface_normals.push_back( normal_vec ) ;

                /// COSE  PER NORMALE CONTINUA
                /*
                Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                interface_normals_cont.push_back( normal_vec_cont ) ;

                 vec_normal_cont->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_cont);
                */

                if( time_step == 0 )
                {

                    vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val );
                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }

        }

        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal);
            postoutput_vec.add_object(vec_normal_cont);
            postoutput_vec.write();

        }
        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;

        testing_level_set_time(msh,level_set_function,tot_time);
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error /= counter_interface_pts;
        divergence_error = sqrt(divergence_error);
        std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }


        tc_agglo.toc();
        std::cout << bold << yellow << "------> TIME ---->CHECK GOAL QUANTITIES: " << tc_agglo << " seconds" << reset << std::endl;
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE
        /*
        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
        */
        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);


        // Non serve modificare Gamma = 1/2
        tc_agglo.tic();
        auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        tc_agglo.toc();
        std::cout << bold << yellow << "make_test_case_eshelby_2: " << tc_agglo << " seconds" << reset << std::endl;
        tc_agglo.tic();

        auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        tc_agglo.toc();


       std::cout << bold << yellow << "make_test_case_eshelby_2 PROVA: " << tc_agglo << " seconds" << reset << std::endl;
        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);

        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
       tc_agglo.tic();

        if(solve_interface){
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step );
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case);

        tc_agglo.toc();
        std::cout << bold << yellow << "run_cuthho_interface_velocity: " << tc_agglo << " seconds" << reset << std::endl;


        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION

        tc_agglo.tic();
        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }

        tc_agglo.toc();
        std::cout << bold << yellow << "smooth_converting_into_FE_formulation: " << tc_agglo << " seconds" << reset << std::endl;

        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

         tc_agglo.tic();
        testing_velocity_field(msh , u_projected) ;

        tc_agglo.toc();
        std::cout << bold << yellow << "testing_velocity_field: " << tc_agglo << " seconds" << reset << std::endl;
        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;

        /*
        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        */

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = std::min(4e-4 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        testing_level_set2(msh,level_set_function);

        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating continuous normal function
            level_set_function.normal_continuous_setting();
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position3(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells3(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;
            T divergence_error_fin = 0.;

            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_final.dat");

            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ;

            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val = ls_cell.divergence( *interface_point );
                        divergence_error_fin += pow((std::abs(val) - 1.0/radius),2) ;
                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        interface_normals_fin.push_back( normal_vec ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        test_interface_divergence_fin->add_data( *interface_point , val);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );


                        counter_interface_pts++;
                    }

                    T val = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin += pow((std::abs(val) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));

                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals_fin.push_back( normal_vec ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence_fin->add_data( *(cl.user_data.interface.end()-1) ,val );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    counter_interface_pts++;

                }

            }

            postoutput_div2.add_object(test_interface_divergence_fin);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.write();
            goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
            testing_level_set_time(msh,level_set_function, tot_time);
            /*
            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }
            */
            divergence_error_fin /= counter_interface_pts;
            divergence_error_fin = sqrt(divergence_error_fin);
            std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;




        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif


// CHECK FOR Gamma interface = 1/2. (ON PEUT LE EFFACER)
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/
    Matrix<RealType, Dynamic, 1> vel0 , vel1 ;
    Matrix<RealType, Dynamic, 1> phi0 , phi1 , phi2 , phi3;
    Matrix<RealType, Dynamic, 1> vecprova0 , vecprova1 , vecprova2 ;
    Matrix<RealType, Dynamic, 1> vecprovabis0 , vecprovabis1  ,vecprovabis7 ,vecprovabis6 ;
    Matrix<RealType, Dynamic, Dynamic> vecprovabis2 ,vecprovabis3 ,vecprovabis4,vecprovabis5 ;
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);
    /************** FINITE ELEMENT INITIALIZATION **************/
       auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
       typedef Finite_Element<RealType,Mesh> FiniteSpace;

    tc.toc();
    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;
    vecprovabis2 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;

    vecprovabis3 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;

    vecprovabis4 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;

    vecprovabis5 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;

    std::vector<point<RealType, 2>> node_interface0 , node_interface1   ;

    for( int i = 0 ; i < 2 ; i++)
    {


     /*
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
            std::cout<<"CELL = "<<offset(msh,cell)<<std::endl;
             }
    );


#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells_size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
             }
    );
#else
    std::cout<<" I m in sequential zone"<<std::endl;
    for (size_t cell_ind = 0; cell_ind < msh.cells.size(); cell_ind++)
    {
        auto& cell = msh.cells[cell_ind];
    }
#endif
    */


    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = false , ellipse = true ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    RealType C ;
    T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }



    /// THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    typedef  elliptic_level_set<T> Fonction;

    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;

    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre , 2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;


    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);


    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    if(i == 0)
        level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;


    testing_level_set(msh,level_set_function);

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T area_previous_time = 0. , mass_previous_time = 0. , dt = 0. ;

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    T error_normal_global = 0. ;
    T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;

    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    size_t time_step = 0; // add to prove velocity error
   // for (size_t time_step = 0; time_step<=T_N; time_step++)
   // {



        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);


        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"FINE DETECT CELLS."<<std::endl;
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;


        for(auto& cl : msh_i.cells)
        {
            for(auto& pt : cl.user_data.interface)
            {
                if(i == 0)
                    node_interface0.push_back( pt );
                else
                    node_interface1.push_back( pt );
            }

        }
        std::cout<<"node_interface0 - node_interface1"<<'\n';
        for(size_t ciccia = 0 ; ciccia <  node_interface1.size() ; ciccia ++)
            std::cout<<node_interface0[ciccia] - node_interface1[ciccia]<<std::endl;



        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2(msh_i, level_set_function);
            //output_mesh_info2(msh_i, level_set_function);

        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);


        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0. , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;
        T divergence_error = 0.;
        // PLOTTING OF NORMAL


        postprocess_output<double> postoutput_vec;
        auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

        postprocess_output<double> postoutput_div2;
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_initial.dat");


        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val = ls_cell.divergence( *interface_point );
                    divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals.push_back( normal_vec ) ;

                    if( time_step == 0 )
                    {

                        vec_normal->add_data(*interface_point,normal_vec);
                        test_interface_divergence2->add_data(*interface_point , val);
                    }

                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                interface_normals.push_back( normal_vec ) ;

                if( time_step == 0 )
                {

                    vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val );
                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }

        }

        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal);
            postoutput_vec.write();

        }
        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;

        testing_level_set_time(msh,level_set_function,tot_time);
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error /= counter_interface_pts;
        divergence_error = sqrt(divergence_error);
        std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }

        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }

        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);


        // Non serve modificare Gamma = 1/2
        auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);


        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);


        if(solve_interface){
            run_cuthho_interface_velocity(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case);




        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION
        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }

        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */
        testing_velocity_field(msh , u_projected) ;
        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;
        if ( i == 1){
            std::cout<<"----> CHECK vel u_projected.sol_FEM.first = "<<'\n'<<vel0 - u_projected.sol_FEM.first <<std::endl;
            std::cout<<"----> CHECK vel u_projected.sol_FEM.second = "<<'\n'<<vel1 - u_projected.sol_FEM.second <<std::endl;
        }
        vel0 = u_projected.sol_FEM.first ;
        vel1 = u_projected.sol_FEM.second ;

        //if ( i == 1){
        //    std::cout<<"----> CHECK level_set_function.sol_FEM PRE TRANSPORT = "<<'\n'<<phi1 - level_set_function.sol_FEM <<std::endl;
        //}
        //phi1 = level_set_function.sol_FEM ;


        T sub_time = 0.;
        T sub_dt = std::min(4e-4 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;


        while( (sub_time < sub_dt*1) && (sub_time < dt1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , phi2 , phi3 , i , vecprova0 , vecprova1 , vecprova2 , vecprovabis0 , vecprovabis1 , vecprovabis2 ,vecprovabis3 ,vecprovabis4, vecprovabis5, vecprovabis6 ,vecprovabis7 );

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        if ( i == 1){
            Matrix<T, Dynamic, 1> one1 = Matrix<T, Dynamic, 1>::Ones(level_set_function.sol_FEM.size());
            std::cout<<"----> CHECK level_set_function.sol_FEM = "<<'\n'<<0.5*one1 - (phi0 - level_set_function.sol_FEM) <<std::endl;
        }
        phi0 = level_set_function.sol_FEM ;

        if ( i == 0){
            testing_level_set2(msh,level_set_function);
        }
        else
            testing_level_set2_bis(msh,level_set_function);

    }
         exit(1);


    return 0;
}
#endif





// CHECK FOR Gamma interface = 1/2 with analytical velocity. (ON PEUT LE EFFACER)
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/
    Matrix<RealType, Dynamic, Dynamic> phi0 ;
    Matrix<RealType, Dynamic, 1> vel0 , vel1 ;
    Matrix<RealType, Dynamic, 1>  phi1 , phi2 , phi3;
    Matrix<RealType, Dynamic, 1> vecprova0 , vecprova1 , vecprova2 ;
    Matrix<RealType, Dynamic, 1> vecprovabis0 , vecprovabis1   , vecprovabis7  ,vecprovabis6 ;
    Matrix<RealType, Dynamic, Dynamic> vecprovabis2 ,vecprovabis3 ,vecprovabis4,vecprovabis5;
    tc.tic();
    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);
    tc.toc();
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;
    std::vector<point<RealType, 2>> node_interface0 , node_interface1   ;
    vecprovabis2 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;
    vecprovabis3 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;
    vecprovabis4 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;
    vecprovabis5 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;
    phi0 = Matrix<RealType, Dynamic, Dynamic>::Zero(fe_data.local_ndof , msh.cells.size() ) ;
    for( int i = 0 ; i < 2 ; i++)
    {


     /*
    size_t n_cells = msh.cells.size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
            std::cout<<"CELL = "<<offset(msh,cell)<<std::endl;
             }
    );


#ifdef HAVE_INTEL_TBB
    size_t n_cells = msh.cells_size();
    std::cout<<" I m in parallel zone"<<std::endl;
    tbb::parallel_for(size_t(0), size_t(n_cells), size_t(1),
    [&msh] (size_t & cell_ind){
            auto& cell = msh.cells[cell_ind];
             }
    );
#else
    std::cout<<" I m in sequential zone"<<std::endl;
    for (size_t cell_ind = 0; cell_ind < msh.cells.size(); cell_ind++)
    {
        auto& cell = msh.cells[cell_ind];
    }
#endif
    */

    /************** FINITE ELEMENT INITIALIZATION **************/

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = false , ellipse = true ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    RealType C ;
    T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }



    /// THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    typedef  elliptic_level_set<T> Fonction;

    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;

    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre , 2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/

    //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
    T u_0 = 1.00 ;
    T u_1 = 0.00 ;
    //auto u = linear_velocity_field<RealType>(0,u_0,0,u_1); // analytic velocity (0,0,0,0)
    //typedef linear_velocity_field<RealType> Velocity;
    //auto u = rotational_velocity_field<RealType>( x_centre , y_centre , 1.0);
    //typedef rotational_velocity_field<RealType> Velocity;
    auto u = taylor_green_vortex<RealType>( 1.0, false );
    typedef taylor_green_vortex<RealType> Velocity;
    auto u_projected = projection_velocity_high_order< Mesh,Velocity,FiniteSpace,T >(fe_data , u , msh);
    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;


    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);


    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    if(i == 0)
        level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;


    testing_level_set(msh,level_set_function);

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T area_previous_time = 0. , mass_previous_time = 0. , dt = 0. ;

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    T error_normal_global = 0. ;
    T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;

    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    size_t time_step = 0; // add to prove velocity error
   // for (size_t time_step = 0; time_step<=T_N; time_step++)
   // {



        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);


        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"FINE DETECT CELLS."<<std::endl;
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;


        for(auto& cl : msh_i.cells)
        {
            for(auto& pt : cl.user_data.interface)
            {
                if(i == 0)
                    node_interface0.push_back( pt );
                else
                    node_interface1.push_back( pt );
            }

        }
        std::cout<<"node_interface0 - node_interface1"<<'\n';
        for(size_t ciccia = 0 ; ciccia <  node_interface1.size() ; ciccia ++)
            std::cout<<node_interface0[ciccia] - node_interface1[ciccia]<<std::endl;



        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2(msh_i, level_set_function);
            //output_mesh_info2(msh_i, level_set_function);

        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);


        //u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0. , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;
        T divergence_error = 0.;
        // PLOTTING OF NORMAL


        postprocess_output<double> postoutput_vec;
        auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

        postprocess_output<double> postoutput_div2;
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("divergence_interface_Stokes_initial.dat");


        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            //u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val = ls_cell.divergence( *interface_point );
                    divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals.push_back( normal_vec ) ;

                    if( time_step == 0 )
                    {

                        vec_normal->add_data(*interface_point,normal_vec);
                        test_interface_divergence2->add_data(*interface_point , val);
                    }

                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();



                    counter_interface_pts++;

                }

                T val = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                divergence_error += pow((std::abs(val) - 1.0/radius),2) ;
                Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                interface_normals.push_back( normal_vec ) ;

                if( time_step == 0 )
                {

                    vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val );
                }




                counter_interface_pts++;



            }

        }

        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal);
            postoutput_vec.write();

        }
        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;

        testing_level_set_time(msh,level_set_function,tot_time);
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error /= counter_interface_pts;
        divergence_error = sqrt(divergence_error);
        std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }

        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
 /*
        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);


        // Non serve modificare Gamma = 1/2
        auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);


        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);


        if(solve_interface){
            run_cuthho_interface_velocity(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case);




        // *********************** FEM -  PROCESSING ************************** //
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION
        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }
  */
        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */
        //testing_velocity_field(msh , u_projected) ;
        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        dt = 0.1;
        //std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;


        //if ( i == 1){
        //    std::cout<<"----> CHECK level_set_function.sol_FEM PRE TRANSPORT = "<<'\n'<<phi1 - level_set_function.sol_FEM <<std::endl;
        //}
        phi1 = level_set_function.sol_FEM ;


        T sub_time = 0.;
        T sub_dt = std::min(5e-3 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;

        while( (sub_time < sub_dt*1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check_C_NEW( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , phi2 , phi3 , i , vecprova0 , vecprova1 , vecprova2 , vecprovabis0 , vecprovabis1 , vecprovabis2 ,vecprovabis3 ,vecprovabis4, vecprovabis5, vecprovabis6 , vecprovabis7 );
                //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_to_check( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , phi2 , phi3 , i , vecprova0 , vecprova1 , vecprova2 , vecprovabis0 , vecprovabis1 , vecprovabis2 ,vecprovabis3 ,vecprovabis4, vecprovabis5, vecprovabis6 , vecprovabis7 );

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        if ( i == 1){
            //Matrix<T, Dynamic, 1> one1 = Matrix<T, Dynamic, 1>::Ones(level_set_function.sol_FEM.size());
            //std::cout<<"----> CHECK level_set_function.sol_FEM = "<<'\n'<<0.5*one1 - (phi0 - level_set_function.sol_FEM) <<std::endl;
            for(auto& cl:msh.cells)
            {
                size_t cell_offset = offset(msh, cl) ;
                auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
                for (size_t i = 0; i < fe_data.local_ndof; i++)
                {
                    auto pt = pts[i];
                    if( 0.5 -std::abs(level_set_function(pt,msh,cl) - phi0(i,cell_offset)) > 1e-6)
                    std::cout<<"In pt = "<<pt<<" --> phi(pt) = "<<level_set_function(pt,msh,cl)<<" and ERROR = "<< 0.5 -std::abs(level_set_function(pt,msh,cl) - phi0(i,cell_offset))<<std::endl;
                }

            }

        }
        if( i == 0)
        {

            for(auto& cl:msh.cells)
            {
                size_t cell_offset = offset(msh, cl) ;
                auto pts = equidistriduted_nodes_ordered_bis<T,Mesh>( msh, cl, fe_data.order);
                for (size_t i = 0; i < fe_data.local_ndof; i++)
                {
                    auto pt = pts[i];
                    phi0(i,cell_offset) = level_set_function(pt,msh,cl) ;
                }

            }


        }

        if ( i == 0){
            testing_level_set2(msh,level_set_function);
        }
        else
            testing_level_set2_bis(msh,level_set_function);

    }
         exit(1);


    return 0;
}
#endif




// CHECK CURVATURE -> CONVERGENCE
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{

        using RealType = double;

        size_t degree           = 0;
        size_t int_refsteps     = 4;
        size_t degree_FEM       = 0;

        bool dump_debug         = false;
        bool solve_interface    = false;
        bool solve_fictdom      = false;
        bool agglomeration      = false;

        bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
        bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

        mesh_init_params<RealType> mip;
        mip.Nx = 5;
        mip.Ny = 5;
        RealType d = 0.5;
        size_t T_N = 0;
        /* k <deg>:     method degree
         * g<deg>:  method FEM degree
         * M <num>:     number of cells in x direction
         * N <num>:     number of cells in y direction
         * r <num>:     number of interface refinement steps
         *
         * i:           solve interface problem
         * f:           solve fictitious domain problem
         *
         * D:           use node displacement to solve bad cuts (default)
         * A:           use agglomeration to solve bad cuts
         *
         * d:           dump debug data
         */

        int ch;
        while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
        {
            switch(ch)
            {
                case 'k':
                    degree = atoi(optarg);
                    break;

                case 'q':
                    degree_FEM = atoi(optarg);
                    break;

                case 'M':
                    mip.Nx = atoi(optarg);
                    break;

                case 'N':
                    mip.Ny = atoi(optarg);
                    break;

                case 'r':
                    int_refsteps = atoi(optarg);
                    break;

                case 'T':
                    T_N = atoi(optarg);
                    break;

                case 'i':
                    solve_interface = true;
                    break;

                case 'f':
                    solve_fictdom = true;
                    break;

                case 'D':
                    agglomeration = false;
                    break;

                case 'A':
                    agglomeration = true;
                    break;

                case 'd':
                    dump_debug = true;
                    break;

                case 'h':
                    high_order = true;
                break;

                case 'c':
                    cut_off_active = true;
                break;


                case '?':
                default:
                    std::cout << "wrong arguments" << std::endl;
                    exit(1);
            }
        }

        argc -= optind;
        argv += optind;



        timecounter tc;

        /************** BUILD MESH **************/
        tc.tic();
        cuthho_poly_mesh<RealType> msh(mip);
        typedef cuthho_poly_mesh<RealType> Mesh;
        offset_definition(msh);
        tc.toc();
        std::cout << bold << yellow << "Mesh generation: " << tc << " seconds" << reset << std::endl;



        /************** FINITE ELEMENT INITIALIZATION **************/
        auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
        typedef Finite_Element<RealType,Mesh> FiniteSpace;

        /************** ANALYTIC LEVEL SET FUNCTION  **************/
        typedef RealType T;

        bool circle = true , ellipse = false ;

        RealType radius_a , radius_b , radius ;
        RealType x_centre = 0.5;
        RealType y_centre = 0.5;
        RealType C ;
        T h = std::max( fe_data.hx , fe_data.hy) ;
        if(circle)
        {
            radius = 1.0/9.0;
        }

        if(ellipse)
        {
            radius_a = 1.0/6.0;
            radius_b = 1.0/12.0;
            //radius_a = 1.0/9.0;
            //radius_b = 1.0/9.0;
            std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
            radius = sqrt( radius_a * radius_b ) ;
            std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
        }



        /// THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

        auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
        typedef  circle_level_set<T> Fonction;

        //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
        //typedef  elliptic_level_set<T> Fonction;

        //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
        //typedef  elliptic_distance_ls<T> Fonction;

        //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre , 2*h );
        //typedef  circle_distance_ls<T> Fonction;




        /************** LEVEL SET FUNCTION DISCRETISATION **************/
        std::cout<<"degree FEM "<<degree_FEM<<std::endl;


        auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);


        //level_set_function.iso_val_interface = 0.5 ;
        //level_set_function.coefficients_mapping_quadratic( );
        //level_set_function.coefficients_mapping_MAX_MAX( );
        //level_set_function.coefficients_sfasamento( );


        if(high_order)
            std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
        else
            std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;


        testing_level_set(msh,level_set_function);

        // Initiliatisation data for time routine
        auto crr_mesh =  Current_Mesh<Mesh>(msh);

        // Initialisation area , mass
        T initial_area = 0. , initial_mass = 0.;
        T area_previous_time = 0. , mass_previous_time = 0. , dt = 0. ;

        /// DATA CHECK INITIALISATION
        T d_a = 0. ;
        T error_normal_global = 0. ;
        T error_normal_local = 0. ;
        T perimeter_initial = 0. ;
        T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



        T check = 10.0;
        T time_pos = 0.;

        T tot_time = 0.;

        bool bdry_bottom = false , bdry_up = false ;
        bool bdry_left = false , bdry_right = false ;

        check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

        size_t time_step = 0 ;


            // Updating continuous normal function
            level_set_function.normal_continuous_setting();
            level_set_function.gradient_continuous_setting();

            // ************** Re-Initialization mesh **************
            crr_mesh.current_mesh = msh;
            Mesh msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);


            //************ DO cutHHO MESH PROCESSING **************
            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                std::cout<<"FINE DETECT CELLS."<<std::endl;
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
                //refine_interface2(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // IN cuthho_export..Points/Nodes don't change-> it's fast
            if(time_step == 0){
                output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
            }
            else
                output_mesh_info2(msh_i, level_set_function);
                //output_mesh_info2(msh_i, level_set_function);



            typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
            auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);


            //u_projected.set_agglo_mesh( msh_i );
            // CALCULATION OF AREA AND MASS AT TIME STEP t^n
            // CALCULATION ALSO OF CENTRE OF MASS


            /// DATA CHECK INITIALISATION
            T area0 = 0. , mass0 = 0. , global_mass0 = 0. ;
            T diff_area = 0. , diff_mass = 0. ;
            T error_normal_global0 = 0. ;
            T centre_mass0_x = 0. , centre_mass0_y = 0. ;
            T perimeter0 = 0.;
            T normal_interface_status = 0. ;
            size_t counter_interface_pts = 0;
            T divergence_error_disc_old = 0. , divergence_error_disc_new = 0. , divergence_error_cont = 0. , divergence_error_cont_grad = 0.;
            // PLOTTING OF NORMAL


            postprocess_output<double> postoutput_vec;
            auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

            auto vec_normal_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Continuos_Stokes.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence2  = std::make_shared<
            gnuplot_output_object<double> >("divergence_interface_Stokes_initial.dat");


            std::vector<T> val_u_nx , val_u_ny , val_u_n ;
            std::vector< point<T, 2> > interface_points_plot ;
            std::vector< std::pair<T,T> > interface_normals , interface_normals_cont ;



            for(auto& cl : msh_i.cells)
            {
                ls_cell.cell_assignment(cl);
                //u_projected.cell_assignment(cl);


                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    /*
                    std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                    if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                    {
                        for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                        std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                        std::cout<<'\n'<<std::endl;
                    }
                    */
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {


                        T val_disc_old = ls_cell.divergence( *interface_point );
                        //T val_disc_new = ls_cell.divergence_disc_new( *interface_point );
                        T val_cont = ls_cell.divergence_cont( *interface_point );
                        T val_cont_grad = ls_cell.divergence_cont_grad( *interface_point );

                        divergence_error_disc_old += pow((std::abs(val_disc_old) - 1.0/radius),2) ;
                        //divergence_error_disc_new += pow((std::abs(val_disc_new) - 1.0/radius),2) ;
                        divergence_error_cont += pow((std::abs(val_cont) - 1.0/radius),2) ;
                        divergence_error_cont_grad+= pow((std::abs(val_cont_grad) - 1.0/radius),2) ;
                        //Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        //std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        //interface_normals.push_back( normal_vec ) ;

                        /// COSE  PER NORMALE CONTINUA
                        /*
                        Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*interface_point);
                        //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;
                        std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                        interface_normals_cont.push_back( normal_vec_cont ) ;
                        vec_normal_cont->add_data(*interface_point,normal_vec_cont);
                        */
                        if( time_step == 0 )
                        {

                            //vec_normal->add_data(*interface_point,normal_vec);
                            test_interface_divergence2->add_data(*interface_point , val_disc_old);
                        }

                        //perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        //normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                        //interface_points_plot.push_back(*(interface_point)) ;
                        //val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        //val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        //val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                        //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                        //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;
                        std::cout<<"val_disc_old = "<<val_disc_old<<std::endl;
                        //std::cout<<"val_disc_new = "<<val_disc_new<<std::endl;
                        std::cout<<"val_cont = "<<val_cont<<std::endl;
                        std::cout<<"val_cont_grad = "<<val_cont_grad<<std::endl;
                        counter_interface_pts++;

                    }

                    T val_disc_old = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    //T val_disc_new = ls_cell.divergence_disc_new( *(cl.user_data.interface.end()-1) );
                    T val_cont = ls_cell.divergence_cont( *(cl.user_data.interface.end()-1) );
                    T val_cont_grad = ls_cell.divergence_cont_grad( *(cl.user_data.interface.end()-1) );
                    divergence_error_disc_old += pow((std::abs(val_disc_old) - 1.0/radius),2) ;
                    //divergence_error_disc_new += pow((std::abs(val_disc_new) - 1.0/radius),2) ;
                    divergence_error_cont += pow((std::abs(val_cont) - 1.0/radius),2) ;
                    divergence_error_cont_grad+= pow((std::abs(val_cont_grad) - 1.0/radius),2) ;
                    std::cout<<"val_disc_old = "<<val_disc_old<<std::endl;
                    //std::cout<<"val_disc_new = "<<val_disc_new<<std::endl;
                    std::cout<<"val_cont = "<<val_cont<<std::endl;
                    std::cout<<"val_cont_grad = "<<val_cont_grad<<std::endl;
                    //Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                    //std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    //interface_normals.push_back( normal_vec ) ;

                    /// COSE  PER NORMALE CONTINUA
                    /*
                    Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                    interface_normals_cont.push_back( normal_vec_cont ) ;

                     vec_normal_cont->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_cont);
                    */
                    /*
                    if( time_step == 0 )
                    {

                        vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                        test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val );
                    }


                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);


                interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                    val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    */
                    counter_interface_pts++;



                }

            }

            if( time_step == 0 )
            {
                postoutput_div2.add_object(test_interface_divergence2);
                postoutput_div2.write();

                postoutput_vec.add_object(vec_normal);
                postoutput_vec.add_object(vec_normal_cont);
                postoutput_vec.write();

            }
            //goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;

            //testing_level_set_time(msh,level_set_function,tot_time);

            divergence_error_disc_old /= counter_interface_pts;
            divergence_error_disc_old = sqrt(divergence_error_disc_old);

   // divergence_error_disc_new /= counter_interface_pts;
   // divergence_error_disc_new = sqrt(divergence_error_disc_new);

    divergence_error_cont /= counter_interface_pts;
    divergence_error_cont = sqrt(divergence_error_cont);

    divergence_error_cont_grad/= counter_interface_pts;
    divergence_error_cont_grad = sqrt(divergence_error_cont_grad);

            std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE DISC OLD at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error_disc_old <<std::endl;

    // std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE DISC NEW at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error_disc_new <<std::endl;

     std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE CONTINUOUS at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error_cont <<std::endl;

    std::cout<<yellow<<bold<<"The l2 error of the DIVERGENCE CONTINUOUS (VIA GRADIENT) at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error_cont_grad <<std::endl;










        return 0;

}
#endif






// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 28/07/2020
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    offset_definition(msh);



    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = false , ellipse = true ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
        //radius_a = 1.0/9.0;
        //radius_b = 1.0/9.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }



    ///---->  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.
    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    typedef  elliptic_level_set<T> Fonction;

    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;

    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre , 2*h );
    //typedef  circle_distance_ls<T> Fonction;


    timecounter tc_agglo;

    /**************  VELOCITY FIELD  INITIALISATION  **************/

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;

    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ;
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;

    tc_agglo.tic();
    testing_level_set(msh,level_set_function);
    tc_agglo.toc();
    std::cout << bold << yellow << "testing_level_set: time = " << tc_agglo << " seconds" << reset << std::endl;

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T  dt = 0. ; // area_previous_time = 0. , mass_previous_time = 0. ,

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    //T error_normal_global = 0. ;
    //T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;
    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {
        tc_agglo.tic();
        // Updating continuous normal function
        level_set_function.normal_continuous_setting() ;
        level_set_function.gradient_continuous_setting() ;
        tc_agglo.toc();
        std::cout << bold << yellow << "normal_continuous_setting: " << tc_agglo << " seconds" << reset << std::endl;

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);




        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        // The sequential detect_node_position3 is fastern than the parallel one: DIMOSTRATO.
        //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom

        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        //std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"----> Fine of detect_cut_cells3."<<std::endl;

            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla

        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow <<'\n' <<"-----> TIME -----> cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset <<'\n' << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }


        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2(msh_i, level_set_function);



        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;


        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0.; // , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        //T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;


        // PLOTTING OF NORMAL
        postprocess_output<double> postoutput_vec;
        auto vec_normal = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_initial.dat");

        auto vec_normal_n_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes.dat");

        auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

        postprocess_output<double> postoutput_div2;


        auto test_interface_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_interface_Stokes_initial.dat");

        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals , interface_normals_n_cont , interface_normals_grad_cont ;
         T divergence_error0 = 0. , divergence_error1 = 0. , divergence_error2 = 0.;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *interface_point );
                    divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_cont_grad( *interface_point );
                    divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals.push_back( normal_vec ) ;

                    Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_cont(*interface_point);
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;
                    std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                    interface_normals_n_cont.push_back( normal_vec_cont ) ;

                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_cont_normalised(*interface_point);
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;
                    std::pair<T,T> normal_vec_cont_grad = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                    interface_normals_grad_cont.push_back( normal_vec_cont_grad ) ;



                    if( time_step == 0 )
                    {

                        vec_normal->add_data(*interface_point,normal_vec);
                        test_interface_divergence0->add_data(*interface_point , val0);
                        test_interface_divergence1->add_data(*interface_point , val1);
                        test_interface_divergence2->add_data(*interface_point , val2);
                        vec_normal_n_cont->add_data(*interface_point,normal_vec_cont);
                        vec_normal_grad_cont->add_data(*interface_point,normal_vec_cont_grad);
                    }

                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                T val1 = ls_cell.divergence_cont(*(cl.user_data.interface.end()-1));
                T val2 = ls_cell.divergence_cont_grad(*(cl.user_data.interface.end()-1));
                divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;
                divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;
                divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                interface_normals.push_back( normal_vec ) ;

                Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                interface_normals_n_cont.push_back( normal_vec_n_cont ) ;

                Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_cont_normalised(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                /// COSE  PER NORMALE CONTINUA
                /*
                Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                interface_normals_cont.push_back( normal_vec_cont ) ;

                 vec_normal_cont->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_cont);
                */

                if( time_step == 0 )
                {

                    vec_normal->add_data(*(cl.user_data.interface.end()-1) ,normal_vec);
                    test_interface_divergence0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val2 );
                    vec_normal_n_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_n_cont);
                    vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);
                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);



                interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }

        }

        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence0);
            postoutput_div2.add_object(test_interface_divergence1);
            postoutput_div2.add_object(test_interface_divergence2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal);
            postoutput_vec.add_object(vec_normal_n_cont);
            postoutput_vec.add_object(vec_normal_grad_cont);
            postoutput_vec.write();

        }

        std::cout<<"NOTICE:--> The terms u \cdot n are made with n = normal (NO CONTINUOUS)."<<std::endl;

        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
        testing_level_set_time(msh,level_set_function,tot_time);
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error0 /= counter_interface_pts;
        divergence_error0 = sqrt(divergence_error0);

        divergence_error1 /= counter_interface_pts;
        divergence_error1 = sqrt(divergence_error1);

        divergence_error2 /= counter_interface_pts;
        divergence_error2 = sqrt(divergence_error2);
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE (OLD) at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error0 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE (n^c continuous) at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error1 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE ((\nabla(phi))^c continuous) at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error2 <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }


        tc_agglo.toc();
        std::cout << bold << yellow << "------> TIME FOR CHECKING GOAL QUANTITIES: " << tc_agglo << " seconds" << reset << std::endl;
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE
        /*
        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
        */
        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);


        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);

        auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);

        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

        tc_agglo.tic();

        if(solve_interface){
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step);
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        tc_agglo.toc();
        std::cout << bold << yellow << "TIME-----> run_cuthho_interface_velocity: " << tc_agglo << " seconds" << reset << std::endl;


        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION

        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }


        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

        testing_velocity_field(msh , u_projected) ;

        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;

        /*
        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        */

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = std::min(4e-4 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        testing_level_set2(msh,level_set_function);

        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating continuous normal function
            level_set_function.normal_continuous_setting();
            level_set_function.gradient_continuous_setting() ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position3(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells3(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;


            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");
            auto vec_normal_n_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes_final.dat");

            auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin0  = std::make_shared< gnuplot_output_object<double> >("k0_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin1  = std::make_shared< gnuplot_output_object<double> >("k1_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin2  = std::make_shared< gnuplot_output_object<double> >("k2_fin_divergence_interface_Stokes_final.dat");

            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ,interface_normals_n_cont_fin ,interface_normals_grad_cont_fin ;

            T divergence_error_fin0 = 0. , divergence_error_fin1 = 0. , divergence_error_fin2 = 0.;



            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val0 = ls_cell.divergence( *interface_point );
                        divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;
                        T val2 = ls_cell.divergence_cont_grad( *interface_point );
                        divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        interface_normals_fin.push_back( normal_vec ) ;

                        Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*interface_point);
                        std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                        interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                        Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_cont_normalised(*interface_point);
                        std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                        interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        vec_normal_n_cont_fin->add_data(*interface_point,normal_vec_n_cont);
                        vec_normal_grad_cont_fin->add_data(*interface_point,normal_vec_grad_cont);
                        test_interface_divergence_fin0->add_data( *interface_point , val0);
                        test_interface_divergence_fin1->add_data( *interface_point , val1);
                        test_interface_divergence_fin2->add_data( *interface_point , val2);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                        counter_interface_pts++;
                    }

                    T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_cont_grad( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals_fin.push_back( normal_vec ) ;

                    Eigen::Matrix<T,2,1> normal_n_cont = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_n_cont(0),normal_n_cont(1));
                    interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal_cont_normalised(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    vec_normal_n_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_n_cont);
                    vec_normal_grad_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_grad_norm);
                    test_interface_divergence_fin0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence_fin1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence_fin2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    counter_interface_pts++;

                }

            }

            postoutput_div2.add_object(test_interface_divergence_fin0);
            postoutput_div2.add_object(test_interface_divergence_fin1);
            postoutput_div2.add_object(test_interface_divergence_fin2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.add_object(vec_normal_n_cont_fin);
            postoutput_vec.add_object(vec_normal_grad_cont_fin);
            postoutput_vec.write();

            goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
            testing_level_set_time(msh,level_set_function, tot_time);
            /*
            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }
            */
            divergence_error_fin0 /= counter_interface_pts;
            divergence_error_fin0 = sqrt(divergence_error_fin0);

            divergence_error_fin1 /= counter_interface_pts;
            divergence_error_fin1 = sqrt(divergence_error_fin1);

            divergence_error_fin2 /= counter_interface_pts;
            divergence_error_fin2 = sqrt(divergence_error_fin2);

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin0 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin1 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin2 <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) << std::endl;



        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif



// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 28/07/2020 -> GRAD CONTINUOS IMPLEMENTATION (COMPARISON WITH DISCONTINUOUS AND NORMAL_CONT STUFFS)
// ---- > normal_interface_status HAS TO BE CORRECTED !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);


    std::cout << ansi::foreground_red << "PROVA in red" << ansi::reset << std::endl;

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = false , ellipse = true ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        radius_a = 1.0/9.0;
        radius_b = 1.0/11.0;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }



    ///---->  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.
    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    typedef  elliptic_level_set<T> Fonction;

    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;

    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre , 2*h );
    //typedef  circle_distance_ls<T> Fonction;


    timecounter tc_agglo;

    /**************  VELOCITY FIELD  INITIALISATION  **************/

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;

    //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ; // SE MAPPING QUI è falso DEVO FARLO DENTRO IL TRANSPORT PB
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;

    //tc_agglo.tic();
    //testing_level_set(msh,level_set_function);
    //tc_agglo.toc();
    //std::cout << bold << yellow << "testing_level_set: time = " << tc_agglo << " seconds" << reset << std::endl;

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T  dt = 0. ; // area_previous_time = 0. , mass_previous_time = 0. ,

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    //T error_normal_global = 0. ;
    //T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;
    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {
        tc_agglo.tic();
        // UPDATING CONTINUOUS NORMAL FUNCTIONS
        level_set_function.normal_continuous_setting() ;
        level_set_function.gradient_continuous_setting() ;

        tc_agglo.toc();
        std::cout << bold << yellow << "normal_continuous_setting: " << tc_agglo << " seconds" << reset << std::endl;

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);




        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        // The sequential detect_node_position3 is fastern than the parallel one: DIMOSTRATO.
        //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom

        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        //std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"----> Fine di detect_cut_cells3."<<std::endl;

            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla

        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow <<'\n' <<"-----> TIME -----> cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset <<'\n' << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }


        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2(msh_i, level_set_function);



        //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;

        auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0.; // , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        //T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;


        // PLOTTING OF NORMAL
        postprocess_output<double> postoutput_vec;
        auto vec_normal_disc = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_disc_Stokes_initial.dat");

        auto vec_normal_n_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes.dat");

        auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

        postprocess_output<double> postoutput_div2;


        auto test_interface_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_interface_Stokes_initial.dat");

        auto test_curv_var_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_cell  = std::make_shared< gnuplot_output_object<double> >("cell_limit_curv_var_initial.dat");


        std::vector<T> val_u_nx , val_u_ny , val_u_n ;
        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals_disc , interface_normals_n_cont , interface_normals_grad_cont ;
        T divergence_error0 = 0. , divergence_error1 = 0. , divergence_error2 = 0.;


        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *interface_point );
                    divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_disc( *interface_point );
                    divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                    Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_cont(*interface_point);
                    std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                    interface_normals_n_cont.push_back( normal_vec_cont ) ;
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;

                    Eigen::Matrix<T,2,1> normal_disc_val = ls_cell.normal_disc(*interface_point);
                    std::pair<T,T> normal_vec_disc = std::make_pair(normal_disc_val(0),normal_disc_val(1));
                    interface_normals_disc.push_back( normal_vec_disc ) ;
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;



                    if( time_step == 0 )
                    {
                        test_interface_divergence0->add_data(*interface_point , val0);
                        test_interface_divergence1->add_data(*interface_point , val1);
                        test_interface_divergence2->add_data(*interface_point , val2);
                        vec_normal_disc->add_data(*interface_point,normal_vec_disc);
                        vec_normal_n_cont->add_data(*interface_point,normal_vec_cont);
                        vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);


                    }


                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();



                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                T val1 = ls_cell.divergence_cont(*(cl.user_data.interface.end()-1));
                T val2 = ls_cell.divergence_disc(*(cl.user_data.interface.end()-1));
                divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;
                divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;
                divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                interface_normals_n_cont.push_back( normal_vec_n_cont ) ;

                Eigen::Matrix<T,2,1> normal_disc_val = ls_cell.normal_disc(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_disc = std::make_pair(normal_disc_val(0),normal_disc_val(1));
                interface_normals_disc.push_back( normal_vec_disc ) ;

                /// COSE  PER NORMALE CONTINUA
                /*
                Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                interface_normals_cont.push_back( normal_vec_cont ) ;

                 vec_normal_cont->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_cont);
                */



                if( time_step == 0 )
                {
                    test_interface_divergence0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    vec_normal_disc->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_disc);
                    vec_normal_n_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_n_cont);
                    vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);



                interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }

        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        T val2 = ls_cell.divergence_disc( *interface_point );

                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);
                        test_curv_var_divergence1->add_data(curv_var, val1);
                        test_curv_var_divergence2->add_data(curv_var, val2);
                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                T val1 = ls_cell.divergence_cont( *interface_point );
                                T val2 = ls_cell.divergence_disc( *interface_point );

                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);
                                test_curv_var_divergence1->add_data(curv_var, val1);
                                test_curv_var_divergence2->add_data(curv_var, val2);

                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }



        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence0);
            postoutput_div2.add_object(test_interface_divergence1);
            postoutput_div2.add_object(test_interface_divergence2);

            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_divergence1);
            postoutput_div2.add_object(test_curv_var_divergence2);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_disc);
            postoutput_vec.add_object(vec_normal_n_cont);
            postoutput_vec.add_object(vec_normal_grad_cont);
            postoutput_vec.write();

        }



        std::cout<<"NOTICE:--> The terms u cdot n are made with n = normal (NO CONTINUOUS)."<<std::endl;

        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont ) ; // GOAL QUANTITIES PLOT JUST THE GRADIENT CONTINUOUS QUANTITIES


        testing_level_set_time(msh,level_set_function,tot_time); // IT PLOT JUST THE PROFILE
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error0 /= counter_interface_pts;
        divergence_error0 = sqrt(divergence_error0);

        divergence_error1 /= counter_interface_pts;
        divergence_error1 = sqrt(divergence_error1);

        divergence_error2 /= counter_interface_pts;
        divergence_error2 = sqrt(divergence_error2);
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error0 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error1 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error2 <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }


        tc_agglo.toc();
        std::cout << bold << yellow << "------> TIME FOR CHECKING GOAL QUANTITIES: " << tc_agglo << " seconds" << reset << std::endl;
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE
        /*
        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
        */
        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);


        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);

        auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);

        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

        tc_agglo.tic();

        if(solve_interface){
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step );
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        tc_agglo.toc();
        std::cout << bold << yellow << "TIME-----> run_cuthho_interface_velocity: " << tc_agglo << " seconds" << reset << std::endl;


        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION

        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }


        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

        testing_velocity_field(msh , u_projected) ;

        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;

        /*
        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        */

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T sub_dt = std::min(4e-4 , dt ) ;
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order){
                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        testing_level_set2(msh,level_set_function);

        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating continuous normal function
            level_set_function.normal_continuous_setting();
            level_set_function.gradient_continuous_setting() ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position3(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells3(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;


            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");
            auto vec_normal_n_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes_final.dat");

            auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin0  = std::make_shared< gnuplot_output_object<double> >("k0_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin1  = std::make_shared< gnuplot_output_object<double> >("k1_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin2  = std::make_shared< gnuplot_output_object<double> >("k2_fin_divergence_interface_Stokes_final.dat");

            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ,interface_normals_n_cont_fin ,interface_normals_grad_cont_fin ;

            T divergence_error_fin0 = 0. , divergence_error_fin1 = 0. , divergence_error_fin2 = 0.;



            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) , 2) + pow( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val0 = ls_cell.divergence( *interface_point );
                        divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;
                        T val2 = ls_cell.divergence_disc( *interface_point );
                        divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        interface_normals_fin.push_back( normal_vec ) ;

                        Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*interface_point);
                        std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                        interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                        Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_disc(*interface_point);
                        std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                        interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        vec_normal_n_cont_fin->add_data(*interface_point,normal_vec_n_cont);
                        vec_normal_grad_cont_fin->add_data(*interface_point,normal_vec_grad_cont);
                        test_interface_divergence_fin0->add_data( *interface_point , val0);
                        test_interface_divergence_fin1->add_data( *interface_point , val1);
                        test_interface_divergence_fin2->add_data( *interface_point , val2);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                        counter_interface_pts++;
                    }

                    T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_disc( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals_fin.push_back( normal_vec ) ;

                    Eigen::Matrix<T,2,1> normal_n_cont = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_n_cont(0),normal_n_cont(1));
                    interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal_disc(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    vec_normal_n_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_n_cont);
                    vec_normal_grad_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_grad_norm);
                    test_interface_divergence_fin0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence_fin1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence_fin2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0),2) + pow( u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    counter_interface_pts++;

                }

            }

            postoutput_div2.add_object(test_interface_divergence_fin0);
            postoutput_div2.add_object(test_interface_divergence_fin1);
            postoutput_div2.add_object(test_interface_divergence_fin2);
            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.add_object(vec_normal_n_cont_fin);
            postoutput_vec.add_object(vec_normal_grad_cont_fin);
            postoutput_vec.write();

            goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
            testing_level_set_time(msh,level_set_function, tot_time);
            /*
            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }
            */
            divergence_error_fin0 /= counter_interface_pts;
            divergence_error_fin0 = sqrt(divergence_error_fin0);

            divergence_error_fin1 /= counter_interface_pts;
            divergence_error_fin1 = sqrt(divergence_error_fin1);

            divergence_error_fin2 /= counter_interface_pts;
            divergence_error_fin2 = sqrt(divergence_error_fin2);

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin0 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin1 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin2 <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) << std::endl;



        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif


// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 21/09/2020 -> GRAD CONTINUOS IMPLEMENTATION (IMAGES CHECKING FOR CONTINUOUS STUFF)
// ---- > normal_interface_status CORRECT !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);




    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/9.0-eps_circ;
        radius_b = 1.0/9.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    typedef  circle_level_set<T> Fonction;

    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    //radius = 0.31 ;
    //auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    //typedef  flower_level_set<T> Fonction;

    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;


    timecounter tc_agglo;

    /**************  VELOCITY FIELD  INITIALISATION  **************/

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;

    //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ; // SE MAPPING QUI è falso DEVO FARLO DENTRO IL TRANSPORT PB
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;

    //tc_agglo.tic();
    //testing_level_set(msh,level_set_function);
    //tc_agglo.toc();
    //std::cout << bold << yellow << "testing_level_set: time = " << tc_agglo << " seconds" << reset << std::endl;

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T  dt = 0. ; // area_previous_time = 0. , mass_previous_time = 0. ,

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    //T error_normal_global = 0. ;
    //T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;




    T check = 10.0;
    T time_pos = 0.;
    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {
        tc_agglo.tic();
        // UPDATING CONTINUOUS NORMAL FUNCTIONS
        level_set_function.normal_continuous_setting() ;
        level_set_function.gradient_continuous_setting() ;

        tc_agglo.toc();
        std::cout << bold << yellow << "normal_continuous_setting: " << tc_agglo << " seconds" << reset << std::endl;

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);




        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        // The sequential detect_node_position3 is fastern than the parallel one: DIMOSTRATO.
        //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom

        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        //std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"----> Fine di detect_cut_cells3."<<std::endl;

            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla

        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow <<'\n' <<"-----> TIME -----> cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset <<'\n' << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }


        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2_time(msh_i, level_set_function , tot_time);
           // output_mesh_info2(msh_i, level_set_function);



        //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;

        auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0.; // , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        //T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;

        size_t counter_interface_pts = 0;


        // PLOTTING OF NORMAL
        postprocess_output<double> postoutput_vec;
        auto vec_normal_disc = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_disc_Stokes_initial.dat");

        auto vec_normal_n_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes.dat");

        auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");
        //std::string filename_normal_interf_cont_grad = "normal_cont_grad_" + std::to_string(tot_time) + ".dat";
        //auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >(filename_normal_interf_cont_grad);

        postprocess_output<double> postoutput_div2;


        auto test_interface_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_interface_Stokes_initial.dat");

        //auto test_curv_var_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_Stokes_curv_var_initial.dat");
        //auto test_curv_var_cell  = std::make_shared< gnuplot_output_object<double> >("cell_limit_curv_var_initial.dat");

        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);


        std::vector<T> val_u_nx , val_u_ny , val_u_n , curvature_k0 ;

        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals_disc , interface_normals_n_cont , interface_normals_grad_cont , velocity_interface , velocity_field , points_vel_field;
        T divergence_error0 = 0. , divergence_error1 = 0. , divergence_error2 = 0.;


        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    curvature_k0.push_back(val0) ;
                    divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *interface_point );
                    divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_disc( *interface_point );
                    divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                    Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_cont(*interface_point);
                    std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                    interface_normals_n_cont.push_back( normal_vec_cont ) ;
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;

                    Eigen::Matrix<T,2,1> normal_disc_val = ls_cell.normal_disc(*interface_point);
                    std::pair<T,T> normal_vec_disc = std::make_pair(normal_disc_val(0),normal_disc_val(1));
                    interface_normals_disc.push_back( normal_vec_disc ) ;
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;



                    if( time_step == 0 )
                    {
                        test_interface_divergence0->add_data(*interface_point , val0);
                        test_interface_divergence1->add_data(*interface_point , val1);
                        test_interface_divergence2->add_data(*interface_point , val2);
                        vec_normal_disc->add_data(*interface_point,normal_vec_disc);
                        vec_normal_n_cont->add_data(*interface_point,normal_vec_cont);
                        vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);


                    }


                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                curvature_k0.push_back(val0) ;
                T val1 = ls_cell.divergence_cont(*(cl.user_data.interface.end()-1));
                T val2 = ls_cell.divergence_disc(*(cl.user_data.interface.end()-1));
                divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;
                divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;
                divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                interface_normals_n_cont.push_back( normal_vec_n_cont ) ;

                Eigen::Matrix<T,2,1> normal_disc_val = ls_cell.normal_disc(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_disc = std::make_pair(normal_disc_val(0),normal_disc_val(1));
                interface_normals_disc.push_back( normal_vec_disc ) ;

                velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;
                /// COSE  PER NORMALE CONTINUA
                /*
                Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                interface_normals_cont.push_back( normal_vec_cont ) ;

                 vec_normal_cont->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_cont);
                */



                if( time_step == 0 )
                {
                    test_interface_divergence0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    vec_normal_disc->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_disc);
                    vec_normal_n_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_n_cont);
                    vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


                }

                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);



                interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }

        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        T val2 = ls_cell.divergence_disc( *interface_point );

                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);
                        test_curv_var_divergence1->add_data(curv_var, val1);
                        test_curv_var_divergence2->add_data(curv_var, val2);
                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                T val1 = ls_cell.divergence_cont( *interface_point );
                                T val2 = ls_cell.divergence_disc( *interface_point );

                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);
                                test_curv_var_divergence1->add_data(curv_var, val1);
                                test_curv_var_divergence2->add_data(curv_var, val2);

                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }



        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence0);
            postoutput_div2.add_object(test_interface_divergence1);
            postoutput_div2.add_object(test_interface_divergence2);

            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_divergence1);
            postoutput_div2.add_object(test_curv_var_divergence2);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_disc);
            postoutput_vec.add_object(vec_normal_n_cont);
            postoutput_vec.add_object(vec_normal_grad_cont);
            postoutput_vec.write();

        }
        if( time_step > 0)
        {
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();
        }


        std::cout<<"NOTICE:--> The terms u cdot n are made with n = normal (NO CONTINUOUS)."<<std::endl;

        //goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont ) ; // GOAL QUANTITIES PLOT JUST THE GRADIENT CONTINUOUS QUANTITIES
        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont , velocity_interface , velocity_field , points_vel_field ) ; // GOAL QUANTITIES PLOT JUST THE GRADIENT CONTINUOUS QUANTITIES


        testing_level_set_time(msh,level_set_function,tot_time); // IT PLOT JUST THE PROFILE
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error0 /= counter_interface_pts;
        divergence_error0 = sqrt(divergence_error0);

        divergence_error1 /= counter_interface_pts;
        divergence_error1 = sqrt(divergence_error1);

        divergence_error2 /= counter_interface_pts;
        divergence_error2 = sqrt(divergence_error2);
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error0 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error1 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error2 <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;

        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;



        }


        tc_agglo.toc();
        std::cout << bold << yellow << "------> TIME FOR CHECKING GOAL QUANTITIES: " << tc_agglo << " seconds" << reset << std::endl;
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE
        /*
        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
        */
        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------- OLD VERSIONS --------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);

        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad , gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);

        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

        tc_agglo.tic();

        if(solve_interface){
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step);
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        tc_agglo.toc();
        std::cout << bold << yellow << "TIME-----> run_cuthho_interface_velocity: " << tc_agglo << " seconds" << reset << std::endl;


        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION

        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }


        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

        testing_velocity_field(msh , u_projected) ;

        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;

        // -------------------- TIME EVOLUTION (u^n,phi^n) ----------------------
        // MACRO TIME STEP dt
        T dt2 = 1e-3;

        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;

        T sub_dt = std::min(4*1e-4 , dt ) ;
        /*
        T sub_dt;
        if(tot_time <0.132)
            sub_dt = std::min(4*1e-4 , dt ) ;
        else
            sub_dt = std::min(5*1e-5 , dt ) ;
        */
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        testing_level_set2(msh,level_set_function);

        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating continuous normal function
            level_set_function.normal_continuous_setting();
            level_set_function.gradient_continuous_setting() ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position3(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells3(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2_time(msh_i2, level_set_function,tot_time);
            //output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;


            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");
            auto vec_normal_n_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes_final.dat");

            auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin0  = std::make_shared< gnuplot_output_object<double> >("k0_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin1  = std::make_shared< gnuplot_output_object<double> >("k1_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin2  = std::make_shared< gnuplot_output_object<double> >("k2_fin_divergence_interface_Stokes_final.dat");


            //auto test_curv_var_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_Stokes_curv_var_final.dat");
            auto test_curv_var_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_Stokes_curv_var_final.dat");
            auto test_curv_var_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_Stokes_curv_var_final.dat");
            //auto test_curv_var_cell  = std::make_shared< gnuplot_output_object<double> >("cell_limit_curv_var_initial.dat");

            std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(tot_time) + ".dat";
            auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
            std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(tot_time) + ".dat";
            auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);




            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ,interface_normals_n_cont_fin ,interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field;

            T divergence_error_fin0 = 0. , divergence_error_fin1 = 0. , divergence_error_fin2 = 0.;



            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val0 = ls_cell.divergence( *interface_point );
                        divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;
                        T val2 = ls_cell.divergence_disc( *interface_point );
                        divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        interface_normals_fin.push_back( normal_vec ) ;

                        Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*interface_point);
                        std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                        interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                        Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_disc(*interface_point);
                        std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                        interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        vec_normal_n_cont_fin->add_data(*interface_point,normal_vec_n_cont);
                        vec_normal_grad_cont_fin->add_data(*interface_point,normal_vec_grad_cont);
                        test_interface_divergence_fin0->add_data( *interface_point , val0);
                        test_interface_divergence_fin1->add_data( *interface_point , val1);
                        test_interface_divergence_fin2->add_data( *interface_point , val2);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                        velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;


                        counter_interface_pts++;
                    }

                    T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_disc( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals_fin.push_back( normal_vec ) ;

                    Eigen::Matrix<T,2,1> normal_n_cont = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_n_cont(0),normal_n_cont(1));
                    interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal_disc(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    vec_normal_n_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_n_cont);
                    vec_normal_grad_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_grad_norm);
                    test_interface_divergence_fin0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence_fin1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence_fin2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                    counter_interface_pts++;

                }
                for(auto& pt : points(msh_i,cl))
                {
                    points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                    velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

                }


            }

            bool first_cut_cell_found = FALSE ;
            T distance_pts = 0.0;
            point<T,2> first_point ;
            point<T,2> cell_end_point;
            for(auto& cl : msh_i.cells)
            {

                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    if(!first_cut_cell_found)
                    {
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                        {
                            T val0 = ls_cell.divergence( *interface_point );
                            T val1 = ls_cell.divergence_cont( *interface_point );
                            T val2 = ls_cell.divergence_disc( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);
                            test_curv_var_divergence1->add_data(curv_var, val1);
                            test_curv_var_divergence2->add_data(curv_var, val2);
                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        first_cut_cell_found = TRUE;
                        first_point = *cl.user_data.interface.begin() ;
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }
                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                    {
                        for(auto& cl : msh_i.cells)
                        {
                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                            {
                                ls_cell.cell_assignment(cl);
                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                                {

                                    T val0 = ls_cell.divergence( *interface_point );
                                    T val1 = ls_cell.divergence_cont( *interface_point );
                                    T val2 = ls_cell.divergence_disc( *interface_point );

                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                                    if( interface_point == cl.user_data.interface.begin() )
                                        test_curv_var_cell->add_data(curv_var, val0);

                                    test_curv_var_divergence0->add_data(curv_var, val0);
                                    test_curv_var_divergence1->add_data(curv_var, val1);
                                    test_curv_var_divergence2->add_data(curv_var, val2);

                                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                                }
                                cell_end_point = *(cl.user_data.interface.end() -1) ;
                            }

                        }

                    }
                    else
                        break;

                }

            }





            postoutput_div2.add_object(test_interface_divergence_fin0);
            postoutput_div2.add_object(test_interface_divergence_fin1);
            postoutput_div2.add_object(test_interface_divergence_fin2);
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_divergence1);
            postoutput_div2.add_object(test_curv_var_divergence2);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.add_object(vec_normal_n_cont_fin);
            postoutput_vec.add_object(vec_normal_grad_cont_fin);
            postoutput_vec.write();
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont , velocity_interface , velocity_field , points_vel_field ) ;
            //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
            testing_level_set_time(msh,level_set_function, tot_time);
            /*
            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }
            */
            divergence_error_fin0 /= counter_interface_pts;
            divergence_error_fin0 = sqrt(divergence_error_fin0);

            divergence_error_fin1 /= counter_interface_pts;
            divergence_error_fin1 = sqrt(divergence_error_fin1);

            divergence_error_fin2 /= counter_interface_pts;
            divergence_error_fin2 = sqrt(divergence_error_fin2);

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin0 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin1 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin2 <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) << std::endl;



        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif






// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 28/09/2020 -> DISCONTINUOUS IMPLEMENTATION (IMAGES CHECKING FOR DISCONTINUOS STUFF)
// ---- > normal_interface_status CORRECT !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);




    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/9.0-eps_circ;
        radius_b = 1.0/9.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    typedef  circle_level_set<T> Fonction;

    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    //radius = 0.31 ;
    //auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    //typedef  flower_level_set<T> Fonction;

    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;


    timecounter tc_agglo;

    /**************  VELOCITY FIELD  INITIALISATION  **************/

    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;

    auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ; // SE MAPPING QUI è falso DEVO FARLO DENTRO IL TRANSPORT PB
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    if(high_order)
        std::cout<<bold<<yellow<<"----> USING phi_HP HIGH order!!!!! "<<reset<<std::endl;
    else
        std::cout<<bold<<yellow<<"----> USING phi_L LOW order!!!!! "<<reset<<std::endl;

    //tc_agglo.tic();
    //testing_level_set(msh,level_set_function);
    //tc_agglo.toc();
    //std::cout << bold << yellow << "testing_level_set: time = " << tc_agglo << " seconds" << reset << std::endl;

    // Initiliatisation data for time routine
    auto crr_mesh =  Current_Mesh<Mesh>(msh);

    // Initialisation area , mass
    T initial_area = 0. , initial_mass = 0.;
    T  dt = 0. ; // area_previous_time = 0. , mass_previous_time = 0. ,

    /// DATA CHECK INITIALISATION
    T d_a = 0. ;
    //T error_normal_global = 0. ;
    //T error_normal_local = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;



    T check = 10.0;
    T time_pos = 0.;
    T tot_time = 0.;

    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;

    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {
        tc_agglo.tic();
        // UPDATING CONTINUOUS NORMAL FUNCTIONS
        level_set_function.normal_continuous_setting() ;
        level_set_function.gradient_continuous_setting() ;

        tc_agglo.toc();
        std::cout << bold << yellow << "normal_continuous_setting: " << tc_agglo << " seconds" << reset << std::endl;

        // ************** Re-Initialization mesh **************
        crr_mesh.current_mesh = msh;
        Mesh msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);




        //************ DO cutHHO MESH PROCESSING **************
        tc.tic();
        // The sequential detect_node_position3 is fastern than the parallel one: DIMOSTRATO.
        //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom

        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
        //std::cout<<"FINE DETECT NODES AND FACES."<<std::endl;
        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
            std::cout<<"----> Fine di detect_cut_cells3."<<std::endl;

            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla

        }
        else
        {
            //move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow <<'\n' <<"-----> TIME -----> cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset <<'\n' << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }


        // IN cuthho_export..Points/Nodes don't change-> it's fast
        if(time_step == 0){
            output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export
        }
        else
            output_mesh_info2_time(msh_i, level_set_function , tot_time);
           // output_mesh_info2(msh_i, level_set_function);


        // -------------------> DISCONTINUOUS GRADIENT IMPLEMENTATION <-------------------
        typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
        auto ls_cell = LS_cell_Bernstein_high_order< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
        // -------------------> CONTINUOUS GRADIENT IMPLEMENTATION <-------------------
        //typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
        //auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

        u_projected.set_agglo_mesh( msh_i );
        // CALCULATION OF AREA AND MASS AT TIME STEP t^n
        // CALCULATION ALSO OF CENTRE OF MASS


        /// DATA CHECK INITIALISATION
        T area0 = 0. , mass0 = 0.; // , global_mass0 = 0. ;
        T diff_area = 0. , diff_mass = 0. ;
        //T error_normal_global0 = 0. ;
        T centre_mass0_x = 0. , centre_mass0_y = 0. ;
        T perimeter0 = 0.;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;


        // PLOTTING OF NORMAL
        postprocess_output<double> postoutput_vec;
        auto vec_normal_disc = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_disc_Stokes_initial.dat");

        auto vec_normal_n_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes.dat");

        auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");
        //std::string filename_normal_interf_cont_grad = "normal_cont_grad_" + std::to_string(tot_time) + ".dat";
        //auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >(filename_normal_interf_cont_grad);

        postprocess_output<double> postoutput_div2;


        auto test_interface_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_interface_Stokes_initial.dat");
        auto test_interface_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_interface_Stokes_initial.dat");

        //auto test_curv_var_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_Stokes_curv_var_initial.dat");
        auto test_curv_var_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_Stokes_curv_var_initial.dat");
        //auto test_curv_var_cell  = std::make_shared< gnuplot_output_object<double> >("cell_limit_curv_var_initial.dat");

        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);


        std::vector<T> val_u_nx , val_u_ny , val_u_n , curvature_k0 ;

        std::vector< point<T, 2> > interface_points_plot ;
        std::vector< std::pair<T,T> > interface_normals_disc , interface_normals_n_cont , interface_normals_grad_cont , velocity_interface , velocity_field , points_vel_field;
        T divergence_error0 = 0. , divergence_error1 = 0. , divergence_error2 = 0.;


        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area0 += partial_area;
                auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass0 += qp.second * ls_cell(qp.first);
                    centre_mass0_x += qp.second * qp.first.x() ;
                    centre_mass0_y += qp.second * qp.first.y() ;
                }
            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                /*
                std::cout<<"CELL = "<<offset(msh,cl)<<std::endl;
                if(offset(msh,cl) == 101 || offset(msh,cl) == 104 )
                {
                    for(size_t kk = 0 ; kk < u_projected.sol_HHO.first.rows() ; kk++ )
                    std::cout<< u_projected.sol_HHO.first(kk,offset(msh,cl)) << " " << u_projected.sol_HHO.second(kk,offset(msh,cl)) << '\n';
                    std::cout<<'\n'<<std::endl;
                }
                */
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    curvature_k0.push_back(val0) ;
                    divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *interface_point );
                    divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_cont_grad( *interface_point );
                    divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                    Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_cont(*interface_point);
                    std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                    interface_normals_n_cont.push_back( normal_vec_cont ) ;
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;

                    Eigen::Matrix<T,2,1> normal_disc_val = ls_cell.normal_cont_normalised(*interface_point);
                    std::pair<T,T> normal_vec_disc = std::make_pair(normal_disc_val(0),normal_disc_val(1));
                    interface_normals_disc.push_back( normal_vec_disc ) ;
                    //std::cout<<"normal = "<<'\n'<<normal<<" , CONTIUOUS_normal = "<<'\n'<<normal_cont<<std::endl;



                    if( time_step == 0 )
                    {
                        test_interface_divergence0->add_data(*interface_point , val0);
                        test_interface_divergence1->add_data(*interface_point , val1);
                        test_interface_divergence2->add_data(*interface_point , val2);
                        vec_normal_disc->add_data(*interface_point,normal_vec_disc);
                        vec_normal_n_cont->add_data(*interface_point,normal_vec_cont);
                        vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);


                    }


                    perimeter0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();



                    normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );

                    interface_points_plot.push_back(*(interface_point)) ;
                    val_u_nx.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;
                    //std::cout<<"*(interface_point) = "<<*(interface_point)<<std::endl;
                    //std::cout<<" u_projected primo = "<<u_projected(*(interface_point)).first  << " u_projected second = "<< u_projected(*(interface_point)).second  << " somma tot con olds = "<<normal_interface_status<<std::endl;
                    //std::cout<<" ls_cell.normal(*(interface_point))(0)  = "<<ls_cell.normal(*(interface_point))(0)  << " ls_cell.normal(*(interface_point))(1)  = "<< ls_cell.normal(*(interface_point))(1)  << std::endl;

                    counter_interface_pts++;

                }

                T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));
                curvature_k0.push_back(val0) ;
                T val1 = ls_cell.divergence_cont(*(cl.user_data.interface.end()-1));
                T val2 = ls_cell.divergence_cont_grad(*(cl.user_data.interface.end()-1));
                divergence_error0 += pow((std::abs(val0) - 1.0/radius),2) ;
                divergence_error1 += pow((std::abs(val1) - 1.0/radius),2) ;
                divergence_error2 += pow((std::abs(val2) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals_grad_cont.push_back( normal_vec_grad_cont ) ;

                Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                interface_normals_n_cont.push_back( normal_vec_n_cont ) ;

                Eigen::Matrix<T,2,1> normal_disc_val = ls_cell.normal_cont_normalised(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_disc = std::make_pair(normal_disc_val(0),normal_disc_val(1));
                interface_normals_disc.push_back( normal_vec_disc ) ;

                velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;
                /// COSE  PER NORMALE CONTINUA
                /*
                Eigen::Matrix<T,2,1> normal_cont = ls_cell.normal_continuous(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_cont = std::make_pair(normal_cont(0),normal_cont(1));
                interface_normals_cont.push_back( normal_vec_cont ) ;

                 vec_normal_cont->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_cont);
                */



                if( time_step == 0 )
                {
                    test_interface_divergence0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    vec_normal_disc->add_data(*(cl.user_data.interface.end()-1) ,normal_vec_disc);
                    vec_normal_n_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_n_cont);
                    vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


                }


                normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);



                interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;
                val_u_nx.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );


                counter_interface_pts++;



            }
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }

        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        T val2 = ls_cell.divergence_cont_grad( *interface_point );

                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);
                        test_curv_var_divergence1->add_data(curv_var, val1);
                        test_curv_var_divergence2->add_data(curv_var, val2);
                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                T val1 = ls_cell.divergence_cont( *interface_point );
                                T val2 = ls_cell.divergence_cont_grad( *interface_point );

                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);
                                test_curv_var_divergence1->add_data(curv_var, val1);
                                test_curv_var_divergence2->add_data(curv_var, val2);

                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }



        if( time_step == 0 )
        {
            postoutput_div2.add_object(test_interface_divergence0);
            postoutput_div2.add_object(test_interface_divergence1);
            postoutput_div2.add_object(test_interface_divergence2);

            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_divergence1);
            postoutput_div2.add_object(test_curv_var_divergence2);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_disc);
            postoutput_vec.add_object(vec_normal_n_cont);
            postoutput_vec.add_object(vec_normal_grad_cont);
            postoutput_vec.write();

        }
        if( time_step > 0)
        {
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();
        }


        std::cout<<"NOTICE:--> The terms u cdot n are made with n = normal (NO CONTINUOUS)."<<std::endl;

        //goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont ) ; // GOAL QUANTITIES PLOT JUST THE GRADIENT CONTINUOUS QUANTITIES
        goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont , velocity_interface , velocity_field , points_vel_field ) ; // GOAL QUANTITIES PLOT JUST THE GRADIENT CONTINUOUS QUANTITIES


        testing_level_set_time(msh,level_set_function,tot_time); // IT PLOT JUST THE PROFILE
        /*
        if( time_step == 0 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }


        if( time_step == 5 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 10 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 15 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 20 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        if( time_step == 30 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }

        if( time_step == 40 ){
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals ) ;
            testing_level_set_time(msh,level_set_function,tot_time);
        }
        */

        divergence_error0 /= counter_interface_pts;
        divergence_error0 = sqrt(divergence_error0);

        divergence_error1 /= counter_interface_pts;
        divergence_error1 = sqrt(divergence_error1);

        divergence_error2 /= counter_interface_pts;
        divergence_error2 = sqrt(divergence_error2);
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error0 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error1 <<std::endl;
        std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< dt*time_step <<" is " << divergence_error2 <<std::endl;


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<yellow<<bold<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;
        if(time_step == 0)
            check = 10.0;
        else
            check = normal_interface_status ;

        std::cout << "Area at time step: "<<tot_time<<" is "<< area0  << reset << std::endl;
        std::cout  << "Internal mass at time step: "<<tot_time<<" is "<<reset<< mass0   << std::endl;
        //std::cout<<bold<<yellow << "GLOBAL Mass at time step: "<<time_step<<" is "<<reset<<global_mass0<< reset << std::endl;
         std::cout << "CENTRE OF MASS at time step: " <<tot_time<<" is "<<" ( "<< centre_mass0_x/area0  << " , "<< centre_mass0_y/area0 <<" ). " << reset << std::endl;

         d_a = sqrt(4.0*area0/M_PI) ;

        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter0 <<std::endl;

        std::cout<<yellow<<bold<<"The CIRCULARITY, at time "<< tot_time <<" is "<<reset << M_PI*d_a/perimeter0 <<std::endl;



        if(time_step == 0 ){
            initial_area  = area0 ;
            initial_mass = mass0 ;
            centre_mass_x_inital = centre_mass0_x ;
            centre_mass_y_inital = centre_mass0_y ;
            perimeter_initial = perimeter0 ;
        }

        if(time_step > 0 )
        {
            diff_area = (area0 - initial_area)/initial_area ;
            diff_mass = (std::abs((mass0 - initial_mass)))/(std::abs(initial_mass)) ;
            std::cout << bold << yellow << "Normalised difference in Area (new - old)/old at time step: "<<tot_time<<" is "<<reset<< diff_area  << reset << std::endl;
            std::cout << bold << yellow << "Difference in internal MASS |new - old|/|old| at time step: "<<tot_time<<" is "<<reset<< diff_mass  << reset << std::endl;

            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass0_x/area0 - centre_mass_x_inital/initial_area <<" , " << centre_mass0_y/area0 - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time " << tot_time <<" is " << (perimeter0 - perimeter_initial)/perimeter_initial <<std::endl;

        }


        tc_agglo.toc();
        std::cout << bold << yellow << "------> TIME FOR CHECKING GOAL QUANTITIES: " << tc_agglo << " seconds" << reset << std::endl;
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

/// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE
        /*
        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
        */
        bool sym_grad = TRUE;

        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);


        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);

        auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);

        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

        tc_agglo.tic();

        if(solve_interface){
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step );
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        tc_agglo.toc();
        std::cout << bold << yellow << "TIME-----> run_cuthho_interface_velocity: " << tc_agglo << " seconds" << reset << std::endl;


        /*********************** FEM -  PROCESSING **************************/
        /// ORA HO SMOOTH OPERATOR! USE L2 PROJECTION

        if( 1 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: OLD OPERATOR FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<yellow<<bold<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<reset<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }


        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );


        testing_velocity_field_L2projected(msh , u_prova) ;

        //std::cout<<"CHECK SMOOTH CONVERTING  FEM ----> FIRST"<<'\n'<<(u_prova.sol_FEM.first - u_projected.sol_FEM.first)<<'\n' <<std::endl;
        //std::cout<<"CHECK SMOOTH CONVERTING FEM ----> SECOND"<<'\n'<<(u_prova.sol_FEM.second - u_projected.sol_FEM.second)<<'\n' <<std::endl;

        testing_velocity_field(msh , u_projected) ;
        */

        testing_velocity_field(msh , u_projected) ;

        //check_inlet( msh , fe_data ,  u_projected , 1e-14 );
        //std::cout<<"u_projected.sol_FEM.first = "<<'\n'<<u_projected.sol_FEM.first <<std::endl;
        //std::cout<<"u_projected.sol_FEM.second = "<<'\n'<<u_projected.sol_FEM.second <<std::endl;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt1 = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt1 = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        T dt2 = 0.1;
        dt = std::min(dt1 , dt2);
        std::cout<<"MAX dt = "<<dt<<" AND HEURISTIC CFL IS "<<dt1<<std::endl;

        /*
        if(high_order)
            run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        else
            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT( level_set_function.msh , fe_data , level_set_function , u_projected , dt);
        */

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;

        T sub_dt = std::min(4*1e-4 , dt ) ;
        /*
        T sub_dt;
        if(tot_time <0.132)
            sub_dt = std::min(4*1e-4 , dt ) ;
        else
            sub_dt = std::min(5*1e-5 , dt ) ;
        */
        std::cout<<"Implemented dt = "<<dt<<std::endl;
        while( (sub_time < sub_dt*10) && (sub_time < dt1) )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<yellow<<bold<<"SUB TIME REPETITION OF TRANSPORT PB DATA:"<<reset<<" sub_dt = "<<sub_dt<< " , number time steps = "<<sub_time/sub_dt<<std::endl;

        tot_time += sub_time ;

        testing_level_set2(msh,level_set_function);

        /// OLD IMPLEMENTATION
        //for(size_t j=1; j<4 ; j++)
        //run_FEM_levelset( level_set_function.msh,degree_FEM,level_set_function,u,dt,mip);

        /************** FEM -  POST-PROCESSING **************/
        if( (T_N - time_step)==0 )
        {
            // Updating continuous normal function
            level_set_function.normal_continuous_setting();
            level_set_function.gradient_continuous_setting() ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            Mesh msh_i2 =  crr_mesh.current_mesh;
            offset_definition(msh_i2);
            tc.tic();
            detect_node_position3(msh_i2, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i2, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                // std::cout<<"i m here 1"<<std::endl;
                detect_cut_cells3(msh_i2, level_set_function); // In cuthho_geom

                detect_cell_agglo_set(msh_i2, level_set_function); // Non serve modificarla

                make_neighbors_info_cartesian(msh_i2); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i2, level_set_function); // Non serve modificarla
            }
            else
            {
                //move_nodes(msh_i2, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i2, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i2, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i2);
                output_mesh_info(msh_i2, level_set_function);
            }

            output_mesh_info2_time(msh_i2, level_set_function,tot_time);
            //output_mesh_info2(msh_i2, level_set_function);
            // IN cuthho_export..Points/Nodes don't change

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i2;
            u_projected.set_agglo_mesh( msh_i2 );


            T mass_fin = 0. , area_fin = 0. ;
            T centre_mass_x = 0. , centre_mass_y = 0. ;

            T perimeter = 0. ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;


            postprocess_output<double> postoutput_vec;
            auto vec_normal_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_Stokes_final.dat");
            auto vec_normal_n_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_n_Stokes_final.dat");

            auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

            postprocess_output<double> postoutput_div2;
            auto test_interface_divergence_fin0  = std::make_shared< gnuplot_output_object<double> >("k0_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin1  = std::make_shared< gnuplot_output_object<double> >("k1_fin_divergence_interface_Stokes_final.dat");
            auto test_interface_divergence_fin2  = std::make_shared< gnuplot_output_object<double> >("k2_fin_divergence_interface_Stokes_final.dat");


            //auto test_curv_var_divergence0  = std::make_shared< gnuplot_output_object<double> >("k0_divergence_Stokes_curv_var_final.dat");
            auto test_curv_var_divergence1  = std::make_shared< gnuplot_output_object<double> >("k1_divergence_Stokes_curv_var_final.dat");
            auto test_curv_var_divergence2  = std::make_shared< gnuplot_output_object<double> >("k2_divergence_Stokes_curv_var_final.dat");
            //auto test_curv_var_cell  = std::make_shared< gnuplot_output_object<double> >("cell_limit_curv_var_initial.dat");

            std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(tot_time) + ".dat";
            auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
            std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(tot_time) + ".dat";
            auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);




            std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
            std::vector< point<T, 2> > interface_points_plot_fin ;
            std::vector< std::pair<T,T> > interface_normals_fin ,interface_normals_n_cont_fin ,interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field;

            T divergence_error_fin0 = 0. , divergence_error_fin1 = 0. , divergence_error_fin2 = 0.;



            for(auto& cl : msh_i2.cells)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);

                if( (location(msh_i2, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i2, cl) == element_location::ON_INTERFACE) )
                {

                    T partial_area = measure( msh_i2, cl, element_location::IN_NEGATIVE_SIDE);

                    area_fin += partial_area;


                    auto qps_fin = integrate( msh_i2 , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                    for(auto& qp:qps_fin){
                        mass_fin += qp.second * ls_cell(qp.first);
                        centre_mass_x += qp.second * qp.first.x() ;
                        centre_mass_y += qp.second * qp.first.y() ;
                    }

                }
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {

                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {
                        perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                        normal_interface_status += pow( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) , 2 );


                        T val0 = ls_cell.divergence( *interface_point );
                        divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;
                        T val1 = ls_cell.divergence_cont( *interface_point );
                        divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;
                        T val2 = ls_cell.divergence_cont_grad( *interface_point );
                        divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                        Eigen::Matrix<T,2,1> normal = ls_cell.normal(*interface_point);
                        std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                        interface_normals_fin.push_back( normal_vec ) ;

                        Eigen::Matrix<T,2,1> normal_cont_n = ls_cell.normal_cont(*interface_point);
                        std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_cont_n(0),normal_cont_n(1));
                        interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                        Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_cont_normalised(*interface_point);
                        std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                        interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;

                        vec_normal_fin->add_data(*interface_point,normal_vec);
                        vec_normal_n_cont_fin->add_data(*interface_point,normal_vec_n_cont);
                        vec_normal_grad_cont_fin->add_data(*interface_point,normal_vec_grad_cont);
                        test_interface_divergence_fin0->add_data( *interface_point , val0);
                        test_interface_divergence_fin1->add_data( *interface_point , val1);
                        test_interface_divergence_fin2->add_data( *interface_point , val2);

                        interface_points_plot_fin.push_back( *(interface_point) ) ;
                        val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                        val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                        val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                        velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;


                        counter_interface_pts++;
                    }

                    T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin0 += pow((std::abs(val0) - 1.0/radius),2) ;

                    T val1 = ls_cell.divergence_cont( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin1 += pow((std::abs(val1) - 1.0/radius),2) ;

                    T val2 = ls_cell.divergence_cont_grad( *(cl.user_data.interface.end()-1) );
                    divergence_error_fin2 += pow((std::abs(val2) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal = ls_cell.normal(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec = std::make_pair(normal(0),normal(1));
                    interface_normals_fin.push_back( normal_vec ) ;

                    Eigen::Matrix<T,2,1> normal_n_cont = ls_cell.normal_cont(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_n_cont = std::make_pair(normal_n_cont(0),normal_n_cont(1));
                    interface_normals_n_cont_fin.push_back( normal_vec_n_cont ) ;

                    Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal_cont_normalised(*(cl.user_data.interface.end()-1));
                    std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                    interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;

                    vec_normal_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec);
                    vec_normal_n_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_n_cont);
                    vec_normal_grad_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_grad_norm);
                    test_interface_divergence_fin0->add_data( *(cl.user_data.interface.end()-1) ,val0 );
                    test_interface_divergence_fin1->add_data( *(cl.user_data.interface.end()-1) ,val1 );
                    test_interface_divergence_fin2->add_data( *(cl.user_data.interface.end()-1) ,val2 );

                    normal_interface_status += pow( u_projected (*(cl.user_data.interface.end()-1) ).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*( cl.user_data.interface.end()-1) ).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1), 2);

                    interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                    val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                    val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                    val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                    counter_interface_pts++;

                }
                for(auto& pt : points(msh_i,cl))
                {
                    points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                    velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

                }


            }

            bool first_cut_cell_found = FALSE ;
            T distance_pts = 0.0;
            point<T,2> first_point ;
            point<T,2> cell_end_point;
            for(auto& cl : msh_i.cells)
            {

                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    if(!first_cut_cell_found)
                    {
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                        {
                            T val0 = ls_cell.divergence( *interface_point );
                            T val1 = ls_cell.divergence_cont( *interface_point );
                            T val2 = ls_cell.divergence_cont_grad( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);
                            test_curv_var_divergence1->add_data(curv_var, val1);
                            test_curv_var_divergence2->add_data(curv_var, val2);
                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        first_cut_cell_found = TRUE;
                        first_point = *cl.user_data.interface.begin() ;
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }
                    else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                    {
                        for(auto& cl : msh_i.cells)
                        {
                            if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                            {
                                ls_cell.cell_assignment(cl);
                                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                                {

                                    T val0 = ls_cell.divergence( *interface_point );
                                    T val1 = ls_cell.divergence_cont( *interface_point );
                                    T val2 = ls_cell.divergence_cont_grad( *interface_point );

                                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                                    if( interface_point == cl.user_data.interface.begin() )
                                        test_curv_var_cell->add_data(curv_var, val0);

                                    test_curv_var_divergence0->add_data(curv_var, val0);
                                    test_curv_var_divergence1->add_data(curv_var, val1);
                                    test_curv_var_divergence2->add_data(curv_var, val2);

                                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                                }
                                cell_end_point = *(cl.user_data.interface.end() -1) ;
                            }

                        }

                    }
                    else
                        break;

                }

            }





            postoutput_div2.add_object(test_interface_divergence_fin0);
            postoutput_div2.add_object(test_interface_divergence_fin1);
            postoutput_div2.add_object(test_interface_divergence_fin2);
            postoutput_div2.add_object(test_curv_var_divergence0);
            postoutput_div2.add_object(test_curv_var_divergence1);
            postoutput_div2.add_object(test_curv_var_divergence2);
            postoutput_div2.add_object(test_curv_var_cell);

            postoutput_div2.write();

            postoutput_vec.add_object(vec_normal_fin);
            postoutput_vec.add_object(vec_normal_n_cont_fin);
            postoutput_vec.add_object(vec_normal_grad_cont_fin);
            postoutput_vec.write();
            goal_quantities_time(msh , tot_time, interface_points_plot , val_u_nx , val_u_ny , val_u_n , interface_normals_grad_cont , velocity_interface , velocity_field , points_vel_field ) ;
            //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
            testing_level_set_time(msh,level_set_function, tot_time);
            /*
            if( time_step == 9 ){
                goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
                testing_level_set_time(msh,level_set_function, tot_time);
            }
            */
            divergence_error_fin0 /= counter_interface_pts;
            divergence_error_fin0 = sqrt(divergence_error_fin0);

            divergence_error_fin1 /= counter_interface_pts;
            divergence_error_fin1 = sqrt(divergence_error_fin1);

            divergence_error_fin2 /= counter_interface_pts;
            divergence_error_fin2 = sqrt(divergence_error_fin2);

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin0 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin1 <<std::endl;

            std::cout<<yellow<<bold<<"The l2 error of the CURVATURE at the INTERFACE, at time "<<reset<< tot_time <<" is " << divergence_error_fin2 <<std::endl;

            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<yellow<<bold<<"The l2 error of u*n over the INTERFACE, at time "<<reset<< tot_time <<" is " << normal_interface_status << std::endl;



            std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter <<std::endl;

            std::cout<<"perimeter = "<< perimeter << " AND  perimeter0 =  "<<perimeter_initial<<std::endl;
            std::cout<< bold << yellow<<"NORMALISED DIFFERENCE PERIMETER, at time "<<reset<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

            d_a = sqrt(4.0*area_fin/M_PI) ;

            std::cout<< bold << yellow<<"The CIRCULARITY, at time "<< tot_time<<reset <<" is " << M_PI*d_a/perimeter <<std::endl;

            std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
            std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

            std::cout << bold << yellow << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< reset<< (area_fin - initial_area)/initial_area << std::endl;
            std::cout << bold << yellow << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< reset<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
            std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
            std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
            std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) << std::endl;



        } // END OF T = FINAL TIME

        time_pos +=dt ;
        //time_step++;
    } // End of the temporal loop

    std::cout<< bold << yellow <<"FINAL TIME IS t = "<< reset<<tot_time<<std::endl;
    return 0;
}
#endif



// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 29/09/2020 -> GRAD CONTINUOS IMPLEMENTATION (IMAGES CHECKING FOR CONTINUOUS STUFF)
// -----> dt_M (CHECK OF THE MAXIMUM TIME STEP)
// ---- > normal_interface_status CORRECT !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);




    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"degree FEM "<<degree_FEM<<std::endl;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/9.0;
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/9.0-eps_circ;
        radius_b = 1.0/9.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    radius = 0.31 ;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;

    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);

    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    level_set_function.gradient_continuous_setting() ;

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ; // SE MAPPING QUI è falso DEVO FARLO DENTRO IL TRANSPORT PB
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);
    //Mesh msh_tmp =  crr_mesh.current_mesh;  // MESH at t=t^n+1 (FOR POST-PROCESSING)
    //offset_definition(msh_tmp);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.; // Initialisation Area , Mass for t = 0
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    // NOTICE: The sequential detect_node_position3 is faster than the parallel one: PROVED IN DEBUG MOD, IN RELEASE WILL IT BE THE SAME???
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom

    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        move_nodes(msh_i, level_set_function);
        //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface2(msh_i, level_set_function, int_refsteps);
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
    }

    tc.toc();
    std::cout << bold << yellow <<'\n' <<"-----> TIME -----> cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }


    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    level_set_function.gradient_continuous_setting() ;

    //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;

    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();


    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    postprocess_output<double> postoutput_vec;
    auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    T divergence_error = 0. ;
    size_t counter_interface_pts = 0;

    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
            {


                T val0 = ls_cell.divergence( *interface_point );
                divergence_error += pow((std::abs(val0) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);

                perimeter_initial += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                interface_points_plot.push_back(*(interface_point)) ;


                counter_interface_pts++;

            }

            T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));
            divergence_error += pow((std::abs(val0) - 1.0/radius),2) ;

            Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
            std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
            interface_normals.push_back( normal_vec_grad_cont ) ;

            vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;



            counter_interface_pts++;

        }



    }

    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() )
                        test_curv_var_cell->add_data(curv_var, val0);

                    test_curv_var_divergence0->add_data(curv_var, val0);

                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                    {
                        ls_cell.cell_assignment(cl);
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.write();

    postoutput_vec.add_object(vec_normal_grad_cont);
    postoutput_vec.write();

    divergence_error /= counter_interface_pts;
    divergence_error = sqrt(divergence_error);
    std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << divergence_error <<std::endl;
    std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;

    std::cout << "Initial time, AREA  = "<< initial_area << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    tc_initial.toc();
    std::cout << "Machine Time for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;







    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {


        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        testing_level_set_time(msh,level_set_function,tot_time);



        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);


        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);

        //auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        timecounter tc_u ;
        tc_u.tic();

        if(solve_interface){
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step);
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        tc_u.toc();
        std::cout << "Machine Time for checking INITAL GOAL QUANTITIES: " << tc_u << " seconds" << std::endl;
        std::cout << "Machine Time for solving STOKES PB: " << tc_u << " seconds" << std::endl;


        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if( 1 )
        {
            std::cout<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<"------------------>>>> NOTICE: OLD OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }
        testing_velocity_field(msh , u_projected) ;
        /*
        auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        u_prova.sol_HHO = u_projected.sol_HHO ;
        u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        testing_velocity_field_L2projected(msh , u_prova) ;
        */



        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------

        auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        T dt_M = 4*1e-3;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt_one_cell = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) dt_CFL = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;
        /*
        T sub_dt;
        if(tot_time <0.132)
            sub_dt = std::min(4*1e-4 , dt ) ;
        else
            sub_dt = std::min(5*1e-5 , dt ) ;
        */
        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else
                run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        tot_time += sub_time ;


       /**************************************************   POST-PROCESSING **************************************************/


        // Updating continuous normal function
        level_set_function.gradient_continuous_setting() ;
        // Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
            refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i2, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh( msh_i );


        T max_u_n_val = 0.0 ;
        T max_u_n_val_abs = 0.0 ;
        T normal_interface_status = 0. ;
        size_t counter_interface_pts = 0;
        for(auto& cl : msh_i.cells)
        {
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                    max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                    if( std::abs(u_n_val) == max_u_n_val_abs )
                        max_u_n_val = u_n_val ;

                    normal_interface_status += pow(u_n_val,2.0);
                    counter_interface_pts ++ ;

                }
            }
        }

        if( time_step == 0 )
            max_u_n_val_new = max_u_n_val ;

        if(time_step > 0 )
        {
            max_u_n_val_old = max_u_n_val_new ;
            max_u_n_val_new = max_u_n_val ;
            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;
        }

        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        normal_interface_status /= counter_interface_pts;
        normal_interface_status = sqrt(normal_interface_status);
        std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << normal_interface_status << std::endl;



        if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && max_u_n_val_new > max_u_n_val_old )
        {
            std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
            //exit(9) ;
        }

        if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )
        {




            // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
            // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
            T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
            T dt_new = std::min(dt_one_cell , dt_M_new);

            bool forward = TRUE ;
            if( forward ) // GO FORWARD FROM THE TIME t^n
            {
                dt = dt_new ;

                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                tot_time -= sub_time ; // I erase the time previously calculated
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;
                /*
                T sub_dt;
                if(tot_time <0.132)
                    sub_dt = std::min(4*1e-4 , dt ) ;
                else
                    sub_dt = std::min(5*1e-5 , dt ) ;
                */
                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , sub_dt , mapping );
                    }
                    else{
                        run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , sub_dt);
                    }

                    sub_time += sub_dt ;

                }

                tot_time += sub_time ; // the new time is substracted
                level_set_function = level_set_tmp ;
                //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
            }
            else // GO BACKWARD FROM THE TIME t^n + dt_M
            {

                dt = dt_M - dt_new ;
                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;
                /*
                T sub_dt;
                if(tot_time <0.132)
                    sub_dt = std::min(4*1e-4 , dt ) ;
                else
                    sub_dt = std::min(5*1e-5 , dt ) ;
                */
                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    if(high_order){
                        T neg_time = -sub_dt ;
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , neg_time , mapping );
                    }
                    else{
                        T neg_time = -sub_dt ;
                        run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , neg_time);
                    }

                    sub_time += sub_dt ;

                }

                tot_time -= sub_time ; // the new time is substracted

            }


            //-------------------------- NEW CALCULATION OF U*N --------------------------

            // Updating continuous normal function
            level_set_function.gradient_continuous_setting() ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);

            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            }
            else
            {
                move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << bold << yellow << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << reset << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i;
            u_projected.set_agglo_mesh( msh_i );


            T max_u_n_val = 0.0 ;
            T max_u_n_val_abs = 0.0 ;
            normal_interface_status = 0. ;
            counter_interface_pts = 0;
            for(auto& cl : msh_i.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        if( std::abs(u_n_val) == max_u_n_val_abs )
                            max_u_n_val = u_n_val ;

                        normal_interface_status += pow(u_n_val,2.0);
                        counter_interface_pts ++ ;

                    }
                }
            }


            max_u_n_val_new = max_u_n_val ;


            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
            normal_interface_status /= counter_interface_pts;
            normal_interface_status = sqrt(normal_interface_status);

            std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << normal_interface_status << std::endl;




        }

        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------
        check = normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE
        /*
        if(check < 1e-8 )
        {
            std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
            return 0;
        }
        */


        output_mesh_info2_time(msh_i, level_set_function,tot_time);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T divergence_error_fin = 0. ;
        T perimeter = 0. ;



        // PLOTTING OF NORMAL

        postprocess_output<double> postoutput_vec;
        auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

        postprocess_output<double> postoutput_div2;

        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

        std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
        std::vector< point<T, 2> > interface_points_plot_fin ;
        std::vector< std::pair<T,T> > interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field;





        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
            {

                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                auto qps_fin = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                for(auto& qp:qps_fin){
                    mass_fin += qp.second * ls_cell(qp.first);
                    centre_mass_x += qp.second * qp.first.x() ;
                    centre_mass_y += qp.second * qp.first.y() ;
                }

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    T val0 = ls_cell.divergence( *interface_point );
                    divergence_error_fin += pow((std::abs(val0) - 1.0/radius),2) ;

                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal_disc(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                    interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;
                    vec_normal_grad_cont_fin->add_data(*interface_point,normal_vec_grad_cont);

                    interface_points_plot_fin.push_back( *(interface_point) ) ;
                    val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;


                    //    counter_interface_pts++;
                }

                T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                divergence_error_fin += pow((std::abs(val0) - 1.0/radius),2) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal_disc(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;

                vec_normal_grad_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_grad_norm);


                interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                //    counter_interface_pts++;

            }
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }


        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);

                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);


                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }


        postoutput_div2.add_object(test_curv_var_divergence0);
        postoutput_div2.add_object(test_curv_var_cell);
        postoutput_div2.write();


        postoutput_vec.add_object(vec_normal_grad_cont_fin);
        postoutput_vec.write();

        goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field ) ;
            //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
        if(time_step == T_N)
            testing_level_set_time(msh,level_set_function, tot_time);


        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        divergence_error_fin /= counter_interface_pts;
        divergence_error_fin = sqrt(divergence_error_fin);



        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << divergence_error_fin <<std::endl;






        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << reset << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) << std::endl;



    } // End of the temporal loop

    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;
    return 0;
}
#endif



// ------------------------------------ CONVERGENCE ANALYSIS -------------------------------------
#if 1 // CONVERGENCEEEEE
int main(int argc, char **argv)
{
    size_t degree_para      = 1;
    size_t int_refsteps     = 0;
    size_t degree_FEM       = 2;
    int ch;
    while ( (ch = getopt(argc, argv, "q:l:r:")) != -1 )
    {
        switch(ch)
        {
            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'l':
                degree_para = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;

//    convergence_test(); // GUILLAUME APPLICATION
//    convergence_test_normal_error(degree_para,int_refsteps); // STEFANO APPLICATION: STATIC BUBBLE ANALYTIC
    
//    convergence_test_normal_error_numerical_ls(degree_FEM,degree_para,int_refsteps); // STEFANO APPLICATION: STATIC BUBBLE NUMERICAL
    convergence_test_normal_error_numerical_ls_test_best_ls(degree_FEM,degree_para,int_refsteps);
    
    //convergence_test_normal_error_case1(); // curvature const(case 1)
    //convergence_test_normal_error_case2(); // curvature const(case 2)
    // tests_stabilization();
    // interface_residus();
    return 1;
}
#endif



// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 03/11/2020 -> (GRADIENT AND NORMAL CONTINUOUS + DIVERGENCE CONT/DISC )
#if 0 // CASE 1
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    size_t T_N = 0;
    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Mesh size = "<<mip.Nx<<"x"<<mip.Ny<<std::endl;
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

    
    auto cl = msh.cells[38];
    cell_basis_Lagrange_1d_reference<Mesh,RealType> cb_l(msh, cl, 3);
    RealType pt0 = 0.5;
    RealType pt1 = 0.0;
    RealType pt2 = 1.0;
    auto val0l = cb_l.eval_basis_1d(pt0) ;
    //auto val_physic0l = cb_l.eval_basis_curv(pt0);
    std::cout<<"val0l = "<<val0l<<std::endl;
    //std::cout<<"val_physic0l = "<<val_physic0l<<std::endl;
    
    auto val1l = cb_l.eval_basis_1d(pt1) ;
    //auto val_physic1l = cb_l.eval_basis_curv(pt1);
    std::cout<<"val1l = "<<val1l<<std::endl;
    //std::cout<<"val_physic1l = "<<val_physic1l<<std::endl;
    
    auto val2l = cb_l.eval_basis_1d(pt2) ;
    //auto val_physic2l = cb_l.eval_basis_curv(pt2);
    std::cout<<"val2l = "<<val2l<<std::endl;
    //std::cout<<"val_physic2l = "<<val_physic2l<<std::endl;
              
    auto val0ldd = cb_l.eval_double_derivative_1d(pt0) ;
    std::cout<<"val0ldd = "<<val0ldd<<std::endl;
    auto val1ldd = cb_l.eval_double_derivative_1d(pt1) ;
    std::cout<<"val1ldd = "<<val1ldd<<std::endl;
    auto val2ldd = cb_l.eval_double_derivative_1d(pt2) ;
    std::cout<<"val2ldd = "<<val2ldd<<std::endl;
              
      
              
    auto derval0l = cb_l.eval_gradients_1d(pt0) ;
    std::cout<<"derval0l = "<<derval0l<<std::endl;
    //auto val_physicder0l = cb_l.eval_gradients_curv(0.0);
    //          std::cout<<"val_physicder0l = "<<val_physicder0l<<std::endl;
    auto derval1l = cb_l.eval_gradients_1d(pt1) ;
    std::cout<<"derval1l = "<<derval1l<<std::endl;
    //          auto val_physicder1l = cb_l.eval_gradients_curv(1.0);
    //          std::cout<<"val_physicder1l = "<<val_physicder1l<<std::endl;
    auto derval2l = cb_l.eval_gradients_1d(pt2) ;
    std::cout<<"derval2l = "<<derval2l<<std::endl;
      //        auto val_physicder2l = cb_l.eval_gradients_curv(-1.0);
     //         std::cout<<"val_physicder2l = "<<val_physicder2l<<std::endl;
   
    
    
    /**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
    //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t  degree_gradient = degree_FEM - 1 ;
    auto fe_data_gradient = Finite_Element<RealType,Mesh>( msh , degree_gradient , mip ) ;
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;

    size_t  degree_div = degree_FEM - 1 ;
    std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
    auto fe_data_div = Finite_Element<RealType,Mesh>( msh , degree_div , mip ) ;
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;
    bool flower = false ;
    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/3.0-eps_circ;
        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    
    std::cout<<"Initial interface: CIRCLE"<<std::endl;
    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    typedef  circle_level_set<T> Fonction;
    
    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    /*
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;
    flower = true ;
     
    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //std::cout<<"Initial interface: ELLIPSE"<<std::endl;
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;
     
      */


    /**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/


    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;
    auto level_set_function = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );
    
    
    typedef Level_set_berstein< Mesh , Fonction , FiniteSpace , T > Level_Set;
    T degree_curve = 3 ;
    auto curve = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
   
    
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
   //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);



     // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
    // IF DIVERGENCE CONTINUOUS
    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

    /************** LEVEL SET  MAPPING **************/
    // If mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    bool mapping = false ;
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );



    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.;
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
        make_agglomeration_no_double_points(msh_i, level_set_function,degree_curve);
        //make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        //move_nodes(msh_i, level_set_function);
        //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }

    
    for(auto& cl : msh_i.cells)
    {
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            if(0)
            {
                auto msh_int =  integration_mesh<T>(degree_curve);
                msh_int.set_cell(cl);
                cl.user_data.integration_msh = msh_int ;
            }
            else
                cl.user_data.integration_msh.set_cell_new(cl,degree_curve);
            
            for(auto& cl_i : cl.user_data.integration_msh.cells)
            {
                std::cout<<"cl = "<<offset(cl.user_data.integration_msh,cl_i)<<std::endl;
                auto pts = points( cl.user_data.integration_msh , cl_i);
                auto nds = nodes( cl.user_data.integration_msh , cl_i);
                for(auto& pt: pts)
                    std::cout<<"pt = "<<'\n'<<pt<<std::endl;
                for(auto& nd: nds)
                    std::cout<<"nd = "<<'\n'<<nd<<std::endl;
                std::cout<<'\n'<<std::endl;
            }
            
        }
        
    }
    
    /*
    for(auto& cl : msh_i.cells)
    {
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            
            auto msh_int =  integration_mesh_cl<T,typename Mesh::cell_type >(cl,degree_curve);
            cl.user_data.integration_msh = msh_int ;
        }
        
    }
    */

    

    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
    // IF DIVERGENCE CONTINUOUS
    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

    
    //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
    //typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
     //typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > Level_Set;

    // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\
    // IF grad cont -> normal cont -> (divergence disc) -> divergence cont
    auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    // IF grad cont -> normal cont -> divergence disc
    //auto ls_cell = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    // IF grad cont -> normal cont -> divergence disc
    //auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();
    
    
    // ---------------------------------- CHECK bernstein 1d  -----------------------------------
    T tot = degree_curve ; // 100
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para.dat");
     auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para.dat");
    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            curve.cell_assignment(cl);
            auto pts_int = cl.user_data.interface ;
            auto pts = points(msh, cl);
            /*
            std::cout<<"Cell "<<offset(msh_i,cl)<<" pts:"<<std::endl;
            auto pts = points(msh, cl);
            for(auto& pt : pts)
                std::cout<<pt<<std::endl;
            std::cout<<"Interfacea pts:"<<std::endl;
            
            for(auto& pt : pts_int)
                std::cout<<pt<<std::endl;
                       
            std::cout<<'\n'<<std::endl;
            */
             if( pts_int.size() == degree_curve + 1 ) // if( curve.subcells.size()<1 )
             {
                //std::cout<<"curve.subcells.size() = "<<curve.subcells.size()<<std::endl;
                for(int i= 0; i <= tot ; i++)
                {
                    T pos = 0.0+i/tot ;
                     interface_gamma.push_back( curve(pos,msh_i,cl) ) ;
                    //std::cout<<"pos = "<<pos<<" , curve(pos,msh_i,cl) = "<<curve(pos,msh_i,cl)<<std::endl;
                    point<T,2> curv_var0 = point_type(curve(pos,msh_i,cl)(0), curve(pos,msh_i,cl)(1));
                    interface_gamma_plot->add_data(curv_var0,0.0);
                    curvature_plot->add_data(curv_var0,curve.curvature(pos, msh_i, cl));
                    curvature_gamma.push_back( curve.curvature(pos,msh_i,cl) ) ;
                    tangent_gamma.push_back( curve.tangent(pos,msh_i,cl) ) ;
                    normal_gamma.push_back( curve.normal(pos,msh_i,cl) ) ;
                }
                /*
                interface_gamma.push_back( curve(0,msh_i,cl) ) ;
                interface_gamma.push_back( curve(1,msh_i,cl) ) ;
                interface_gamma.push_back( curve(-1,msh_i,cl)) ;
                point<T,2> curv_var0 = point_type(curve(0,msh_i,cl)(0), curve(0,msh_i,cl)(1));
                point<T,2> curv_var1 = point_type(curve(1,msh_i,cl)(0), curve(1,msh_i,cl)(1));
                point<T,2> curv_var2 = point_type(curve(-1,msh_i,cl)(0), curve(-1,msh_i,cl)(1));
                
                interface_gamma_plot->add_data(curv_var0,0.0);
                interface_gamma_plot->add_data(curv_var1,0.0);
                interface_gamma_plot->add_data(curv_var2,0.0);
                 */
            }
            else
            {
                size_t tot_cls = (pts_int.size()-1)/ (degree_curve )  ;
                //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                    //std::cout<<"curve.subcells.size() = "<<curve.subcells.size()<<" , cell_ind = "<<cell_ind<<std::endl;
                    
                    for(int i= 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        //if(i== 0 && cell_ind>0)
                        //    continue;
                        //std::cout<<"pos = "<<pos<<" , curve(pos,msh_i,cl) = "<<curve(pos,msh_i,cl,cell_ind)<<std::endl;
                         interface_gamma.push_back( curve(pos,msh_i,cl,cell_ind) ) ;
                        point<T,2> curv_var0 = point_type(curve(pos,msh_i,cl,cell_ind)(0), curve(pos,msh_i,cl,cell_ind)(1));
                        interface_gamma_plot->add_data(curv_var0,0.0);
                        curvature_plot->add_data(curv_var0,curve.curvature(pos, msh_i, cl,cell_ind));
                        curvature_gamma.push_back( curve.curvature(pos,msh_i,cl,cell_ind) ) ;
                        tangent_gamma.push_back( curve.tangent(pos,msh_i,cl,cell_ind) ) ;
                        normal_gamma.push_back( curve.normal(pos,msh_i,cl,cell_ind) ) ;
                        /*
                        if(offset(msh_i,cl)==65)
                        {
                            std::cout<<"curvature = "<<curve.curvature(pos,msh_i,cl,cell_ind)<<" , tangent = "<<curve.tangent(pos,msh_i,cl,cell_ind)<<" , nromal = "<<curve.normal(pos,msh_i,cl,cell_ind)<<std::endl;
                        }
                         */
                        
                    }
                    /*
                    interface_gamma.push_back( curve(0,msh_i,cl,cell_ind) ) ;
                    interface_gamma.push_back( curve(1,msh_i,cl,cell_ind) ) ;
                    interface_gamma.push_back( curve(-1,msh_i,cl,cell_ind)) ;
                    
                    point<T,2> curv_var0 = point_type(curve(0,msh_i,cl)(0), curve(0,msh_i,cl)(1));
                    point<T,2> curv_var1 = point_type(curve(1,msh_i,cl)(0), curve(1,msh_i,cl)(1));
                    point<T,2> curv_var2 = point_type(curve(-1,msh_i,cl)(0), curve(-1,msh_i,cl)(1));
                    
                    interface_gamma_plot->add_data(curv_var0,0.0);
                    interface_gamma_plot->add_data(curv_var1,0.0);
                    interface_gamma_plot->add_data(curv_var2,0.0);
                     */
                }
                
            }
            
        }
           
           
    }

    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
    postoutput.write();
    goal_quantities_time_fast(msh , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k0_curvature_para.dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para.dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T linf_divergence_error_para = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
       
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

           if( cl.user_data.interface.size() == degree_FEM + 1 ) // if( curve.subcells.size()<1 )
            {
                for(int i= 0; i <= tot ; i++)
                {
                    T pos = 0.0+i/tot ;
                    T val0 = curve.curvature(pos,msh_i,cl) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                        
                }
            }
            else
            {
                //size_t tot_cls = cl.user_data.interface.size()/ (degree_FEM + 1.0)  ;
                size_t tot_cls = (cl.user_data.interface.size()-1)/ (degree_curve )  ;
                //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                    for(int i= 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        T val0 = curve.curvature(pos,msh_i,cl,cell_ind) ;
                        T error_curvature = std::abs( val0 + 1.0/radius) ;
                        
                        l1_divergence_error_para += error_curvature;
                        l2_divergence_error_para += pow(error_curvature,2) ;
                        linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                         counter_interface_pts_para++;
                                      
                                    
                    }
                }
            }
          

           

        }



    }

    bool first_cut_cell_found_para = FALSE ;
    T distance_pts_para = 0.0;
    point<T,2> first_point_para ;
    point<T,2> cell_end_point_para;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            
            if(!first_cut_cell_found_para)
            {
                if( cl.user_data.interface.size() == degree_FEM + 1 ) // if( curve.subcells.size()<1 )
                {
                    for(int i= 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        T val0 = curve.curvature(pos,msh_i,cl) ;
                        //T error_curvature = std::abs( val0 + 1.0/radius) ;
                         point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        if( pos==0)
                            test_curvature_para->add_data(curv_var, val0);

                        test_curv_var_para->add_data(curv_var, val0);

                        distance_pts_para += i/tot ;
                            
                    }
                }
                else
                {
                    //size_t tot_cls = cl.user_data.interface.size()/ (degree_FEM + 1.0)  ;
                    size_t tot_cls = (cl.user_data.interface.size()-1)/ (degree_curve )  ;
                    //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                    for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                        for(int i= 0; i <= tot ; i++)
                        {
                            T pos = 0.0+i/tot ;
                                                   
                            T val0 = curve.curvature(pos,msh_i,cl) ;
                            //T error_curvature = std::abs( val0 + 1.0/radius) ;
                            point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                            if( pos==0)
                                test_curvature_para->add_data(curv_var, val0);

                            test_curv_var_para->add_data(curv_var, val0);
                            distance_pts_para += i/tot ;
                                          
                                        
                        }
                    }
                }
                
                first_cut_cell_found_para = TRUE;
                first_point_para = *cl.user_data.interface.begin() ;
                cell_end_point_para = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found_para && !( first_point_para == cell_end_point_para  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point_para ==*cl.user_data.interface.begin() )  )
                    {
                        if( cl.user_data.interface.size() == degree_FEM + 1 ) // if( curve.subcells.size()<1 )
                        {
                            for(int i= 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature(pos,msh_i,cl) ;
                                //T error_curvature = std::abs( val0 + 1.0/radius) ;
                                 point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                if( pos==0)
                                    test_curvature_para->add_data(curv_var, val0);

                                test_curv_var_para->add_data(curv_var, val0);

                                distance_pts_para += i/tot ;
                                
                                    
                            }
                        }
                        else
                        {
                           //size_t tot_cls = cl.user_data.interface.size()/ (degree_FEM + 1.0)  ;
                            size_t tot_cls = (cl.user_data.interface.size()-1)/ (degree_curve )  ;
                            //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                            for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                                              
                                for(int i= 0; i <= tot ; i++)
                                {
                                    T pos = 0.0+i/tot ;
                                                           
                                    T val0 = curve.curvature(pos,msh_i,cl) ;
                                    //T error_curvature = std::abs( val0 + 1.0/radius) ;
                                    point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                    if( pos==0)
                                        test_curvature_para->add_data(curv_var, val0);

                                    test_curv_var_para->add_data(curv_var, val0);
                                    distance_pts_para += i/tot ;
                                                  
                                                
                                }
                            }
                        }
                       
                        cell_end_point_para = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    postoutput_div_para.write();
    l1_divergence_error_para /= counter_interface_pts_para;

    l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
    std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
    std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
    std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
    std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
    
    
    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;
    std::vector<T> circularity_time , flux_interface_time , perimeter_time;
    std::vector<std::pair<T,T>> centre_mass_err_time , rise_velocity_time , min_max_vec ;

    //postprocess_output<double> postoutput_vec;
    //auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    size_t counter_interface_pts = 0;

    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
            {


                T val0 = ls_cell.divergence( *interface_point );
                T error_curvature = std::abs( val0 + 1.0/radius) ;
                l1_divergence_error += error_curvature;
                l2_divergence_error += pow(error_curvature,2) ;
                linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                //vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);

                perimeter_initial += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                interface_points_plot.push_back(*(interface_point)) ;


                counter_interface_pts++;

            }

            T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));

            T error_curvature = std::abs( val0 + 1.0/radius) ;
            l1_divergence_error += error_curvature;
            l2_divergence_error += pow(error_curvature,2) ;
            linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;


            Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
            std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
            interface_normals.push_back( normal_vec_grad_cont ) ;

            //vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;



            counter_interface_pts++;

        }



    }

    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() )
                        test_curv_var_cell->add_data(curv_var, val0);

                    test_curv_var_divergence0->add_data(curv_var, val0);

                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                    {
                        ls_cell.cell_assignment(cl);
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.write();

    //postoutput_vec.add_object(vec_normal_grad_cont);
    //postoutput_vec.write();



    if( !flower) //1 ) // !flower)
    {
        l1_divergence_error /= counter_interface_pts;

        l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;
        l1_err_curvature_time.push_back(l1_divergence_error) ;
        linf_err_curvature_time.push_back(linf_divergence_error) ;

    }

    std::cout <<bold<<yellow << '\n' << "Initial time, AREA  = "<< initial_area << reset << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    std::cout<<"OLD radius = " << radius <<std::endl;


    if(flower)
    {
        T l1_divergence_error_flower = 0. , l2_divergence_error_flower = 0. ;
        T linf_divergence_error_flower = -10. ;
        radius = sqrt( initial_area/M_PI ) ;
        std::cout<<"FROM AREA radius = " << radius <<std::endl;
        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl) ;

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_flower += error_curvature;
                    l2_divergence_error_flower += pow(error_curvature,2) ;
                    linf_divergence_error_flower = std::max(linf_divergence_error_flower , error_curvature ) ;

                }
            }
        }
        l1_divergence_error_flower /= counter_interface_pts;

        l2_divergence_error_flower = sqrt(l2_divergence_error_flower/counter_interface_pts);

        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error_flower<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error_flower <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error_flower<<reset <<std::endl;

        l1_err_curvature_time.push_back(l1_divergence_error_flower) ;
        linf_err_curvature_time.push_back(linf_divergence_error_flower) ;
    }


    T circularity_ref = 0.0 ;
    T perim_ref = 0.0 ;
    T area_ref = 0.0  ;

    {
        // calculus of circle REF in Q^k mesh N x M --> CIRCULARITY REF
        auto level_anal_ref = circle_level_set<RealType>(radius, x_centre, y_centre );
        std::cout<<"REF radius = " << radius <<std::endl;
        typedef  circle_level_set<T> Fonction_REF;
        auto level_set_ref = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > (fe_data , level_anal_ref , msh);

        Mesh msh_ref =  msh;
        offset_definition(msh_ref);
        detect_node_position3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_faces3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_cells3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cell_agglo_set(msh_ref, level_set_ref); // Non serve modificarla
        make_neighbors_info_cartesian(msh_ref); // Non serve modificarla
        refine_interface_pro3(msh_ref, level_set_ref, int_refsteps);
        //make_agglomeration(msh_ref, level_set_ref); // Non serve modificarla
        make_agglomeration_no_double_points(msh_ref, level_set_ref,degree_curve);

        typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > Level_Set_REF;
        auto ls_cell_ref = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set_REF, Fonction_REF , FiniteSpace >(level_set_ref,msh_ref);


        for(auto& cl : msh_ref.cells)
        {
            ls_cell_ref.cell_assignment(cl);


            if( location(msh_ref, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_ref, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_ref, cl, element_location::IN_NEGATIVE_SIDE);
                area_ref += partial_area;

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perim_ref += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                }
            }
        }

        T d_a_REF = sqrt(4.0*area_ref/M_PI) ;
        std::cout<<"AREA REF = " << area_ref <<std::endl;
        std::cout<<"PERIMETER REF = " << perim_ref <<std::endl;
        std::cout<<"Error( perimetre_ref - perimeter_initial ) = " << perim_ref - perimeter_initial <<std::endl;
        std::cout<<"Error( area_ref - initial_area ) = " << area_ref - initial_area <<std::endl;
        circularity_ref = M_PI*d_a_REF/perim_ref ;
        std::cout<<"CIRCULARITY REF = " << circularity_ref <<std::endl;
        std::cout<<"Error( area_ref - area_analytic ) = " << area_ref - M_PI*radius*radius <<std::endl;

    }




    circularity_time.push_back(M_PI*d_a/perimeter_initial);
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(std::make_pair(centre_mass_x_inital/initial_area  , centre_mass_y_inital/initial_area) );

    time_vec.push_back(0) ;
    area_time.push_back(initial_area) ;

    min_max_vec.push_back( std::make_pair( level_set_function.phi_min , level_set_function.phi_max ) );

    T dt_M ;



    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration, time t = "<<tot_time<<reset <<std::endl;
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        //testing_level_set_time(msh,level_set_function,tot_time,time_step);



        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);


        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);


        //timecounter tc_u ;
        //tc_u.tic();
        //stokes_test_info<T> TI;
        if(solve_interface){

            //bool normal_analysis =  true ;
            //TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        //tc_u.toc();

        //std::cout << "Machine Time for solving STOKES PB: " << tc_u << " seconds" << std::endl;





        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if(0)
            std::cout<<bold<<green<<"CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"<<reset<<std::endl;

        if( 1 ) //1 FIRST RESULT WITH THIS
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh , method_transport_pb);
        }
        //testing_velocity_field(msh , u_projected) ;

        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;




        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------
        auto level_set_tmp = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        //auto ls_cell_tmp = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        //auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        //if(tot_time < 0.75)
        dt_M = 8*1e-3; // 4*1e-3;
        //else
        //    dt_M = 1e-3;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt_one_cell = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;

        //T sub_dt;
        //if(tot_time <0.132)
        //    sub_dt = std::min(4*1e-4 , dt ) ;
        //else
        //    sub_dt = std::min(5*1e-5 , dt ) ;

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        /*
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else{
                if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  );
                else
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  , fe_data_Lagrange);

            }
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        */
        //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        // ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , mapping );

            }
            else{
                //if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  sub_dt  );
                //else
                //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

            }


            sub_time += sub_dt ;

        }
        tot_time += sub_time ;


       /**************************************************   POST-PROCESSING **************************************************/


        // Updating continuous normal function

        // IF GRADIENT CONTINUOUS
        level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
        // IF DIVERGENCE CONTINUOUS
        level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

        // Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
            refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration_no_double_points(msh_i, level_set_function,degree_curve); // Non serve modificarla
           // make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i2, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh( msh_i );


        T max_u_n_val = 0.0 ;
        T max_u_n_val_abs = 0.0 ;
        T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;


        size_t counter_interface_pts = 0;
        for(auto& cl : msh_i.cells)
        {
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                    max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                    if( std::abs(u_n_val) == max_u_n_val_abs )
                        max_u_n_val = u_n_val ;

                    l1_normal_interface_status += std::abs(u_n_val) ;
                    l2_normal_interface_status += pow(u_n_val,2.0);
                    counter_interface_pts ++ ;

                }
            }
        }

        if( time_step == 0 )
            max_u_n_val_new = max_u_n_val ;

        if(time_step > 0 )
        {
            max_u_n_val_old = max_u_n_val_new ;
            max_u_n_val_new = max_u_n_val ;
            std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
        }

        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;
        l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
        std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
        std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
        std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;




        if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
        {
            std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
            //exit(9) ;
        }

        //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

        //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
        if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
        {




            // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
            // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
            T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
            T dt_new = std::min(dt_one_cell , dt_M_new);

            bool forward = TRUE ;
            if( forward ) // GO FORWARD FROM THE TIME t^n
            {
                dt = dt_new ;

                std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                tot_time -= sub_time ; // I erase the time previously calculated
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {

                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb ,  sub_dt  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);


                    }


                    sub_time += sub_dt ;

                }

                tot_time += sub_time ; // the new time is substracted
                level_set_function = level_set_tmp ;
                std::cout<<'\n'<<std::endl;
                //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
            }
            else // GO BACKWARD FROM THE TIME t^n + dt_M
            {

                dt = dt_M - dt_new ;
                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    T neg_time = -sub_dt ;
                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  neg_time  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time  , fe_data_Lagrange);


                    }



                    sub_time += sub_dt ;

                }
                std::cout<<'\n'<<std::endl;
                tot_time -= sub_time ; // the new time is substracted

            }


            //-------------------------- NEW CALCULATION OF U*N --------------------------

            // Updating continuous normal function

            // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div) ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);

            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration_no_double_points(msh_i, level_set_function,degree_curve);
                //make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            }
            else
            {
                move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i;
            u_projected.set_agglo_mesh( msh_i );


            max_u_n_val = 0.0 ;
            max_u_n_val_abs = 0.0 ;
            l1_normal_interface_status = 0. ;
            l2_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh_i.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        if( std::abs(u_n_val) == max_u_n_val_abs )
                            max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        l2_normal_interface_status += pow(u_n_val,2.0);
                        counter_interface_pts ++ ;

                    }
                }
            }


            max_u_n_val_new = max_u_n_val ;


            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
            l1_normal_interface_status /= counter_interface_pts;
            l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

            std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
            std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
            std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

            std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;



        }


        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;



        // PLOTTING OF NORMAL

        //postprocess_output<double> postoutput_vec;
        //auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

        postprocess_output<T> postoutput_div2;
        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

        std::vector<T>  val_u_n_fin ; //val_u_nx_fin , val_u_ny_fin ;
        std::vector< point<T, 2> > interface_points_plot_fin ;
        std::vector< std::pair<T,T> > vec_n ; // , velocity_interface , velocity_field , points_vel_field;



        T rise_vel0 = 0.0 , rise_vel1 = 0.0 ;
        T flux_interface = 0.0 ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
            {

                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                auto qps_fin = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                for(auto& qp:qps_fin){
                    mass_fin += qp.second * ls_cell(qp.first);
                    centre_mass_x += qp.second * qp.first.x() ;
                    centre_mass_y += qp.second * qp.first.y() ;

                    rise_vel0 +=  qp.second * u_projected(qp.first).first;
                    rise_vel1 +=  qp.second * u_projected(qp.first).second;
                }

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    T segment = ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    perimeter += segment ;
                    T val0 = ls_cell.divergence( *interface_point );
                    T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                    l1_divergence_error_fin += curvature_error ;
                    l2_divergence_error_fin += pow(curvature_error,2) ;
                    linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);



                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair( normal_cont_grad(0) , normal_cont_grad(1) );

                    vec_n.push_back( normal_vec_grad_cont ) ;

                    T u_n_0 = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) ;
                    T u_n_1 = u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;

                    interface_points_plot_fin.push_back( *(interface_point) ) ;

                    //val_u_nx_fin.push_back( u_n_0 );
                    //val_u_ny_fin.push_back( u_n_1 );
                    val_u_n_fin.push_back( u_n_0 + u_n_1 );

                    //velocity_interface.push_back( std::make_pair( u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;

                    T u_n_0_pt2 = u_projected(*(interface_point+1)).first * ls_cell.normal(*(interface_point+1))(0) ;
                    T u_n_1_pt2 = u_projected(*(interface_point+1)).second * ls_cell.normal(*(interface_point+1))(1) ;

                    flux_interface += segment * 0.5*( u_n_0 + u_n_1 + u_n_0_pt2 + u_n_1_pt2 ) ;
                    //    counter_interface_pts++;
                }

                T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                l1_divergence_error_fin += curvature_error ;
                l2_divergence_error_fin += pow(curvature_error,2) ;
                linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                vec_n.push_back( normal_vec_grad_norm ) ;

                T u_n_0 = u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) ;
                T u_n_1 = u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) ;


                interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                //val_u_nx_fin.push_back( u_n_0 );
                //val_u_ny_fin.push_back( u_n_1 );
                val_u_n_fin.push_back( u_n_0 + u_n_1 );

                //velocity_interface.push_back( std::make_pair( u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                //    counter_interface_pts++;

            }
            /*
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }
            */

        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);

                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);


                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }


        postoutput_div2.add_object(test_curv_var_divergence0);
        postoutput_div2.add_object(test_curv_var_cell);
        postoutput_div2.write();


        //postoutput_vec.add_object(vec_normal_grad_cont_fin);
        //postoutput_vec.write();
        goal_quantities_time_fast(msh , interface_points_plot_fin , val_u_n_fin  , vec_n , time_step);

        //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , vec_n , velocity_interface , velocity_field , points_vel_field , time_step ) ;
        //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;

        //if(time_step == T_N)
        //    testing_level_set_time(msh,level_set_function, tot_time,time_step);

        testing_level_set_max_min(msh,level_set_function , time_step , min_max_vec );

        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts;
        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;






        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;

        //DA ADD BENE!!!! da qui

        circularity_time.push_back(M_PI*d_a/perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x/area_fin  , centre_mass_y/area_fin) );

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back( std::make_pair(rise_vel0/area_fin  , rise_vel1/area_fin) ) ;


        //fino a qua


    } // End of the temporal loop

    //plotting_in_time( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M );

    plotting_in_time_complete( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M ,min_max_vec ,  flux_interface_time , rise_velocity_time , centre_mass_err_time , perimeter_time , circularity_time , circularity_ref , perim_ref , area_ref , radius );



    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;

    tc_tot.toc();
    std::cout<<"Simulation time 0 t = "<<tc_tot <<std::endl;

    return 0;
}
#endif



// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 03/11/2020 -> (NORMAL DISC -> DIVERGENCE CONT  (+GRAD/NORM CONT a posteriori) )
#if 0 // CASE 2
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    size_t T_N = 0;
    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Mesh size = "<<mip.Nx<<"x"<<mip.Ny<<std::endl;
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;


    /**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
    //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t  degree_gradient = degree_FEM  ;
    auto fe_data_gradient = Finite_Element<RealType,Mesh>( msh , degree_gradient , mip ) ;
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;

    size_t  degree_div = degree_FEM  ;
    std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
    auto fe_data_div = Finite_Element<RealType,Mesh>( msh , degree_div , mip ) ;
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/3.0-eps_circ;
        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    //std::cout<<"Initial interface: CIRCLE"<<std::endl;
    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;
    bool flower = true ;

    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //std::cout<<"Initial interface: ELLIPSE"<<std::endl;
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/


    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;
    auto level_set_function = Level_set_berstein_curvature2< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
   //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);



     // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
    // IF DIVERGENCE CONTINUOUS
    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

    /************** LEVEL SET  MAPPING **************/
    // If mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    bool mapping = false ;
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );



    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.;
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        move_nodes(msh_i, level_set_function);
        //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
        detect_cut_cells3(msh_i, level_set_function);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }


    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
    // IF DIVERGENCE CONTINUOUS
    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

    typedef Level_set_berstein_curvature2< Mesh , Fonction , FiniteSpace , T > Level_Set;
    //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
    //typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
     //typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > Level_Set;

    // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\
    // IF grad disc -> normal disc -> divergence cont -> grad cont -> norm cont (from the disc)
       auto ls_cell = LS_cell_high_order_grad_cont_div_cont2< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
    // IF grad disc -> normal disc -> divergence cont
    //auto ls_cell = LS_cell_high_order_grad_disc_div_cont2< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);




    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();


    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;
    std::vector<T> circularity_time , flux_interface_time , perimeter_time;
    std::vector<std::pair<T,T>> centre_mass_err_time , rise_velocity_time , min_max_vec ;

    //postprocess_output<double> postoutput_vec;
    //auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    size_t counter_interface_pts = 0;

    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
            {


                T val0 = ls_cell.divergence( *interface_point );
                T error_curvature = std::abs( val0 + 1.0/radius) ;
                l1_divergence_error += error_curvature;
                l2_divergence_error += pow(error_curvature,2) ;
                linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                //vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);

                perimeter_initial += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                interface_points_plot.push_back(*(interface_point)) ;


                counter_interface_pts++;

            }

            T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));

            T error_curvature = std::abs( val0 + 1.0/radius) ;
            l1_divergence_error += error_curvature;
            l2_divergence_error += pow(error_curvature,2) ;
            linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;


            Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
            std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
            interface_normals.push_back( normal_vec_grad_cont ) ;

            //vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;



            counter_interface_pts++;

        }



    }

    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() )
                        test_curv_var_cell->add_data(curv_var, val0);

                    test_curv_var_divergence0->add_data(curv_var, val0);

                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                    {
                        ls_cell.cell_assignment(cl);
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.write();

    //postoutput_vec.add_object(vec_normal_grad_cont);
    //postoutput_vec.write();



    if( !flower) //1 ) // !flower)
    {
        l1_divergence_error /= counter_interface_pts;

        l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;
        l1_err_curvature_time.push_back(l1_divergence_error) ;
        linf_err_curvature_time.push_back(linf_divergence_error) ;

    }

    std::cout <<bold<<yellow << '\n' << "Initial time, AREA  = "<< initial_area << reset << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    std::cout<<"OLD radius = " << radius <<std::endl;


    if(flower)
    {
        T l1_divergence_error_flower = 0. , l2_divergence_error_flower = 0. ;
        T linf_divergence_error_flower = -10. ;
        radius = sqrt( initial_area/M_PI ) ;
        std::cout<<"FROM AREA radius = " << radius <<std::endl;
        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl) ;

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_flower += error_curvature;
                    l2_divergence_error_flower += pow(error_curvature,2) ;
                    linf_divergence_error_flower = std::max(linf_divergence_error_flower , error_curvature ) ;

                }
            }
        }
        l1_divergence_error_flower /= counter_interface_pts;

        l2_divergence_error_flower = sqrt(l2_divergence_error_flower/counter_interface_pts);

        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error_flower<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error_flower <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error_flower<<reset <<std::endl;

        l1_err_curvature_time.push_back(l1_divergence_error_flower) ;
        linf_err_curvature_time.push_back(linf_divergence_error_flower) ;
    }


    T circularity_ref = 0.0 ;
    T perim_ref = 0.0 ;
    T area_ref = 0.0  ;

    {
        // calculus of circle REF in Q^k mesh N x M --> CIRCULARITY REF
        auto level_anal_ref = circle_level_set<RealType>(radius, x_centre, y_centre );
        std::cout<<"REF radius = " << radius <<std::endl;
        typedef  circle_level_set<T> Fonction_REF;
        auto level_set_ref = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > (fe_data , level_anal_ref , msh);

        Mesh msh_ref =  msh;
        offset_definition(msh_ref);
        detect_node_position3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_faces3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_cells3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cell_agglo_set(msh_ref, level_set_ref); // Non serve modificarla
        make_neighbors_info_cartesian(msh_ref); // Non serve modificarla
        refine_interface_pro3(msh_ref, level_set_ref, int_refsteps);
        make_agglomeration(msh_ref, level_set_ref); // Non serve modificarla

        typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > Level_Set_REF;
        auto ls_cell_ref = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set_REF, Fonction_REF , FiniteSpace >(level_set_ref,msh_ref);


        for(auto& cl : msh_ref.cells)
        {
            ls_cell_ref.cell_assignment(cl);


            if( location(msh_ref, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_ref, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_ref, cl, element_location::IN_NEGATIVE_SIDE);
                area_ref += partial_area;

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perim_ref += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                }
            }
        }

        T d_a_REF = sqrt(4.0*area_ref/M_PI) ;
        std::cout<<"AREA REF = " << area_ref <<std::endl;
        std::cout<<"PERIMETER REF = " << perim_ref <<std::endl;
        std::cout<<"Error( perimetre_ref - perimeter_initial ) = " << perim_ref - perimeter_initial <<std::endl;
        std::cout<<"Error( area_ref - initial_area ) = " << area_ref - initial_area <<std::endl;
        circularity_ref = M_PI*d_a_REF/perim_ref ;
        std::cout<<"CIRCULARITY REF = " << circularity_ref <<std::endl;
        std::cout<<"Error( area_ref - area_analytic ) = " << area_ref - M_PI*radius*radius <<std::endl;

    }




    circularity_time.push_back(M_PI*d_a/perimeter_initial);
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(std::make_pair(centre_mass_x_inital/initial_area  , centre_mass_y_inital/initial_area) );

    time_vec.push_back(0) ;
    area_time.push_back(initial_area) ;

    min_max_vec.push_back( std::make_pair( level_set_function.phi_min , level_set_function.phi_max ) );

    T dt_M ;



    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration, time t = "<<tot_time<<reset <<std::endl;
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        //testing_level_set_time(msh,level_set_function,tot_time,time_step);



        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);


        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);


        //timecounter tc_u ;
        //tc_u.tic();
        //stokes_test_info<T> TI;
        if(solve_interface){

            //bool normal_analysis =  true ;
            //TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        //tc_u.toc();

        //std::cout << "Machine Time for solving STOKES PB: " << tc_u << " seconds" << std::endl;





        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if(0)
            std::cout<<bold<<green<<"CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"<<reset<<std::endl;

        if( 1 ) //1 FIRST RESULT WITH THIS
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh , method_transport_pb);
        }
        //testing_velocity_field(msh , u_projected) ;

        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;




        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------
        auto level_set_tmp = Level_set_berstein_curvature2< Mesh , Fonction , FiniteSpace , T > (level_set_function);

        // IF grad disc -> normal disc -> divergence cont -> grad cont -> norm cont (from the disc)
           auto ls_cell_tmp = LS_cell_high_order_grad_cont_div_cont2< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        // IF grad disc -> normal disc -> divergence cont
        //auto ls_cell_tmp = LS_cell_high_order_grad_disc_div_cont2< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);


        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        //if(tot_time < 0.75)
        dt_M = 8*1e-3; // 4*1e-3;
        //else
        //    dt_M = 1e-3;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt_one_cell = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;

        //T sub_dt;
        //if(tot_time <0.132)
        //    sub_dt = std::min(4*1e-4 , dt ) ;
        //else
        //    sub_dt = std::min(5*1e-5 , dt ) ;

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        /*
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else{
                if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  );
                else
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  , fe_data_Lagrange);

            }
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        */
        //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        // ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , mapping );

            }
            else{
                //if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  sub_dt  );
                //else
                //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

            }


            sub_time += sub_dt ;

        }
        tot_time += sub_time ;


       /**************************************************   POST-PROCESSING **************************************************/


        // Updating continuous normal function

        // IF GRADIENT CONTINUOUS
        level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
        // IF DIVERGENCE CONTINUOUS
        level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

        // Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
            refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i2, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh( msh_i );


        T max_u_n_val = 0.0 ;
        T max_u_n_val_abs = 0.0 ;
        T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;


        size_t counter_interface_pts = 0;
        for(auto& cl : msh_i.cells)
        {
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                    max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                    if( std::abs(u_n_val) == max_u_n_val_abs )
                        max_u_n_val = u_n_val ;

                    l1_normal_interface_status += std::abs(u_n_val) ;
                    l2_normal_interface_status += pow(u_n_val,2.0);
                    counter_interface_pts ++ ;

                }
            }
        }

        if( time_step == 0 )
            max_u_n_val_new = max_u_n_val ;

        if(time_step > 0 )
        {
            max_u_n_val_old = max_u_n_val_new ;
            max_u_n_val_new = max_u_n_val ;
            std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
        }

        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;
        l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
        std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
        std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
        std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;




        if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
        {
            std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
            //exit(9) ;
        }

        //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

        //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
        if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
        {




            // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
            // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
            T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
            T dt_new = std::min(dt_one_cell , dt_M_new);

            bool forward = TRUE ;
            if( forward ) // GO FORWARD FROM THE TIME t^n
            {
                dt = dt_new ;

                std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                tot_time -= sub_time ; // I erase the time previously calculated
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {

                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb ,  sub_dt  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);


                    }


                    sub_time += sub_dt ;

                }

                tot_time += sub_time ; // the new time is substracted
                level_set_function = level_set_tmp ;
                std::cout<<'\n'<<std::endl;
                //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
            }
            else // GO BACKWARD FROM THE TIME t^n + dt_M
            {

                dt = dt_M - dt_new ;
                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    T neg_time = -sub_dt ;
                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  neg_time  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time  , fe_data_Lagrange);


                    }



                    sub_time += sub_dt ;

                }
                std::cout<<'\n'<<std::endl;
                tot_time -= sub_time ; // the new time is substracted

            }


            //-------------------------- NEW CALCULATION OF U*N --------------------------

            // Updating continuous normal function

            // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div) ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);

            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            }
            else
            {
                move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i;
            u_projected.set_agglo_mesh( msh_i );


            max_u_n_val = 0.0 ;
            max_u_n_val_abs = 0.0 ;
            l1_normal_interface_status = 0. ;
            l2_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh_i.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        if( std::abs(u_n_val) == max_u_n_val_abs )
                            max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        l2_normal_interface_status += pow(u_n_val,2.0);
                        counter_interface_pts ++ ;

                    }
                }
            }


            max_u_n_val_new = max_u_n_val ;


            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
            l1_normal_interface_status /= counter_interface_pts;
            l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

            std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
            std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
            std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

            std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;



        }


        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;



        // PLOTTING OF NORMAL

        //postprocess_output<double> postoutput_vec;
        //auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

        postprocess_output<T> postoutput_div2;
        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

        std::vector<T>  val_u_n_fin ; //val_u_nx_fin , val_u_ny_fin ;
        std::vector< point<T, 2> > interface_points_plot_fin ;
        std::vector< std::pair<T,T> > vec_n ; // , velocity_interface , velocity_field , points_vel_field;



        T rise_vel0 = 0.0 , rise_vel1 = 0.0 ;
        T flux_interface = 0.0 ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
            {

                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                auto qps_fin = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                for(auto& qp:qps_fin){
                    mass_fin += qp.second * ls_cell(qp.first);
                    centre_mass_x += qp.second * qp.first.x() ;
                    centre_mass_y += qp.second * qp.first.y() ;

                    rise_vel0 +=  qp.second * u_projected(qp.first).first;
                    rise_vel1 +=  qp.second * u_projected(qp.first).second;
                }

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    T segment = ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    perimeter += segment ;
                    T val0 = ls_cell.divergence( *interface_point );
                    T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                    l1_divergence_error_fin += curvature_error ;
                    l2_divergence_error_fin += pow(curvature_error,2) ;
                    linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);



                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair( normal_cont_grad(0) , normal_cont_grad(1) );

                    vec_n.push_back( normal_vec_grad_cont ) ;

                    T u_n_0 = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) ;
                    T u_n_1 = u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;

                    interface_points_plot_fin.push_back( *(interface_point) ) ;

                    //val_u_nx_fin.push_back( u_n_0 );
                    //val_u_ny_fin.push_back( u_n_1 );
                    val_u_n_fin.push_back( u_n_0 + u_n_1 );

                    //velocity_interface.push_back( std::make_pair( u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;

                    T u_n_0_pt2 = u_projected(*(interface_point+1)).first * ls_cell.normal(*(interface_point+1))(0) ;
                    T u_n_1_pt2 = u_projected(*(interface_point+1)).second * ls_cell.normal(*(interface_point+1))(1) ;

                    flux_interface += segment * 0.5*( u_n_0 + u_n_1 + u_n_0_pt2 + u_n_1_pt2 ) ;
                    //    counter_interface_pts++;
                }

                T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                l1_divergence_error_fin += curvature_error ;
                l2_divergence_error_fin += pow(curvature_error,2) ;
                linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                vec_n.push_back( normal_vec_grad_norm ) ;

                T u_n_0 = u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) ;
                T u_n_1 = u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) ;


                interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                //val_u_nx_fin.push_back( u_n_0 );
                //val_u_ny_fin.push_back( u_n_1 );
                val_u_n_fin.push_back( u_n_0 + u_n_1 );

                //velocity_interface.push_back( std::make_pair( u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                //    counter_interface_pts++;

            }
            /*
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }
            */

        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);

                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);


                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }


        postoutput_div2.add_object(test_curv_var_divergence0);
        postoutput_div2.add_object(test_curv_var_cell);
        postoutput_div2.write();


        //postoutput_vec.add_object(vec_normal_grad_cont_fin);
        //postoutput_vec.write();
        goal_quantities_time_fast(msh , interface_points_plot_fin , val_u_n_fin  , vec_n , time_step);

        //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , vec_n , velocity_interface , velocity_field , points_vel_field , time_step ) ;
        //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;

        //if(time_step == T_N)
        //    testing_level_set_time(msh,level_set_function, tot_time,time_step);

        testing_level_set_max_min(msh,level_set_function , time_step , min_max_vec );

        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts;
        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;






        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;

        //DA ADD BENE!!!! da qui

        circularity_time.push_back(M_PI*d_a/perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x/area_fin  , centre_mass_y/area_fin) );

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back( std::make_pair(rise_vel0/area_fin  , rise_vel1/area_fin) ) ;


        //fino a qua


    } // End of the temporal loop

    //plotting_in_time( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M );

    plotting_in_time_complete( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M ,min_max_vec ,  flux_interface_time , rise_velocity_time , centre_mass_err_time , perimeter_time , circularity_time , circularity_ref , perim_ref , area_ref , radius );



    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;

    tc_tot.toc();
    std::cout<<"Simulation time 0 t = "<<tc_tot <<std::endl;

    return 0;
}
#endif




// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 29/09/2020 -> GRAD CONTINUOS IMPLEMENTATION (IMAGES CHECKING FOR CONTINUOUS STUFF)
// ---- > dt_M (CHECK OF THE MAXIMUM TIME STEP)
// ---- > normal_interface_status CORRECT !!!!
// ---- > STARTING FROM A SAVED SOLUTION AT A FIXED TIME t > 0
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;





    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/3.0-eps_circ;
        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    //std::cout<<"Initial interface: CIRCLE"<<std::endl;
    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;

    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //std::cout<<"Initial interface: ELLIPSE"<<std::endl;
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/
    size_t  degree_velocity = std::max(degree , degree_FEM) ; // degree_FEM ; //10 ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;
    std::cout<<"Level set: high order Berstein Vandermonde interpolated."<<std::endl;
    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    std::cout<<"Uploading level set:"<<std::endl;

    std::cout<<"sol_FEM pre"<<'\n'<<level_set_function.sol_FEM<<std::endl;

    std::string filename_FEM = "prova/sol_FEM_t=0.008000.dat";


    level_set_function.upload_level_set(filename_FEM) ;


    std::cout<<"sol_FEM post"<<'\n'<<level_set_function.sol_FEM<<std::endl;


    //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    level_set_function.gradient_continuous_setting() ;

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ; // if mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );


    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);
    //Mesh msh_tmp =  crr_mesh.current_mesh;  // MESH at t=t^n+1 (FOR POST-PROCESSING)
    //offset_definition(msh_tmp);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.; // Initialisation Area , Mass for t = 0
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    // NOTICE: The sequential detect_node_position3 is faster than the parallel one: PROVED IN DEBUG MOD, IN RELEASE WILL IT BE THE SAME???
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom

    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        move_nodes(msh_i, level_set_function);
        //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface2(msh_i, level_set_function, int_refsteps);
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }


    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    level_set_function.gradient_continuous_setting() ;

    //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;

    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();


    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    postprocess_output<double> postoutput_vec;
    auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    size_t counter_interface_pts = 0;

    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
            {


                T val0 = ls_cell.divergence( *interface_point );
                T error_curvature = std::abs( val0 + 1.0/radius) ;
                l1_divergence_error += error_curvature;
                l2_divergence_error += pow(error_curvature,2) ;
                linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);

                perimeter_initial += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                interface_points_plot.push_back(*(interface_point)) ;


                counter_interface_pts++;

            }

            T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));

            T error_curvature = std::abs( val0 + 1.0/radius) ;
            l1_divergence_error += error_curvature;
            l2_divergence_error += pow(error_curvature,2) ;
            linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;


            Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
            std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
            interface_normals.push_back( normal_vec_grad_cont ) ;

            vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;



            counter_interface_pts++;

        }



    }

    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() )
                        test_curv_var_cell->add_data(curv_var, val0);

                    test_curv_var_divergence0->add_data(curv_var, val0);

                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                    {
                        ls_cell.cell_assignment(cl);
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.write();

    postoutput_vec.add_object(vec_normal_grad_cont);
    postoutput_vec.write();

    l1_divergence_error /= counter_interface_pts;

    l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);

    std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
    std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
    std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
    std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;


    std::cout <<bold<<yellow << '\n' << "Initial time, AREA  = "<< initial_area << reset << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;





    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;
    time_vec.push_back(0) ;
    area_time.push_back(initial_mass) ;
    l1_err_curvature_time.push_back(l1_divergence_error) ;
    linf_err_curvature_time.push_back(linf_divergence_error) ;
    T dt_M ;


    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration, time t = "<<tot_time<<reset <<std::endl;
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        testing_level_set_time(msh,level_set_function,tot_time,time_step);



        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);


        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);


        //timecounter tc_u ;
        //tc_u.tic();
        stokes_test_info<T> TI;
        if(solve_interface){

            //bool normal_analysis =  true ;
            //TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        //tc_u.toc();

        //std::cout << "Machine Time for solving STOKES PB: " << tc_u << " seconds" << std::endl;





        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------

        if( 1 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh);
        }
        testing_velocity_field(msh , u_projected) ;

        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;




        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------

        auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        dt_M = 8*1e-3; // 4*1e-3;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt_one_cell = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;

        //T sub_dt;
        //if(tot_time <0.132)
        //    sub_dt = std::min(4*1e-4 , dt ) ;
        //else
        //    sub_dt = std::min(5*1e-5 , dt ) ;

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else{
                if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                else
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt,fe_data_Lagrange);

            }

                //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        tot_time += sub_time ;


       /**************************************************   POST-PROCESSING **************************************************/


        // Updating continuous normal function
        level_set_function.gradient_continuous_setting() ;
        // Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
            refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i2, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh( msh_i );


        T max_u_n_val = 0.0 ;
        T max_u_n_val_abs = 0.0 ;
        T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;


        size_t counter_interface_pts = 0;
        for(auto& cl : msh_i.cells)
        {
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                    max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                    if( std::abs(u_n_val) == max_u_n_val_abs )
                        max_u_n_val = u_n_val ;

                    l1_normal_interface_status += std::abs(u_n_val) ;
                    l2_normal_interface_status += pow(u_n_val,2.0);
                    counter_interface_pts ++ ;

                }
            }
        }

        if( time_step == 0 )
            max_u_n_val_new = max_u_n_val ;

        if(time_step > 0 )
        {
            max_u_n_val_old = max_u_n_val_new ;
            max_u_n_val_new = max_u_n_val ;
            std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
        }

        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;
        l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
        std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
        std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
        std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;




        if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
        {
            std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
            //exit(9) ;
        }

        //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

        //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
        if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
        {




            // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
            // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
            T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
            T dt_new = std::min(dt_one_cell , dt_M_new);

            bool forward = TRUE ;
            if( forward ) // GO FORWARD FROM THE TIME t^n
            {
                dt = dt_new ;

                std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                tot_time -= sub_time ; // I erase the time previously calculated
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , sub_dt , mapping );
                    }
                    else{
                        if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , sub_dt);
                        else
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , sub_dt,fe_data_Lagrange);

                    }

                    sub_time += sub_dt ;

                }

                tot_time += sub_time ; // the new time is substracted
                level_set_function = level_set_tmp ;
                std::cout<<'\n'<<std::endl;
                //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
            }
            else // GO BACKWARD FROM THE TIME t^n + dt_M
            {

                dt = dt_M - dt_new ;
                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    if(high_order){
                        T neg_time = -sub_dt ;
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , neg_time , mapping );
                    }
                    else{
                        T neg_time = -sub_dt ;
                        if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , neg_time);
                        else
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , neg_time,fe_data_Lagrange);

                    }

                    sub_time += sub_dt ;

                }
                std::cout<<'\n'<<std::endl;
                tot_time -= sub_time ; // the new time is substracted

            }


            //-------------------------- NEW CALCULATION OF U*N --------------------------

            // Updating continuous normal function
            level_set_function.gradient_continuous_setting() ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);

            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            }
            else
            {
                move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i;
            u_projected.set_agglo_mesh( msh_i );


            max_u_n_val = 0.0 ;
            max_u_n_val_abs = 0.0 ;
            l1_normal_interface_status = 0. ;
            l2_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh_i.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        if( std::abs(u_n_val) == max_u_n_val_abs )
                            max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        l2_normal_interface_status += pow(u_n_val,2.0);
                        counter_interface_pts ++ ;

                    }
                }
            }


            max_u_n_val_new = max_u_n_val ;


            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
            l1_normal_interface_status /= counter_interface_pts;
            l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

            std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
            std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
            std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

            std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;



        }


        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;



        // PLOTTING OF NORMAL

        postprocess_output<double> postoutput_vec;
        auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

        postprocess_output<double> postoutput_div2;

        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(tot_time) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

        std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
        std::vector< point<T, 2> > interface_points_plot_fin ;
        std::vector< std::pair<T,T> > interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field;





        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
            {

                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                auto qps_fin = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                for(auto& qp:qps_fin){
                    mass_fin += qp.second * ls_cell(qp.first);
                    centre_mass_x += qp.second * qp.first.x() ;
                    centre_mass_y += qp.second * qp.first.y() ;
                }

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    T val0 = ls_cell.divergence( *interface_point );
                    T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                    l1_divergence_error_fin += curvature_error ;
                    l2_divergence_error_fin += pow(curvature_error,2) ;
                    linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                    interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;
                    vec_normal_grad_cont_fin->add_data(*interface_point,normal_vec_grad_cont);

                    interface_points_plot_fin.push_back( *(interface_point) ) ;
                    val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;


                    //    counter_interface_pts++;
                }

                T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                l1_divergence_error_fin += curvature_error ;
                l2_divergence_error_fin += pow(curvature_error,2) ;
                linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;

                vec_normal_grad_cont_fin->add_data( *(cl.user_data.interface.end()-1) ,normal_vec_grad_norm);


                interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                //    counter_interface_pts++;

            }
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }


        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);

                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);


                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }


        postoutput_div2.add_object(test_curv_var_divergence0);
        postoutput_div2.add_object(test_curv_var_cell);
        postoutput_div2.write();


        postoutput_vec.add_object(vec_normal_grad_cont_fin);
        postoutput_vec.write();

        goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field , time_step ) ;
            //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
        if(time_step == T_N)
            testing_level_set_time(msh,level_set_function, tot_time,time_step);


        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts;
        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;






        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;


    } // End of the temporal loop

    plotting_in_time( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M );
    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;
    return 0;
}
#endif



// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 29/09/2020 -> DISCONTINUOUS IMPLEMENTATION
// ---- > dt_M (CHECK OF THE MAXIMUM TIME STEP)
// ---- > normal_interface_status CORRECT !!!!
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    //RealType d = 0.5;
    size_t T_N = 0;
    /* k <deg>:     method degree
     * g<deg>:  method FEM degree
     * M <num>:     number of cells in x direction
     * N <num>:     number of cells in y direction
     * r <num>:     number of interface refinement steps
     *
     * i:           solve interface problem
     * f:           solve fictitious domain problem
     *
     * D:           use node displacement to solve bad cuts (default)
     * A:           use agglomeration to solve bad cuts
     *
     * d:           dump debug data
     */

    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();

    //system("mkdir stefano_folder'");
    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Mesh size = "<<mip.Nx<<"x"<<mip.Ny<<std::endl;
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;
    /*
    timecounter tbb_time ;
    tbb_time.tic();
    tbb::parallel_for(size_t(0), size_t(msh.cells.size()), size_t(1),
        [&msh] (size_t & cell_ind){
                auto& cell = msh.cells[cell_ind];
                 }
        );

    tbb_time.toc();
    std::cout<<"time cells parall= "<<tbb_time<<std::endl;

    tbb_time.tic();
    int sum = 0;
    tbb::parallel_for(size_t(0), size_t(10000), size_t(1),
        [&sum] (size_t & cell_ind){
                sum += cell_ind;
                 }
        );

    tbb_time.toc();
    std::cout<<"time sum= "<<tbb_time<<std::endl;


    tbb_time.tic();

    for (size_t cell_ind = 0; cell_ind < msh.cells.size(); cell_ind++)
    {
        auto& cell = msh.cells[cell_ind];
    }
    tbb_time.toc();

    std::cout<<"time cls seq= "<<tbb_time<<std::endl;

    tbb_time.tic();
    int sum2 = 0;
    for (size_t cell_ind = 0; cell_ind <10000; cell_ind++)
    {
        sum2 += cell_ind;
    }
    tbb_time.toc();

    std::cout<<"time sum2= "<<tbb_time<<std::endl;
   */

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;


    /**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
    //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;



    /************** ANALYTIC LEVEL SET FUNCTION  **************/
    typedef RealType T;

    bool circle = true , ellipse = false ;

    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //RealType C ;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/3.0-eps_circ;
        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM.

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    //std::cout<<"Initial interface: CIRCLE"<<std::endl;
    //auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    //typedef  circle_level_set<T> Fonction;

    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;
    bool flower = true ;

    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //std::cout<<"Initial interface: ELLIPSE"<<std::endl;
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;



    /**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ; //10 ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/
    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;
    std::cout<<"Level set: high order Berstein Vandermonde interpolated. Discontinuous divergence."<<std::endl;
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);

    auto level_set_function = Level_set_berstein_high_order_interpolation_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //level_set_function.gradient_continuous_setting(method_transport_pb) ;

    /************** LEVEL SET  MAPPING **************/
    bool mapping = false ; // if mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );



    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);
    //Mesh msh_tmp =  crr_mesh.current_mesh;  // MESH at t=t^n+1 (FOR POST-PROCESSING)
    //offset_definition(msh_tmp);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.; // Initialisation Area , Mass for t = 0
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    // NOTICE: The sequential detect_node_position3 is faster than the parallel one: PROVED IN DEBUG MOD, IN RELEASE WILL IT BE THE SAME???
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom

    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom

    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        move_nodes(msh_i, level_set_function);
        //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface2(msh_i, level_set_function, int_refsteps);
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3(msh_i, level_set_function, int_refsteps);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }


    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    //level_set_function.gradient_continuous_setting(method_transport_pb) ;

    //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
    //typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
    //typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > Level_Set;
    typedef Level_set_berstein_high_order_interpolation_fast< Mesh , Fonction , FiniteSpace , T > Level_Set;

    auto ls_cell = LS_cell_high_order_fast< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();


    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;


    postprocess_output<double> postoutput_vec;
    auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    size_t counter_interface_pts = 0;

    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
            {


                T val0 = ls_cell.divergence( *interface_point );
                T error_curvature = std::abs( val0 + 1.0/radius) ;
                l1_divergence_error += error_curvature;
                l2_divergence_error += pow(error_curvature,2) ;
                linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);

                perimeter_initial += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                interface_points_plot.push_back(*(interface_point)) ;


                counter_interface_pts++;

            }

            T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));

            T error_curvature = std::abs( val0 + 1.0/radius) ;
            l1_divergence_error += error_curvature;
            l2_divergence_error += pow(error_curvature,2) ;
            linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;


            Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
            std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
            interface_normals.push_back( normal_vec_grad_cont ) ;

            vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;



            counter_interface_pts++;

        }



    }

    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() )
                        test_curv_var_cell->add_data(curv_var, val0);

                    test_curv_var_divergence0->add_data(curv_var, val0);

                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                    {
                        ls_cell.cell_assignment(cl);
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.write();

    postoutput_vec.add_object(vec_normal_grad_cont);
    postoutput_vec.write();



    if(!flower)
    {
        l1_divergence_error /= counter_interface_pts;

        l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;
        l1_err_curvature_time.push_back(l1_divergence_error) ;
        linf_err_curvature_time.push_back(linf_divergence_error) ;
    }

    std::cout <<bold<<yellow << '\n' << "Initial time, AREA  = "<< initial_area << reset << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;


    if(flower)
    {
        T l1_divergence_error_flower = 0. , l2_divergence_error_flower = 0. ;
        T linf_divergence_error_flower = -10. ;
        radius = sqrt( initial_area/M_PI ) ;
        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl) ;

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_flower += error_curvature;
                    l2_divergence_error_flower += pow(error_curvature,2) ;
                    linf_divergence_error_flower = std::max(linf_divergence_error_flower , error_curvature ) ;

                }
            }
        }
        l1_divergence_error_flower /= counter_interface_pts;

        l2_divergence_error_flower = sqrt(l2_divergence_error_flower/counter_interface_pts);

        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error_flower<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error_flower <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error_flower<<reset <<std::endl;

        l1_err_curvature_time.push_back(l1_divergence_error_flower) ;
        linf_err_curvature_time.push_back(linf_divergence_error_flower) ;
    }




    time_vec.push_back(0) ;
    area_time.push_back(initial_area) ;

    T dt_M ;

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration, time t = "<<tot_time<<reset <<std::endl;
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        testing_level_set_time(msh,level_set_function,tot_time,time_step);



        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);


        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);


        //timecounter tc_u ;
        //tc_u.tic();
        stokes_test_info<T> TI;
        if(solve_interface){

            //bool normal_analysis =  true ;
            //TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        //tc_u.toc();

        //std::cout << "Machine Time for solving STOKES PB: " << tc_u << " seconds" << std::endl;





        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if(0)
            std::cout<<bold<<green<<"CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"<<reset<<std::endl;

        if( 1 ) //1 FIRST RESULT WITH THIS
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh , method_transport_pb);
        }
        //testing_velocity_field(msh , u_projected) ;

        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;




        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------

        auto level_set_tmp = Level_set_berstein_high_order_interpolation_fast< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_fast< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        //auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        //if(tot_time < 0.75)
        dt_M = 8*1e-3; // 4*1e-3;
        //else
        //    dt_M = 1e-3;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt_one_cell = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;

        //T sub_dt;
        //if(tot_time <0.132)
        //    sub_dt = std::min(4*1e-4 , dt ) ;
        //else
        //    sub_dt = std::min(5*1e-5 , dt ) ;

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        /*
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else{
                if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  );
                else
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  , fe_data_Lagrange);

            }
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        */
        //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        // ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , mapping );

            }
            else{
                //if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  sub_dt  );
                //else
                //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

            }


            sub_time += sub_dt ;

        }
        tot_time += sub_time ;


       /**************************************************   POST-PROCESSING **************************************************/


        // Updating continuous normal function
        //level_set_function.gradient_continuous_setting(method_transport_pb) ;
        // Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
            refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration(msh_i, level_set_function); // Non serve modificarla
        }
        else
        {
            move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i2, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
            refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh( msh_i );


        T max_u_n_val = 0.0 ;
        T max_u_n_val_abs = 0.0 ;
        T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;


        size_t counter_interface_pts = 0;
        for(auto& cl : msh_i.cells)
        {
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                    max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                    if( std::abs(u_n_val) == max_u_n_val_abs )
                        max_u_n_val = u_n_val ;

                    l1_normal_interface_status += std::abs(u_n_val) ;
                    l2_normal_interface_status += pow(u_n_val,2.0);
                    counter_interface_pts ++ ;

                }
            }
        }

        if( time_step == 0 )
            max_u_n_val_new = max_u_n_val ;

        if(time_step > 0 )
        {
            max_u_n_val_old = max_u_n_val_new ;
            max_u_n_val_new = max_u_n_val ;
            std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
        }

        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;
        l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
        std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
        std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
        std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;




        if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
        {
            std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
            //exit(9) ;
        }

        //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

        //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
        if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
        {




            // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
            // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
            T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
            T dt_new = std::min(dt_one_cell , dt_M_new);

            bool forward = TRUE ;
            if( forward ) // GO FORWARD FROM THE TIME t^n
            {
                dt = dt_new ;

                std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                tot_time -= sub_time ; // I erase the time previously calculated
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {

                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb ,  sub_dt  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);


                    }


                    sub_time += sub_dt ;

                }

                tot_time += sub_time ; // the new time is substracted
                level_set_function = level_set_tmp ;
                std::cout<<'\n'<<std::endl;
                //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
            }
            else // GO BACKWARD FROM THE TIME t^n + dt_M
            {

                dt = dt_M - dt_new ;
                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    T neg_time = -sub_dt ;
                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  neg_time  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time  , fe_data_Lagrange);


                    }



                    sub_time += sub_dt ;

                }
                std::cout<<'\n'<<std::endl;
                tot_time -= sub_time ; // the new time is substracted

            }


            //-------------------------- NEW CALCULATION OF U*N --------------------------

            // Updating continuous normal function
            //level_set_function.gradient_continuous_setting(method_transport_pb) ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);

            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            }
            else
            {
                move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                refine_interface_pro3(msh_i, level_set_function, int_refsteps);
            }

            tc.toc();
            std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i;
            u_projected.set_agglo_mesh( msh_i );


            max_u_n_val = 0.0 ;
            max_u_n_val_abs = 0.0 ;
            l1_normal_interface_status = 0. ;
            l2_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh_i.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        if( std::abs(u_n_val) == max_u_n_val_abs )
                            max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        l2_normal_interface_status += pow(u_n_val,2.0);
                        counter_interface_pts ++ ;

                    }
                }
            }


            max_u_n_val_new = max_u_n_val ;


            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
            l1_normal_interface_status /= counter_interface_pts;
            l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

            std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
            std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
            std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

            std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;



        }


        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;



        // PLOTTING OF NORMAL



        postprocess_output<double> postoutput_div2;

        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

        std::vector<T> val_u_nx_fin , val_u_ny_fin , val_u_n_fin ;
        std::vector< point<T, 2> > interface_points_plot_fin ;
        std::vector< std::pair<T,T> > interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field;





        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
            {

                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                auto qps_fin = integrate( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);

                for(auto& qp:qps_fin){
                    mass_fin += qp.second * ls_cell(qp.first);
                    centre_mass_x += qp.second * qp.first.x() ;
                    centre_mass_y += qp.second * qp.first.y() ;
                }

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perimeter += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    T val0 = ls_cell.divergence( *interface_point );
                    T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                    l1_divergence_error_fin += curvature_error ;
                    l2_divergence_error_fin += pow(curvature_error,2) ;
                    linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                     std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_cont_grad(0),normal_cont_grad(1));
                     interface_normals_grad_cont_fin.push_back( normal_vec_grad_cont ) ;



                    interface_points_plot_fin.push_back( *(interface_point) ) ;
                    val_u_nx_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) );
                    val_u_ny_fin.push_back( u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );
                    val_u_n_fin.push_back( u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) );

                    velocity_interface.push_back( std::make_pair(u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;


                    //    counter_interface_pts++;
                }

                T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                l1_divergence_error_fin += curvature_error ;
                l2_divergence_error_fin += pow(curvature_error,2) ;
                linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals_grad_cont_fin.push_back( normal_vec_grad_norm ) ;


                interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                val_u_nx_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) );
                val_u_ny_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );
                val_u_n_fin.push_back( u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) + u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) );

                velocity_interface.push_back( std::make_pair(u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                //    counter_interface_pts++;

            }
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }


        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);

                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);


                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }


        postoutput_div2.add_object(test_curv_var_divergence0);
        postoutput_div2.add_object(test_curv_var_cell);
        postoutput_div2.write();



        goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_grad_cont_fin , velocity_interface , velocity_field , points_vel_field , time_step ) ;
            //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;
        if(time_step == T_N)
            testing_level_set_time(msh,level_set_function, tot_time,time_step);


        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts;
        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;






        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;


    } // End of the temporal loop

    plotting_in_time( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M );
    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;

    tc_tot.toc();
    std::cout<<"Simulation time 0 t = "<<tc_tot <<std::endl;

    return 0;
}
#endif




// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 03/11/2020 -> (GRADIENT AND NORMAL CONTINUOUS + DIVERGENCE CONT/DISC )

// NEW CURVE INTEGRATION : CHECKING (OLD GOAL QUANTITIES). JUST USEFULL TO CHECK OLD IMPLEMENTATION, THEN DELETE
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;

    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    size_t T_N = 0;
    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef RealType T;
    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Mesh size = "<<mip.Nx<<"x"<<mip.Ny<<std::endl;
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

    /*
    auto cl = msh.cells[38];
    cell_basis_Lagrange_1d_reference<Mesh,RealType> cb_l(msh, cl, 3);
    RealType pt0 = 0.5;
    RealType pt1 = 0.0;
    RealType pt2 = 1.0;
    auto val0l = cb_l.eval_basis_1d(pt0) ;
    //auto val_physic0l = cb_l.eval_basis_curv(pt0);
    std::cout<<"val0l = "<<val0l<<std::endl;
    //std::cout<<"val_physic0l = "<<val_physic0l<<std::endl;
    
    auto val1l = cb_l.eval_basis_1d(pt1) ;
    //auto val_physic1l = cb_l.eval_basis_curv(pt1);
    std::cout<<"val1l = "<<val1l<<std::endl;
    //std::cout<<"val_physic1l = "<<val_physic1l<<std::endl;
    
    auto val2l = cb_l.eval_basis_1d(pt2) ;
    //auto val_physic2l = cb_l.eval_basis_curv(pt2);
    std::cout<<"val2l = "<<val2l<<std::endl;
    //std::cout<<"val_physic2l = "<<val_physic2l<<std::endl;
              
    auto val0ldd = cb_l.eval_double_derivative_1d(pt0) ;
    std::cout<<"val0ldd = "<<val0ldd<<std::endl;
    auto val1ldd = cb_l.eval_double_derivative_1d(pt1) ;
    std::cout<<"val1ldd = "<<val1ldd<<std::endl;
    auto val2ldd = cb_l.eval_double_derivative_1d(pt2) ;
    std::cout<<"val2ldd = "<<val2ldd<<std::endl;
              
      
              
    auto derval0l = cb_l.eval_gradients_1d(pt0) ;
    std::cout<<"derval0l = "<<derval0l<<std::endl;
    //auto val_physicder0l = cb_l.eval_gradients_curv(0.0);
    //          std::cout<<"val_physicder0l = "<<val_physicder0l<<std::endl;
    auto derval1l = cb_l.eval_gradients_1d(pt1) ;
    std::cout<<"derval1l = "<<derval1l<<std::endl;
    //          auto val_physicder1l = cb_l.eval_gradients_curv(1.0);
    //          std::cout<<"val_physicder1l = "<<val_physicder1l<<std::endl;
    auto derval2l = cb_l.eval_gradients_1d(pt2) ;
    std::cout<<"derval2l = "<<derval2l<<std::endl;
      //        auto val_physicder2l = cb_l.eval_gradients_curv(-1.0);
     //         std::cout<<"val_physicder2l = "<<val_physicder2l<<std::endl;
   
    */
    
    /**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
    //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t  degree_gradient = degree_FEM - 1 ;
    auto fe_data_gradient = Finite_Element<RealType,Mesh>( msh , degree_gradient , mip ) ;
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;

    size_t  degree_div = degree_FEM - 1 ;
    std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
    auto fe_data_div = Finite_Element<RealType,Mesh>( msh , degree_div , mip ) ;
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


    /************** ANALYTIC LEVEL SET FUNCTION  **************/
   

    bool circle = true , ellipse = false ;
    bool flower = false ;
    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        //radius_a = 1.0/6.0;
        //radius_b = 1.0/12.0;
        T eps_circ = 1e-4;
        radius_a = 1.0/3.0-eps_circ;
        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    
    std::cout<<"Initial interface: CIRCLE"<<std::endl;
    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
    typedef  circle_level_set<T> Fonction;
    
    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    /*
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;
    flower = true ;
     
    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
    //std::cout<<"Initial interface: ELLIPSE"<<std::endl;
    //auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
    //typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;
     
      */


    /**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/


    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;
    auto level_set_function = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );
    
    
    typedef Level_set_berstein< Mesh , Fonction , FiniteSpace , T > Level_Set;
    T degree_curve = 2 ;
    auto curve = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
   
    
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
   //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);



     // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
    // IF DIVERGENCE CONTINUOUS
    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;

    /************** LEVEL SET  MAPPING **************/
    // If mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    bool mapping = false ;
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );



    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.;
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
    
    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
        set_integration_mesh(msh_i,degree_curve) ;
        T area_prova = 0. , perimeter_prova0 = 0. , perimeter_prova1 = 0. , perimeter_prova2 = 0.  ;
        T area_prova_tot = 0. , area_prova_old = 0. ;
        T mass_prova = 0. , c_mass_prova_x = 0. , c_mass_prova_y = 0. ;
        T mass_prova_old = 0. , c_mass_prova_x_old = 0. , c_mass_prova_y_old = 0. ;
        for(auto& cl : msh_i.cells)
        {
            if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
            {
//                std::cout<<"cl = "<<offset(msh_i,cl)<<std::endl;
//                auto pts = points( msh_i , cl);
//
//                for(auto& pt: pts)
//                    std::cout<<"Cell pt = "<<'\n'<<pt<<std::endl;
                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                T partial_area_old = measure_old( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_prova += partial_area;
                area_prova_old += partial_area_old;
                
                auto qps = integrate( msh_i , cl , 2*degree_FEM , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps){
                    mass_prova += qp.second * level_set_function(qp.first,msh,cl);
                    c_mass_prova_x += qp.second * qp.first.x() ;
                    c_mass_prova_y += qp.second * qp.first.y() ;
                }
                auto qps_old = integrate_old( msh_i , cl , 2*degree_FEM+1 , element_location::IN_NEGATIVE_SIDE);
                for(auto& qp:qps_old){
                    mass_prova_old += qp.second * level_set_function(qp.first,msh,cl);
                    c_mass_prova_x_old += qp.second * qp.first.x() ;
                    c_mass_prova_y_old += qp.second * qp.first.y() ;
                }
                
                if( location(msh_i, cl) == element_location::ON_INTERFACE )
                {
                    T partial_area_pos = measure( msh_i, cl, element_location::IN_POSITIVE_SIDE);
                    area_prova_tot += partial_area_pos;
                }
                
                
                
                if( location(msh_i, cl) == element_location::ON_INTERFACE )
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                    {


                        perimeter_prova0 += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        


                    }
                    auto qps1 =integrate_interface(msh_i, cl, degree_curve, element_location::IN_NEGATIVE_SIDE);
                    auto qps2 =  integrate_interface_old(msh_i, cl, degree_curve, element_location::IN_NEGATIVE_SIDE);
                    for (auto& qp : qps1)
                    {
                        perimeter_prova1 += qp.second ;
                
                    }
                    for (auto& qp : qps2)
                    {
                            perimeter_prova2 += qp.second ;
                    
                    }
                    
                    /*
                    for(auto& cl_i : cl.user_data.integration_msh.cells)
                    {
                        std::cout<<"cl = "<<offset(cl.user_data.integration_msh,cl_i)<<std::endl;
                        auto pts = points( cl.user_data.integration_msh , cl_i);
                        auto nds = nodes( cl.user_data.integration_msh , cl_i);
                        for(auto& pt: pts)
                            std::cout<<"pt = "<<'\n'<<pt<<std::endl;
                        for(auto& nd: nds)
                            std::cout<<"nd = "<<'\n'<<nd<<std::endl;
                        std::cout<<'\n'<<std::endl;
                    }
                    */
                }
            }
            else
            {
                T partial_area_pos = measure( msh_i, cl);
                area_prova_tot += partial_area_pos;
            }

            
        }
        area_prova_tot += area_prova;
        std::cout<<"area_tot = "<<area_prova_tot<<std::endl;
        std::cout<<"Err area_tot = "<<1.0 - area_prova_tot <<std::endl;
        
        std::cout<<"ANALYTICAL area = "<<M_PI*radius*radius<<std::endl;
        
        std::cout<<"ERRORE PERCENTUALE area NUOVA = "<<std::abs(M_PI*radius*radius-area_prova)/(M_PI*radius*radius)*100<<std::endl;
        std::cout<<"ERRORE PERCENTUALE area VECCHIA = "<<std::abs(M_PI*radius*radius-area_prova_old)/(M_PI*radius*radius)*100<<std::endl;
        std::cout<<"area NEW = "<<area_prova<<std::endl;
        std::cout<<"ERROR area NEW = "<<std::abs(M_PI*radius*radius - area_prova)<<std::endl;
        std::cout<<"area OLD = "<<area_prova_old<<std::endl;
        std::cout<<"ERROR area OLD = "<<std::abs(M_PI*radius*radius - area_prova_old)<<'\n'<<std::endl;
        
        std::cout<<"ANALYTICAL perimiter = "<<2*M_PI*radius<<std::endl;
        std::cout<<"perimeter NEW = "<<perimeter_prova1<<std::endl;
        std::cout<<"ERROR perimeter NEW = "<<std::abs(2*M_PI*radius - perimeter_prova1)<<std::endl;
        std::cout<<"perimeter OLD = "<<perimeter_prova2<<std::endl;
        std::cout<<"ERROR perimeter OLD = "<<std::abs(2*M_PI*radius - perimeter_prova2)<<'\n'<<std::endl;
        
        //std::cout<<"ANALYTICAL perimiter = "<<2*M_PI*radius<<std::endl;
        std::cout<<"mass NEW = "<<mass_prova<<std::endl;
        //std::cout<<"ERROR perimeter NEW = "<<std::abs(2*M_PI*radius - perimeter_prova1)<<std::endl;
        std::cout<<"mass OLD = "<<mass_prova_old<<std::endl;
        T area_circle = M_PI*radius*radius ;
        T m1 = c_mass_prova_x/(area_circle) ;
        T m2 = c_mass_prova_x_old/area_circle ;
        T m3 = c_mass_prova_y/area_circle ;
        T m4 = c_mass_prova_y_old/area_circle ;
        std::cout<<"c_mass_prova_x NEW = "<<m1<<std::endl;
        std::cout<<"c_mass_prova_x_old OLD = "<<m2<<std::endl;
        std::cout<<"c_mass_prova_y NEW = "<<m3<<std::endl;
        std::cout<<"c_mass_prova_y_old OLD = "<<m4<<std::endl;
        std::cout<<"DIFF c_mass_prova_x = "<<m1-m2<<std::endl;
        std::cout<<"DIFF c_mass_prova_y = "<<m3-m4<<std::endl;
       
        
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_angle(msh_i, level_set_function, int_refsteps);
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
       
        make_agglomeration_no_double_points(msh_i, level_set_function,degree_curve);
        set_integration_mesh(msh_i,degree_curve) ; // TOLTO PER IL MOMENTO SENNO RADDOPPIO
        //make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        //move_nodes(msh_i, level_set_function);
        //detect_cut_faces2(msh_i, level_set_function); //do it again to update intersection points
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }

    
/*
    for(auto& cl : msh_i.cells)
    {
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            if(0)
            {
                auto msh_int =  integration_mesh<T>(degree_curve);
                msh_int.set_cell(cl);
                cl.user_data.integration_msh = msh_int ;
            }
            else
                cl.user_data.integration_msh.set_cell_new(cl,degree_curve);
            
            for(auto& cl_i : cl.user_data.integration_msh.cells)
            {
                std::cout<<"cl = "<<offset(cl.user_data.integration_msh,cl_i)<<std::endl;
                auto pts = points( cl.user_data.integration_msh , cl_i);
                auto nds = nodes( cl.user_data.integration_msh , cl_i);
                for(auto& pt: pts)
                    std::cout<<"pt = "<<'\n'<<pt<<std::endl;
                for(auto& nd: nds)
                    std::cout<<"nd = "<<'\n'<<nd<<std::endl;
                std::cout<<'\n'<<std::endl;
            }
            
        }
        
    }
    */
    /*
    for(auto& cl : msh_i.cells)
    {
        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            
            auto msh_int =  integration_mesh_cl<T,typename Mesh::cell_type >(cl,degree_curve);
            cl.user_data.integration_msh = msh_int ;
        }
        
    }
    */

    

    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    // IF GRADIENT CONTINUOUS
    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
    // IF DIVERGENCE CONTINUOUS
    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

    
    //typedef Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > Level_Set;
    //typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
     //typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > Level_Set;

    // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\
    // IF grad cont -> normal cont -> (divergence disc) -> divergence cont
    //auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    // IF grad cont -> normal cont -> divergence disc
    auto ls_cell = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    // IF grad cont -> normal cont -> divergence disc
    //auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();
    
    
    // ---------------------------------- CHECK bernstein 1d  -----------------------------------
    T tot = degree_curve ; // 100
    std::vector<Matrix<T,2,1>> interface_gamma ;
    std::vector<Matrix<T,2,1>> tangent_gamma  , normal_gamma;
    std::vector<T > curvature_gamma ;
    postprocess_output<double> postoutput ;
    auto interface_gamma_plot = std::make_shared< gnuplot_output_object<double> >("curve_interface_para.dat");
     auto curvature_plot = std::make_shared< gnuplot_output_object<double> >("curvature_para.dat");
    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::ON_INTERFACE )
        {
            curve.cell_assignment(cl);
            auto pts_int = cl.user_data.interface ;
            auto pts = points(msh, cl);
            /*
            std::cout<<"Cell "<<offset(msh_i,cl)<<" pts:"<<std::endl;
            auto pts = points(msh, cl);
            for(auto& pt : pts)
                std::cout<<pt<<std::endl;
            std::cout<<"Interfacea pts:"<<std::endl;
            
            for(auto& pt : pts_int)
                std::cout<<pt<<std::endl;
                       
            std::cout<<'\n'<<std::endl;
            */
             if( pts_int.size() == degree_curve + 1 ) // if( curve.subcells.size()<1 )
             {
                //std::cout<<"curve.subcells.size() = "<<curve.subcells.size()<<std::endl;
                for(int i= 0; i <= tot ; i++)
                {
                    T pos = 0.0+i/tot ;
                     interface_gamma.push_back( curve(pos,msh_i,cl) ) ;
                    //std::cout<<"pos = "<<pos<<" , curve(pos,msh_i,cl) = "<<curve(pos,msh_i,cl)<<std::endl;
                    point<T,2> curv_var0 = point_type(curve(pos,msh_i,cl)(0), curve(pos,msh_i,cl)(1));
                    interface_gamma_plot->add_data(curv_var0,0.0);
                    curvature_plot->add_data(curv_var0,curve.curvature(pos, msh_i, cl));
                    curvature_gamma.push_back( curve.curvature(pos,msh_i,cl) ) ;
                    tangent_gamma.push_back( curve.tangent(pos,msh_i,cl) ) ;
                    normal_gamma.push_back( curve.normal(pos,msh_i,cl) ) ;
                }
                /*
                interface_gamma.push_back( curve(0,msh_i,cl) ) ;
                interface_gamma.push_back( curve(1,msh_i,cl) ) ;
                interface_gamma.push_back( curve(-1,msh_i,cl)) ;
                point<T,2> curv_var0 = point_type(curve(0,msh_i,cl)(0), curve(0,msh_i,cl)(1));
                point<T,2> curv_var1 = point_type(curve(1,msh_i,cl)(0), curve(1,msh_i,cl)(1));
                point<T,2> curv_var2 = point_type(curve(-1,msh_i,cl)(0), curve(-1,msh_i,cl)(1));
                
                interface_gamma_plot->add_data(curv_var0,0.0);
                interface_gamma_plot->add_data(curv_var1,0.0);
                interface_gamma_plot->add_data(curv_var2,0.0);
                 */
            }
            else
            {
                size_t tot_cls = (pts_int.size()-1)/ (degree_curve )  ;
                //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                    //std::cout<<"curve.subcells.size() = "<<curve.subcells.size()<<" , cell_ind = "<<cell_ind<<std::endl;
                    
                    for(int i= 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        //if(i== 0 && cell_ind>0)
                        //    continue;
                        //std::cout<<"pos = "<<pos<<" , curve(pos,msh_i,cl) = "<<curve(pos,msh_i,cl,cell_ind)<<std::endl;
                         interface_gamma.push_back( curve(pos,msh_i,cl,cell_ind) ) ;
                        point<T,2> curv_var0 = point_type(curve(pos,msh_i,cl,cell_ind)(0), curve(pos,msh_i,cl,cell_ind)(1));
                        interface_gamma_plot->add_data(curv_var0,0.0);
                        curvature_plot->add_data(curv_var0,curve.curvature(pos, msh_i, cl,cell_ind));
                        curvature_gamma.push_back( curve.curvature(pos,msh_i,cl,cell_ind) ) ;
                        tangent_gamma.push_back( curve.tangent(pos,msh_i,cl,cell_ind) ) ;
                        normal_gamma.push_back( curve.normal(pos,msh_i,cl,cell_ind) ) ;
                        /*
                        if(offset(msh_i,cl)==65)
                        {
                            std::cout<<"curvature = "<<curve.curvature(pos,msh_i,cl,cell_ind)<<" , tangent = "<<curve.tangent(pos,msh_i,cl,cell_ind)<<" , nromal = "<<curve.normal(pos,msh_i,cl,cell_ind)<<std::endl;
                        }
                         */
                        
                    }
                    /*
                    interface_gamma.push_back( curve(0,msh_i,cl,cell_ind) ) ;
                    interface_gamma.push_back( curve(1,msh_i,cl,cell_ind) ) ;
                    interface_gamma.push_back( curve(-1,msh_i,cl,cell_ind)) ;
                    
                    point<T,2> curv_var0 = point_type(curve(0,msh_i,cl)(0), curve(0,msh_i,cl)(1));
                    point<T,2> curv_var1 = point_type(curve(1,msh_i,cl)(0), curve(1,msh_i,cl)(1));
                    point<T,2> curv_var2 = point_type(curve(-1,msh_i,cl)(0), curve(-1,msh_i,cl)(1));
                    
                    interface_gamma_plot->add_data(curv_var0,0.0);
                    interface_gamma_plot->add_data(curv_var1,0.0);
                    interface_gamma_plot->add_data(curv_var2,0.0);
                     */
                }
                
            }
            
        }
           
           
    }

    postoutput.add_object(interface_gamma_plot);
    postoutput.add_object(curvature_plot);
    postoutput.write();
    goal_quantities_time_fast(msh , interface_gamma , tangent_gamma  , normal_gamma , curvature_gamma  );
    postprocess_output<double> postoutput_div_para;
    std::string filename_curvature_para = "k0_curvature_para.dat";
    auto test_curvature_para = std::make_shared< gnuplot_output_object<double> >(filename_curvature_para);

    std::string filename_curv_var_para = "cell_limit_curv_var_para.dat";
    auto test_curv_var_para = std::make_shared< gnuplot_output_object<double> >(filename_curv_var_para);

    std::vector< point<T, 2> > interface_points_plot_para ;
    std::vector< std::pair<T,T> > interface_normals_para ;
    T l1_divergence_error_para = 0. , l2_divergence_error_para = 0. ;
    T linf_divergence_error_para = -10. ;
    size_t counter_interface_pts_para = 0;

    for(auto& cl : msh_i.cells)
    {
       
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

           if( cl.user_data.interface.size() == degree_FEM + 1 ) // if( curve.subcells.size()<1 )
            {
                for(int i= 0; i <= tot ; i++)
                {
                    T pos = 0.0+i/tot ;
                    T val0 = curve.curvature(pos,msh_i,cl) ;
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_para += error_curvature;
                    l2_divergence_error_para += pow(error_curvature,2) ;
                    linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                     counter_interface_pts_para++;
                        
                }
            }
            else
            {
                //size_t tot_cls = cl.user_data.interface.size()/ (degree_FEM + 1.0)  ;
                size_t tot_cls = (cl.user_data.interface.size()-1)/ (degree_curve )  ;
                //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                    for(int i= 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        T val0 = curve.curvature(pos,msh_i,cl,cell_ind) ;
                        T error_curvature = std::abs( val0 + 1.0/radius) ;
                        
                        l1_divergence_error_para += error_curvature;
                        l2_divergence_error_para += pow(error_curvature,2) ;
                        linf_divergence_error_para = std::max(linf_divergence_error_para , error_curvature ) ;
                         counter_interface_pts_para++;
                                      
                                    
                    }
                }
            }
          

           

        }



    }

    bool first_cut_cell_found_para = FALSE ;
    T distance_pts_para = 0.0;
    point<T,2> first_point_para ;
    point<T,2> cell_end_point_para;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            
            if(!first_cut_cell_found_para)
            {
                if( cl.user_data.interface.size() == degree_FEM + 1 ) // if( curve.subcells.size()<1 )
                {
                    for(int i= 0; i <= tot ; i++)
                    {
                        T pos = 0.0+i/tot ;
                        T val0 = curve.curvature(pos,msh_i,cl) ;
                        //T error_curvature = std::abs( val0 + 1.0/radius) ;
                         point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                        if( pos==0)
                            test_curvature_para->add_data(curv_var, val0);

                        test_curv_var_para->add_data(curv_var, val0);

                        distance_pts_para += i/tot ;
                            
                    }
                }
                else
                {
                    //size_t tot_cls = cl.user_data.interface.size()/ (degree_FEM + 1.0)  ;
                    size_t tot_cls = (cl.user_data.interface.size()-1)/ (degree_curve )  ;
                    //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                    for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                        for(int i= 0; i <= tot ; i++)
                        {
                            T pos = 0.0+i/tot ;
                                                   
                            T val0 = curve.curvature(pos,msh_i,cl) ;
                            //T error_curvature = std::abs( val0 + 1.0/radius) ;
                            point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                            if( pos==0)
                                test_curvature_para->add_data(curv_var, val0);

                            test_curv_var_para->add_data(curv_var, val0);
                            distance_pts_para += i/tot ;
                                          
                                        
                        }
                    }
                }
                
                first_cut_cell_found_para = TRUE;
                first_point_para = *cl.user_data.interface.begin() ;
                cell_end_point_para = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found_para && !( first_point_para == cell_end_point_para  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point_para ==*cl.user_data.interface.begin() )  )
                    {
                        if( cl.user_data.interface.size() == degree_FEM + 1 ) // if( curve.subcells.size()<1 )
                        {
                            for(int i= 0; i <= tot ; i++)
                            {
                                T pos = 0.0+i/tot ;
                                T val0 = curve.curvature(pos,msh_i,cl) ;
                                //T error_curvature = std::abs( val0 + 1.0/radius) ;
                                 point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                if( pos==0)
                                    test_curvature_para->add_data(curv_var, val0);

                                test_curv_var_para->add_data(curv_var, val0);

                                distance_pts_para += i/tot ;
                                
                                    
                            }
                        }
                        else
                        {
                           //size_t tot_cls = cl.user_data.interface.size()/ (degree_FEM + 1.0)  ;
                            size_t tot_cls = (cl.user_data.interface.size()-1)/ (degree_curve )  ;
                            //std::cout<<"tot_cls = "<<tot_cls<<std::endl;
                            for(size_t cell_ind = 0 ; cell_ind < tot_cls ; cell_ind++ ){
                                              
                                for(int i= 0; i <= tot ; i++)
                                {
                                    T pos = 0.0+i/tot ;
                                                           
                                    T val0 = curve.curvature(pos,msh_i,cl) ;
                                    //T error_curvature = std::abs( val0 + 1.0/radius) ;
                                    point<T,2> curv_var = point_type(distance_pts_para , 0.0);
                                    if( pos==0)
                                        test_curvature_para->add_data(curv_var, val0);

                                    test_curv_var_para->add_data(curv_var, val0);
                                    distance_pts_para += i/tot ;
                                                  
                                                
                                }
                            }
                        }
                       
                        cell_end_point_para = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div_para.add_object(test_curvature_para);
    postoutput_div_para.add_object(test_curv_var_para);
    postoutput_div_para.write();
    l1_divergence_error_para /= counter_interface_pts_para;

    l2_divergence_error_para = sqrt(l2_divergence_error_para/counter_interface_pts_para);
    std::cout<<"Number of interface points is " << counter_interface_pts_para << std::endl;
    std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error_para<<reset <<std::endl;
    std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error_para <<std::endl;
    std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error_para<<reset <<std::endl;
    
    
    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;
    std::vector<T> circularity_time , flux_interface_time , perimeter_time;
    std::vector<std::pair<T,T>> centre_mass_err_time , rise_velocity_time , min_max_vec ;

    //postprocess_output<double> postoutput_vec;
    //auto vec_normal_grad_cont = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes.dat");

    postprocess_output<double> postoutput_div2;
    std::string filename_curvature_k0 = "k0_curvature_initial.dat";
    auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);

    std::string filename_curv_var = "cell_limit_curv_var_initial.dat";
    auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

    std::vector< point<T, 2> > interface_points_plot ;
    std::vector< std::pair<T,T> > interface_normals ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    size_t counter_interface_pts = 0;

    for(auto& cl : msh_i.cells)
    {
        ls_cell.cell_assignment(cl);
        //u_projected.cell_assignment(cl);

        if( location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_i, cl) == element_location::ON_INTERFACE )
        {
//            std::cout<<"cl = "<<offset(msh_i,cl)<<std::endl;
//             auto pts = points( msh_i , cl);
//
//             for(auto& pt: pts)
//                 std::cout<<"Cell pt = "<<'\n'<<pt<<std::endl;
            
            T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
            
            initial_area += partial_area;
            auto qps = integrate( msh_i , cl , 2*degree_FEM , element_location::IN_NEGATIVE_SIDE);
            for(auto& qp:qps){
                initial_mass += qp.second * ls_cell(qp.first);
                centre_mass_x_inital += qp.second * qp.first.x() ;
                centre_mass_y_inital += qp.second * qp.first.y() ;
            }
        }
        if(cl.user_data.location == element_location::ON_INTERFACE)
        {

            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
            {


                T val0 = ls_cell.divergence( *interface_point );
                T error_curvature = std::abs( val0 + 1.0/radius) ;
                l1_divergence_error += error_curvature;
                l2_divergence_error += pow(error_curvature,2) ;
                linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*interface_point);
                std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                interface_normals.push_back( normal_vec_grad_cont ) ;
                //vec_normal_grad_cont->add_data(*interface_point,normal_vec_grad_cont);

                perimeter_initial += ( *(interface_point+1) - *interface_point ).to_vector().norm();


                interface_points_plot.push_back(*(interface_point)) ;


                counter_interface_pts++;

            }

            T val0 = ls_cell.divergence(*(cl.user_data.interface.end()-1));

            T error_curvature = std::abs( val0 + 1.0/radius) ;
            l1_divergence_error += error_curvature;
            l2_divergence_error += pow(error_curvature,2) ;
            linf_divergence_error = std::max(linf_divergence_error , error_curvature ) ;


            Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
            std::pair<T,T> normal_vec_grad_cont = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
            interface_normals.push_back( normal_vec_grad_cont ) ;

            //vec_normal_grad_cont->add_data(*(cl.user_data.interface.end()-1), normal_vec_grad_cont);


            interface_points_plot.push_back(*(cl.user_data.interface.end()-1)) ;



            counter_interface_pts++;

        }



    }

    bool first_cut_cell_found = FALSE ;
    T distance_pts = 0.0;
    point<T,2> first_point ;
    point<T,2> cell_end_point;
    for(auto& cl : msh_i.cells)
    {

        if(cl.user_data.location == element_location::ON_INTERFACE)
        {
            ls_cell.cell_assignment(cl);
            if(!first_cut_cell_found)
            {
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                {
                    T val0 = ls_cell.divergence( *interface_point );

                    point<T,2> curv_var = point_type(distance_pts , 0.0);
                    if( interface_point == cl.user_data.interface.begin() )
                        test_curv_var_cell->add_data(curv_var, val0);

                    test_curv_var_divergence0->add_data(curv_var, val0);

                    distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                }
                first_cut_cell_found = TRUE;
                first_point = *cl.user_data.interface.begin() ;
                cell_end_point = *(cl.user_data.interface.end() -1) ;
            }
            else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
            {
                for(auto& cl : msh_i.cells)
                {
                    if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                    {
                        ls_cell.cell_assignment(cl);
                        for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                        {

                            T val0 = ls_cell.divergence( *interface_point );

                            point<T,2> curv_var = point_type(distance_pts , 0.0);
                            if( interface_point == cl.user_data.interface.begin() )
                                test_curv_var_cell->add_data(curv_var, val0);

                            test_curv_var_divergence0->add_data(curv_var, val0);

                            distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                        }
                        cell_end_point = *(cl.user_data.interface.end() -1) ;
                    }

                }

            }
            else
                break;

        }


    }
    postoutput_div2.add_object(test_curv_var_divergence0);
    postoutput_div2.add_object(test_curv_var_cell);
    postoutput_div2.write();

    //postoutput_vec.add_object(vec_normal_grad_cont);
    //postoutput_vec.write();



    if( !flower) //1 ) // !flower)
    {
        l1_divergence_error /= counter_interface_pts;

        l2_divergence_error = sqrt(l2_divergence_error/counter_interface_pts);
        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error<<reset <<std::endl;
        l1_err_curvature_time.push_back(l1_divergence_error) ;
        linf_err_curvature_time.push_back(linf_divergence_error) ;

    }

    std::cout <<bold<<yellow << '\n' << "Initial time, AREA  = "<< initial_area << reset << std::endl;
    std::cout << "Initial time, MASS  = "<< initial_mass   << std::endl;
    std::cout << "Initial time, CENTRE OF MASS  = ( "<< centre_mass_x_inital/initial_area  << " , "<< centre_mass_y_inital/initial_area <<" )." << std::endl;

    d_a = sqrt(4.0*initial_area/M_PI) ;
    std::cout<<"Initial time, PERIMETER = " << perimeter_initial <<std::endl;
    std::cout<<"Initial time, CIRCULARITY = " << M_PI*d_a/perimeter_initial <<std::endl;
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    std::cout<<"OLD radius = " << radius <<std::endl;


    if(flower)
    {
        T l1_divergence_error_flower = 0. , l2_divergence_error_flower = 0. ;
        T linf_divergence_error_flower = -10. ;
        radius = sqrt( initial_area/M_PI ) ;
        std::cout<<"FROM AREA radius = " << radius <<std::endl;
        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl) ;

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {


                    T val0 = ls_cell.divergence( *interface_point );
                    T error_curvature = std::abs( val0 + 1.0/radius) ;
                    l1_divergence_error_flower += error_curvature;
                    l2_divergence_error_flower += pow(error_curvature,2) ;
                    linf_divergence_error_flower = std::max(linf_divergence_error_flower , error_curvature ) ;

                }
            }
        }
        l1_divergence_error_flower /= counter_interface_pts;

        l2_divergence_error_flower = sqrt(l2_divergence_error_flower/counter_interface_pts);

        std::cout<<"Number of interface points is " << counter_interface_pts << std::endl;
        std::cout<<bold<<yellow<<"The l1 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l1_divergence_error_flower<<reset <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at INITIAL time is " << l2_divergence_error_flower <<std::endl;
        std::cout<<bold<<yellow<<"The linf error of the CURVATURE at the INTERFACE, at INITIAL time is " << linf_divergence_error_flower<<reset <<std::endl;

        l1_err_curvature_time.push_back(l1_divergence_error_flower) ;
        linf_err_curvature_time.push_back(linf_divergence_error_flower) ;
    }


    T circularity_ref = 0.0 ;
    T perim_ref = 0.0 ;
    T area_ref = 0.0  ;

    {
        // calculus of circle REF in Q^k mesh N x M --> CIRCULARITY REF
        auto level_anal_ref = circle_level_set<RealType>(radius, x_centre, y_centre );
        std::cout<<"REF radius = " << radius <<std::endl;
        typedef  circle_level_set<T> Fonction_REF;
        auto level_set_ref = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > (fe_data , level_anal_ref , msh);

        Mesh msh_ref =  msh;
        offset_definition(msh_ref);
        detect_node_position3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_faces3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_cells3(msh_ref, level_set_ref); // In cuthho_geom
        //refine_interface_pro3(msh_ref, level_set_ref, int_refsteps);
        refine_interface_pro3_curve_para(msh_ref, level_set_ref, int_refsteps,degree_curve);
        set_integration_mesh(msh_ref,degree_curve) ;
        detect_cell_agglo_set(msh_ref, level_set_ref); // Non serve modificarla
        make_neighbors_info_cartesian(msh_ref); // Non serve modificarla
        
        //make_agglomeration(msh_ref, level_set_ref); // Non serve modificarla
        make_agglomeration_no_double_points(msh_ref, level_set_ref,degree_curve);
        set_integration_mesh(msh_ref,degree_curve) ;
        
        typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > Level_Set_REF;
        auto ls_cell_ref = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set_REF, Fonction_REF , FiniteSpace >(level_set_ref,msh_ref);


        for(auto& cl : msh_ref.cells)
        {
            ls_cell_ref.cell_assignment(cl);


            if( location(msh_ref, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_ref, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_ref, cl, element_location::IN_NEGATIVE_SIDE);
                area_ref += partial_area;

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    perim_ref += ( *(interface_point+1) - *interface_point ).to_vector().norm();

                }
            }
        }

        T d_a_REF = sqrt(4.0*area_ref/M_PI) ;
        std::cout<<"AREA REF = " << area_ref <<std::endl;
        std::cout<<"PERIMETER REF = " << perim_ref <<std::endl;
        std::cout<<"Error( perimetre_ref - perimeter_initial ) = " << perim_ref - perimeter_initial <<std::endl;
        std::cout<<"Error( area_ref - initial_area ) = " << area_ref - initial_area <<std::endl;
        circularity_ref = M_PI*d_a_REF/perim_ref ;
        std::cout<<"CIRCULARITY REF = " << circularity_ref <<std::endl;
        std::cout<<"Error( area_ref - area_analytic ) = " << area_ref - M_PI*radius*radius <<std::endl;

    }




    circularity_time.push_back(M_PI*d_a/perimeter_initial);
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(std::make_pair(centre_mass_x_inital/initial_area  , centre_mass_y_inital/initial_area) );

    time_vec.push_back(0) ;
    area_time.push_back(initial_area) ;

    min_max_vec.push_back( std::make_pair( level_set_function.phi_min , level_set_function.phi_max ) );

    T dt_M ;



    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration, time t = "<<tot_time<<reset <<std::endl;
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        //testing_level_set_time(msh,level_set_function,tot_time,time_step);



        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;

        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);


        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );
        // ----------------- ESHELBY VERSION - CORRECT (TESTING) ------------------
        T gamma = 1.0; // 0.05
        auto test_case_prova = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);

        //auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);

        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case_prova, sym_grad);


        //timecounter tc_u ;
        //tc_u.tic();
        //stokes_test_info<T> TI;
        if(solve_interface){

            //bool normal_analysis =  true ;
            //TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
            //run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            //run_cuthho_interface_velocity(msh_i, degree, method, test_case, ls_cell , u_projected ,sym_grad );

            // OLD
            //run_cuthho_interface_velocity_analytic(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad ,radius );

            //run_cuthho_interface(msh, degree, method, test_case);
        }
        if (solve_fictdom)
            run_cuthho_fictdom(msh_i, degree, test_case_prova);

        //tc_u.toc();

        //std::cout << "Machine Time for solving STOKES PB: " << tc_u << " seconds" << std::endl;





        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if(0)
            std::cout<<bold<<green<<"CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"<<reset<<std::endl;

        if( 1 ) //1 FIRST RESULT WITH THIS
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh , method_transport_pb);
        }
        //testing_velocity_field(msh , u_projected) ;

        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;




        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------
        auto level_set_tmp = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        //auto ls_cell_tmp = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        //auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        //if(tot_time < 0.75)
        dt_M = 8*1e-3; // 4*1e-3;
        //else
        //    dt_M = 1e-3;
        T eps = 0.48 ; // factor to be inside CFL stability zone
        //T dt_one_cell = time_step_CFL( u , mip , eps ); // OLD IMPLEMENTATION
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;

        //T sub_dt;
        //if(tot_time <0.132)
        //    sub_dt = std::min(4*1e-4 , dt ) ;
        //else
        //    sub_dt = std::min(5*1e-5 , dt ) ;

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        /*
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
            }
            else{
                if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  );
                else
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  , fe_data_Lagrange);

            }
            //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

            sub_time += sub_dt ;

        }
        */
        //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        // ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , mapping );

            }
            else{
                //if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  sub_dt  );
                //else
                //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

            }


            sub_time += sub_dt ;

        }
        tot_time += sub_time ;


       /**************************************************   POST-PROCESSING **************************************************/


        // Updating continuous normal function

        // IF GRADIENT CONTINUOUS
        level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
        // IF DIVERGENCE CONTINUOUS
        level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

        // Updating mesh data to check out differences in mass and areas
        crr_mesh.current_mesh = msh;
        msh_i =  crr_mesh.current_mesh;
        offset_definition(msh_i);

        tc.tic();
        detect_node_position3(msh_i, level_set_function); // In cuthho_geom
        detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


        if (agglomeration)
        {
            detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
            
            refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
            set_integration_mesh(msh_i,degree_curve) ;
            
            detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
            make_neighbors_info_cartesian(msh_i); // Non serve modificarla
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
            //refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
            make_agglomeration_no_double_points(msh_i, level_set_function,degree_curve); // Non serve modificarla
                       // make_agglomeration(msh_i, level_set_function); // Non serve modificarla
            set_integration_mesh(msh_i,degree_curve) ;
        }
        else
        {
            move_nodes(msh_i, level_set_function);
            //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
            detect_cut_cells3(msh_i, level_set_function);
            //refine_interface2(msh_i2, level_set_function, int_refsteps);
            //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
            refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
            //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        }

        tc.toc();
        std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

        if (dump_debug)
        {
            dump_mesh(msh_i);
            output_mesh_info(msh_i, level_set_function);
        }

        // Updating level set
        ls_cell.level_set = level_set_function;
        ls_cell.agglo_msh = msh_i;
        u_projected.set_agglo_mesh( msh_i );


        T max_u_n_val = 0.0 ;
        T max_u_n_val_abs = 0.0 ;
        T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;


        size_t counter_interface_pts = 0;
        for(auto& cl : msh_i.cells)
        {
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                u_projected.cell_assignment(cl);
                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                {
                    T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                    max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                    if( std::abs(u_n_val) == max_u_n_val_abs )
                        max_u_n_val = u_n_val ;

                    l1_normal_interface_status += std::abs(u_n_val) ;
                    l2_normal_interface_status += pow(u_n_val,2.0);
                    counter_interface_pts ++ ;

                }
            }
        }

        if( time_step == 0 )
            max_u_n_val_new = max_u_n_val ;

        if(time_step > 0 )
        {
            max_u_n_val_old = max_u_n_val_new ;
            max_u_n_val_new = max_u_n_val ;
            std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
        }

        std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

        l1_normal_interface_status /= counter_interface_pts;
        l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
        std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
        std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
        std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;




        if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
        {
            std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
            //exit(9) ;
        }

        //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

        //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
        if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
        {




            // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
            // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
            T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
            T dt_new = std::min(dt_one_cell , dt_M_new);

            bool forward = TRUE ;
            if( forward ) // GO FORWARD FROM THE TIME t^n
            {
                dt = dt_new ;

                std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                tot_time -= sub_time ; // I erase the time previously calculated
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {

                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb ,  sub_dt  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);


                    }


                    sub_time += sub_dt ;

                }

                tot_time += sub_time ; // the new time is substracted
                level_set_function = level_set_tmp ;
                std::cout<<'\n'<<std::endl;
                //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
            }
            else // GO BACKWARD FROM THE TIME t^n + dt_M
            {

                dt = dt_M - dt_new ;
                std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                sub_time = 0.;
                sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                //T sub_dt;
                //if(tot_time <0.132)
                //    sub_dt = std::min(4*1e-4 , dt ) ;
                //else
                //    sub_dt = std::min(5*1e-5 , dt ) ;

                std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                while(  sub_time < sub_dt*N_sub  )
                {
                    T neg_time = -sub_dt ;
                    if(high_order){
                        run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time , mapping );

                    }
                    else{
                        //if(degree_velocity == degree_FEM) // IT IS FASTER
                            run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  neg_time  );
                        //else
                        //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time  , fe_data_Lagrange);


                    }



                    sub_time += sub_dt ;

                }
                std::cout<<'\n'<<std::endl;
                tot_time -= sub_time ; // the new time is substracted

            }


            //-------------------------- NEW CALCULATION OF U*N --------------------------

            // Updating continuous normal function

            // IF GRADIENT CONTINUOUS
            level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
            // IF DIVERGENCE CONTINUOUS
            level_set_function.divergence_continuous_setting(method_transport_pb_div) ;
            // Updating mesh data to check out differences in mass and areas
            crr_mesh.current_mesh = msh;
            msh_i =  crr_mesh.current_mesh;
            offset_definition(msh_i);

            tc.tic();
            detect_node_position3(msh_i, level_set_function); // In cuthho_geom
            detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


            if (agglomeration)
            {
                detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                
                refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
                set_integration_mesh(msh_i,degree_curve) ;
                
                detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
                //refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                make_agglomeration_no_double_points(msh_i, level_set_function,degree_curve);
                //make_agglomeration(msh_i, level_set_function); // Non serve modificarla
                set_integration_mesh(msh_i,degree_curve) ;
            }
            else
            {
                //move_nodes(msh_i, level_set_function);
                //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
                detect_cut_cells3(msh_i, level_set_function);
                //refine_interface2(msh_i2, level_set_function, int_refsteps);
                //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
                refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
            }

            tc.toc();
            std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

            if (dump_debug)
            {
                dump_mesh(msh_i);
                output_mesh_info(msh_i, level_set_function);
            }

            // Updating level set
            ls_cell.level_set = level_set_function;
            ls_cell.agglo_msh = msh_i;
            u_projected.set_agglo_mesh( msh_i );


            max_u_n_val = 0.0 ;
            max_u_n_val_abs = 0.0 ;
            l1_normal_interface_status = 0. ;
            l2_normal_interface_status = 0. ;

            counter_interface_pts = 0;
            for(auto& cl : msh_i.cells)
            {
                if(cl.user_data.location == element_location::ON_INTERFACE)
                {
                    ls_cell.cell_assignment(cl);
                    u_projected.cell_assignment(cl);
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
                    {
                        T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
                        max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                        if( std::abs(u_n_val) == max_u_n_val_abs )
                            max_u_n_val = u_n_val ;

                        l1_normal_interface_status += std::abs(u_n_val) ;
                        l2_normal_interface_status += pow(u_n_val,2.0);
                        counter_interface_pts ++ ;

                    }
                }
            }


            max_u_n_val_new = max_u_n_val ;


            std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


            std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
            l1_normal_interface_status /= counter_interface_pts;
            l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

            std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
            std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
            std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

            std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;



        }


        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;



        // PLOTTING OF NORMAL

        //postprocess_output<double> postoutput_vec;
        //auto vec_normal_grad_cont_fin = std::make_shared< gnuplot_output_object_vec<double> >("normal_interface_continuos_grad_Stokes_final.dat");

        postprocess_output<T> postoutput_div2;
        std::string filename_curvature_k0 = "k0_curvature_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_divergence0 = std::make_shared< gnuplot_output_object<double> >(filename_curvature_k0);
        std::string filename_curv_var = "cell_limit_curv_var_" + std::to_string(time_step) + ".dat";
        auto test_curv_var_cell = std::make_shared< gnuplot_output_object<double> >(filename_curv_var);

        std::vector<T>  val_u_n_fin ; //val_u_nx_fin , val_u_ny_fin ;
        std::vector< point<T, 2> > interface_points_plot_fin ;
        std::vector< std::pair<T,T> > vec_n ; // , velocity_interface , velocity_field , points_vel_field;



        T rise_vel0 = 0.0 , rise_vel1 = 0.0 ;
        T flux_interface = 0.0 ;

        for(auto& cl : msh_i.cells)
        {
            ls_cell.cell_assignment(cl);
            u_projected.cell_assignment(cl);

            if( (location(msh_i, cl) == element_location::IN_NEGATIVE_SIDE) || (location(msh_i, cl) == element_location::ON_INTERFACE) )
            {

                T partial_area = measure( msh_i, cl, element_location::IN_NEGATIVE_SIDE);
                area_fin += partial_area;

                auto qps_fin = integrate( msh_i , cl , 2*degree_FEM , element_location::IN_NEGATIVE_SIDE);

                for(auto& qp:qps_fin){
                    mass_fin += qp.second * ls_cell(qp.first);
                    centre_mass_x += qp.second * qp.first.x() ;
                    centre_mass_y += qp.second * qp.first.y() ;

                    rise_vel0 +=  qp.second * u_projected(qp.first).first;
                    rise_vel1 +=  qp.second * u_projected(qp.first).second;
                }

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {

                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                {
                    T segment = ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    perimeter += segment ;
                    T val0 = ls_cell.divergence( *interface_point );
                    T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                    l1_divergence_error_fin += curvature_error ;
                    l2_divergence_error_fin += pow(curvature_error,2) ;
                    linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);



                    Eigen::Matrix<T,2,1> normal_cont_grad = ls_cell.normal(*interface_point);
                    std::pair<T,T> normal_vec_grad_cont = std::make_pair( normal_cont_grad(0) , normal_cont_grad(1) );

                    vec_n.push_back( normal_vec_grad_cont ) ;

                    T u_n_0 = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) ;
                    T u_n_1 = u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;

                    interface_points_plot_fin.push_back( *(interface_point) ) ;

                    //val_u_nx_fin.push_back( u_n_0 );
                    //val_u_ny_fin.push_back( u_n_1 );
                    val_u_n_fin.push_back( u_n_0 + u_n_1 );

                    //velocity_interface.push_back( std::make_pair( u_projected(*(interface_point)).first , u_projected(*(interface_point)).second) ) ;

                    T u_n_0_pt2 = u_projected(*(interface_point+1)).first * ls_cell.normal(*(interface_point+1))(0) ;
                    T u_n_1_pt2 = u_projected(*(interface_point+1)).second * ls_cell.normal(*(interface_point+1))(1) ;

                    flux_interface += segment * 0.5*( u_n_0 + u_n_1 + u_n_0_pt2 + u_n_1_pt2 ) ;
                    //    counter_interface_pts++;
                }

                T val0 = ls_cell.divergence( *(cl.user_data.interface.end()-1) );
                T curvature_error = std::abs( std::abs(val0) - 1.0/radius ) ;
                l1_divergence_error_fin += curvature_error ;
                l2_divergence_error_fin += pow(curvature_error,2) ;
                linf_divergence_error_fin = std::max(linf_divergence_error_fin ,  curvature_error);

                Eigen::Matrix<T,2,1> normal_grad_cont = ls_cell.normal(*(cl.user_data.interface.end()-1));
                std::pair<T,T> normal_vec_grad_norm = std::make_pair(normal_grad_cont(0),normal_grad_cont(1));
                vec_n.push_back( normal_vec_grad_norm ) ;

                T u_n_0 = u_projected(*(cl.user_data.interface.end()-1)).first * ls_cell.normal(*(cl.user_data.interface.end()-1))(0) ;
                T u_n_1 = u_projected(*(cl.user_data.interface.end()-1)).second * ls_cell.normal(*(cl.user_data.interface.end()-1))(1) ;


                interface_points_plot_fin.push_back( *(cl.user_data.interface.end()-1) ) ;
                //val_u_nx_fin.push_back( u_n_0 );
                //val_u_ny_fin.push_back( u_n_1 );
                val_u_n_fin.push_back( u_n_0 + u_n_1 );

                //velocity_interface.push_back( std::make_pair( u_projected(*(cl.user_data.interface.end()-1)).first , u_projected(*(cl.user_data.interface.end()-1)).second) ) ;


                //    counter_interface_pts++;

            }
            /*
            for(auto& pt : points(msh_i,cl))
            {
                points_vel_field.push_back( std::make_pair(pt.x() , pt.y() ) ) ;
                velocity_field.push_back( std::make_pair(u_projected(pt).first , u_projected(pt).second)) ;

            }
            */

        }

        bool first_cut_cell_found = FALSE ;
        T distance_pts = 0.0;
        point<T,2> first_point ;
        point<T,2> cell_end_point;
        for(auto& cl : msh_i.cells)
        {

            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                ls_cell.cell_assignment(cl);
                if(!first_cut_cell_found)
                {
                    for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end()-1 ; interface_point++ )
                    {
                        T val0 = ls_cell.divergence( *interface_point );
                        point<T,2> curv_var = point_type(distance_pts , 0.0);
                        if( interface_point == cl.user_data.interface.begin() )
                            test_curv_var_cell->add_data(curv_var, val0);

                        test_curv_var_divergence0->add_data(curv_var, val0);

                        distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                    }
                    first_cut_cell_found = TRUE;
                    first_point = *cl.user_data.interface.begin() ;
                    cell_end_point = *(cl.user_data.interface.end() -1) ;
                }
                else if( first_cut_cell_found && !( first_point == cell_end_point  ) )
                {
                    for(auto& cl : msh_i.cells)
                    {
                        if((cl.user_data.location == element_location::ON_INTERFACE)&& (cell_end_point ==*cl.user_data.interface.begin() )  )
                        {
                            ls_cell.cell_assignment(cl);
                            for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
                            {

                                T val0 = ls_cell.divergence( *interface_point );
                                point<T,2> curv_var = point_type(distance_pts , 0.0);
                                if( interface_point == cl.user_data.interface.begin() )
                                    test_curv_var_cell->add_data(curv_var, val0);

                                test_curv_var_divergence0->add_data(curv_var, val0);


                                distance_pts += ( *(interface_point+1) - *interface_point ).to_vector().norm();
                            }
                            cell_end_point = *(cl.user_data.interface.end() -1) ;
                        }

                    }

                }
                else
                    break;

            }

        }


        postoutput_div2.add_object(test_curv_var_divergence0);
        postoutput_div2.add_object(test_curv_var_cell);
        postoutput_div2.write();


        //postoutput_vec.add_object(vec_normal_grad_cont_fin);
        //postoutput_vec.write();
        goal_quantities_time_fast(msh , interface_points_plot_fin , val_u_n_fin  , vec_n , time_step);

        //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , vec_n , velocity_interface , velocity_field , points_vel_field , time_step ) ;
        //goal_quantities_time(msh , tot_time, interface_points_plot_fin , val_u_nx_fin , val_u_ny_fin , val_u_n_fin , interface_normals_fin ) ;

        //if(time_step == T_N)
        //    testing_level_set_time(msh,level_set_function, tot_time,time_step);

        testing_level_set_max_min(msh,level_set_function , time_step , min_max_vec );

        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts;
        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;






        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;

        //DA ADD BENE!!!! da qui

        circularity_time.push_back(M_PI*d_a/perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x/area_fin  , centre_mass_y/area_fin) );

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back( std::make_pair(rise_vel0/area_fin  , rise_vel1/area_fin) ) ;


        //fino a qua


    } // End of the temporal loop

    //plotting_in_time( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M );

    plotting_in_time_complete( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M ,min_max_vec ,  flux_interface_time , rise_velocity_time , centre_mass_err_time , perimeter_time , circularity_time , circularity_ref , perim_ref , area_ref , radius );



    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;

    tc_tot.toc();
    std::cout<<"Simulation time 0 t = "<<tc_tot <<std::endl;

    return 0;
}
#endif



// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 03/11/2020 -> (GRADIENT AND NORMAL CONTINUOUS + DIVERGENCE CONT/DISC )

// NEW CURVE INTEGRATION : CHECKING -> POST GOAL QUANTITIES FROM LS
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;
    size_t degree_curve     = 2;
    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    size_t T_N = 0;
    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:l:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;
                
            case 'l':
                degree_curve = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef RealType T;
//    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Mesh size = "<<mip.Nx<<"x"<<mip.Ny<<std::endl;
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

    /**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
    //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t  degree_gradient = degree_FEM - 1 ;
    auto fe_data_gradient = Finite_Element<RealType,Mesh>( msh , degree_gradient , mip ) ;
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;

    size_t  degree_div = degree_FEM - 1 ;
    std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
    auto fe_data_div = Finite_Element<RealType,Mesh>( msh , degree_div , mip ) ;
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


    /************** ANALYTIC LEVEL SET FUNCTION  **************/
   

    bool circle = false , ellipse = false ;
    bool flower = true;
    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
//        T eps_circ = 1e-4;
//        radius_a = 1.0/3.0-eps_circ;
//        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    
//    std::cout<<"Initial interface: CIRCLE"<<std::endl;
//    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
//    typedef  circle_level_set<T> Fonction;
//
    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;
    flower = true ;
     
    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
//    std::cout<<"Initial interface: ELLIPSE"<<std::endl;
//    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
//    typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;
     
    


    /**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/


    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;
    
//    auto level_set_function = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );
//    typedef Level_set_berstein< Mesh , Fonction , FiniteSpace , T > Level_Set;
//     // IF GRADIENT CONTINUOUS
//    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;
    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    level_set_function.gradient_continuous_setting() ;
    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
    
    
    std::cout<<"Parametric interface: degree_curve = "<<degree_curve<<std::endl;
    auto curve = Interface_parametrisation_mesh1d(degree_curve);
//    auto curve_old = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
    size_t degree_det_jac_curve = curve.degree_det ; // 2*degree_curve INUTILE PER ORA
    // integration CUT CELL degree += degree_curve
    // integration INTERFACE degree += degree_curve
    
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
   //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);





    /************** LEVEL SET  MAPPING **************/
    // If mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    bool mapping = false ;
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );



    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.;
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
    
    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
        set_integration_mesh(msh_i,degree_curve);
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
       
        make_agglomeration_no_double_points(msh_i, level_set_function,degree_det_jac_curve);
        set_integration_mesh(msh_i,degree_curve) ; // TOLTO PER IL MOMENTO SENNO RADDOPPIO
//        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }

    
//    Interface_parametrisation_mesh1d_global<Mesh> para_curve_cont(msh_i,degree_curve);
//    para_curve_cont.make_L2_proj_para_derivative(msh_i);
//    check_para_formulation_n_der_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
//    para_curve_cont.make_L2_proj_para_curvature(msh_i);
//    check_para_formulation_n_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
    
    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    level_set_function.gradient_continuous_setting() ;
//    // IF GRADIENT CONTINUOUS
//    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

    
    // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\
    
// IF grad cont -> normal cont -> (divergence disc) -> divergence cont
    //auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad cont -> normal cont -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad disc -> normal disc -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
// IF grad disc -> normal disc -> divergence disc -> normal and grad cont
//    auto ls_cell = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
    
    // OLD CASE
    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i );

    
    
    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();
    
    
    // ---------------------------------- CHECK bernstein 1d  -----------------------------------
    check_para_formulation(msh_i,curve ,degree_curve,degree_FEM,radius,int_refsteps) ;
            
    
    
    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;
    std::vector<T> circularity_time , flux_interface_time , perimeter_time;
    std::vector<std::pair<T,T>> centre_mass_err_time , rise_velocity_time , min_max_vec ;
    T circularity_ref = 0.0 , perim_ref = 0.0, area_ref = 0.0 ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    T L1_divergence_error = 0.;
    
    check_goal_quantities(msh_i, ls_cell, perimeter_initial,d_a, initial_area, centre_mass_x_inital, centre_mass_y_inital,degree_FEM, initial_mass , flower , l1_divergence_error , l2_divergence_error , linf_divergence_error , radius ,L1_divergence_error , ellipse,degree_curve,int_refsteps);
    
    //------------------------ CHECK REFERENCE QUANTITIES ---------------------------//
    {
        // calculus of circle REF in Q^k mesh N x M --> CIRCULARITY REF
        std::cout<<"------ NOTICE: The REF quantities are the numerical calculation of some important quantities for a circle interface. This is useful in the fixed-pont problem to check the convergence of the flower into the equivalent circle."<<std::endl;
        auto level_anal_ref = circle_level_set<T>(radius, x_centre, y_centre );
        std::cout<<"REF radius = " << radius <<std::endl;
        typedef  circle_level_set<T> Fonction_REF;
        auto level_set_ref = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > (fe_data , level_anal_ref , msh);

        Mesh msh_ref =  msh;
        offset_definition(msh_ref);
        detect_node_position3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_faces3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_cells3(msh_ref, level_set_ref); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_ref, level_set_ref, int_refsteps,degree_curve);
        set_integration_mesh(msh_ref,degree_curve) ;
        detect_cell_agglo_set(msh_ref, level_set_ref); // Non serve modificarla
        make_neighbors_info_cartesian(msh_ref); // Non serve modificarla
        make_agglomeration_no_double_points(msh_ref, level_set_ref,degree_det_jac_curve);
        set_integration_mesh(msh_ref,degree_curve) ;
        
        typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > Level_Set_REF;
        auto ls_cell_ref = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set_REF, Fonction_REF , FiniteSpace >(level_set_ref,msh_ref);


        for(auto& cl : msh_ref.cells)
        {
            ls_cell_ref.cell_assignment(cl);


            if( location(msh_ref, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_ref, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_ref, cl, element_location::IN_NEGATIVE_SIDE);
                area_ref += partial_area;

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                perim_ref += measure_interface(msh_i,cl,element_location::ON_INTERFACE);
//                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
//                {
//                    perim_ref += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//
//                }
            }
        }

        T d_a_REF = sqrt(4.0*area_ref/M_PI) ;
        std::cout<<"AREA REF = " << area_ref <<std::endl;
        std::cout<<"PERIMETER REF = " << perim_ref <<std::endl;
        std::cout<<"Error( perimetre_ref - perimeter_initial ) = " << perim_ref - perimeter_initial <<std::endl;
        std::cout<<"Error( area_ref - initial_area ) = " << area_ref - initial_area <<std::endl;
        circularity_ref = M_PI*d_a_REF/perim_ref ;
        std::cout<<"CIRCULARITY REF = " << circularity_ref <<std::endl;
        T area_anal = M_PI*radius*radius ;
        std::cout<<"Error( area_ref - area_analytic ) = " << area_ref - area_anal <<std::endl;
        

        T perimeter_anal = 2.0*M_PI*radius ;
        std::cout<<"Error( perimetre_ref - perimeter_anal ) = " << perim_ref - perimeter_anal <<std::endl;

    }
   
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    circularity_time.push_back(M_PI*d_a/perimeter_initial);
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(std::make_pair(centre_mass_x_inital/initial_area  , centre_mass_y_inital/initial_area) );
    time_vec.push_back(0) ;
    area_time.push_back(initial_area) ;

    min_max_vec.push_back(std::make_pair(level_set_function.phi_min , level_set_function.phi_max) );

    l1_err_curvature_time.push_back(l1_divergence_error) ;
    linf_err_curvature_time.push_back(linf_divergence_error) ;
    
    T dt_M ;

    

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration numero  = "<<time_step<<" --> time t = "<<tot_time<<reset <<std::endl;
        
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        testing_level_set_time(msh,level_set_function,tot_time,time_step);

        testing_level_set(msh , level_set_function ) ; // PLOTTING THE INTERFACE. It saves  the last
        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        T gamma = 1.0; // 0.05
        
//        check_para_formulation_time(msh_i, curve, degree_curve, degree_FEM , radius, time_step,int_refsteps);
        
        Interface_parametrisation_mesh1d_global<Mesh> para_curve_cont(msh_i,degree_curve);
        
        // *********************** DERIVATIVE / NORMAL PARA *************************//
        //------------- L2 cont curvature from parametric interface  r ---------- //
        para_curve_cont.make_L2_proj_para_derivative(msh_i);
        
        //---------------------------- L2 global Normal from LS  ----------------------- //
        para_curve_cont.make_L2_proj_para_normal(msh_i,ls_cell);
               
        //---------------------------- Avg Normal from LS  ---------------------------- //
//        para_curve_cont.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);
        
        

        //        check_para_formulation_n_der_cont_time(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,time_step,int_refsteps) ;
        
        // *********************** CURVATURE PARA *************************//
        
        //------------- L2 cont curvature from parametric interface  r ---------- //
//        para_curve_cont.make_L2_proj_para_curvature(msh_i);

         
        //---------------------------- L2 global Curvature from LS  ----------------------- //
        para_curve_cont.make_L2_proj_para_curvature(msh_i,ls_cell);
       
        //---------------------------- Avg Curvature from LS  ---------------------------- //
//        para_curve_cont.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
        
        check_para_formulation_n_cont_time(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,time_step,int_refsteps) ;
   
        
        
        
        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );

        // ---------------------- ESHELBY VERSION LEVEL SET - CORRECT ------------------------
//        auto test_case = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);
        
         // -------------------- ESHELBY VERSION PARAMETRIC (DISC) - CORRECT -------------------
//        auto test_case = make_test_case_eshelby_correct_parametric(msh_i, ls_cell,  prm , sym_grad,gamma);
        // -------------------- ESHELBY VERSION PARAMETRIC (CONT) - CORRECT -------------------
        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma );
        
        
        // ------------------------ HHO METHOD FOR LEVEL SET  ---------------------------
//        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);
        // -------------------- HHO METHOD FOR DISC PARAMETRIC INTERFACE  -----------------------
//         auto method = make_sym_gradrec_stokes_interface_method_ref_pts(msh_i, 1.0, 0.0, test_case, sym_grad);
    
        // -------------------- HHO METHOD FOR CONT PARAMETRIC INTERFACE  -----------------------
        auto method_prova = make_sym_gradrec_stokes_interface_method_ref_pts_cont(msh_i, 1.0, 0.0, test_case_prova, sym_grad);
        
        
        
        
        //  ******************** - HHO RESOLUTION - ********************
        if(solve_interface){
            // ----------------- HHO RESOLUTION OLD CASE  --------------------------
//            TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
//            run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            
            // ----------------- HHO RESOLUTION LS / PARAMETRIC DISC  ---------------------
//            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            
            // ----------------- HHO RESOLUTION PARAMETRIC CONT  --------------------------
             run_cuthho_interface_velocity_new(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
        }
//        if (solve_fictdom)
//            run_cuthho_fictdom(msh_i, degree, test_case);
        
        
        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if(0)
            std::cout<<bold<<green<<"CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"<<reset<<std::endl;

        if( 1 ) //1 FIRST RESULT WITH THIS
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh , method_transport_pb);
        }
        
        //testing_velocity_field(msh , u_projected) ;
        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;

        
        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------
//        auto level_set_tmp = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (level_set_function);
//         auto ls_cell_tmp = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
//         auto ls_cell_tmp = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);

        //        auto ls_cell_tmp = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
//        auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (level_set_function);
//        auto ls_cell_tmp = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        
        
        auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        //if(tot_time < 0.75)
        T eps = 0.48 ; // factor to be inside CFL stability zone
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        dt_M = dt_one_cell * 0.1 ;
//        dt_M = 8*1e-3; //  4*1e-3;
        
        
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        dt = std::min(0.1 , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;
        if(sub_dt >1e-3)
        {
            sub_dt = 1e-3 ;
            N_sub = dt/sub_dt ;

        }
       

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        /*
            while(  sub_time < sub_dt*N_sub  )
            {
                if(high_order){
                    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                    //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                    //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                    //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                }
                else{
                    if(degree_velocity == degree_FEM) // IT IS FASTER
                        run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  );
                    else
                        run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  , fe_data_Lagrange);

                }
                //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

                sub_time += sub_dt ;

            }
            */
            //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        // ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , mapping );

            }
            else{
                //if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  sub_dt  );
                //else
                //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

                }


                sub_time += sub_dt ;

            }
            tot_time += sub_time ;


    

        /**************************************************   POST-PROCESSING **************************************************/


         // Updating continuous normal function
            level_set_function.gradient_continuous_setting() ;
         // IF GRADIENT CONTINUOUS
//         level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//         // IF DIVERGENCE CONTINUOUS
//         level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

         // Updating mesh data to check out differences in mass and areas
         crr_mesh.current_mesh = msh;
         msh_i =  crr_mesh.current_mesh;
         offset_definition(msh_i);

         tc.tic();
         detect_node_position3(msh_i, level_set_function); // In cuthho_geom
         detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


         if (agglomeration)
         {
             detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
             
             refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
             set_integration_mesh(msh_i,degree_curve) ;
             
             detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
             make_neighbors_info_cartesian(msh_i); // Non serve modificarla
             //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
             //refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
             make_agglomeration_no_double_points(msh_i, level_set_function,degree_det_jac_curve);
            // make_agglomeration(msh_i, level_set_function); // Non serve modificarla
             set_integration_mesh(msh_i,degree_curve) ;
         }
         else
         {
             move_nodes(msh_i, level_set_function);
             //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
             detect_cut_cells3(msh_i, level_set_function);
             //refine_interface2(msh_i2, level_set_function, int_refsteps);
             //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
             refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
             //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
         }

         tc.toc();
         std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

         if (dump_debug)
         {
             dump_mesh(msh_i);
             output_mesh_info(msh_i, level_set_function);
         }

         // Updating level set
         ls_cell.level_set = level_set_function;
         ls_cell.agglo_msh = msh_i;
         u_projected.set_agglo_mesh( msh_i );

        // Updating Parametric interface
//        Interface_parametrisation_mesh1d_global<Mesh> para_curve_tmp(msh_i,degree_curve);
//        para_curve_tmp.make_L2_proj_para_derivative(msh_i);
//       check_para_formulation_n_der_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
//        para_curve_tmp.make_L2_proj_para_curvature(msh_i);
//        check_para_formulation_n_cont(msh_i,para_curve_tmp ,degree_curve,degree_FEM,radius,int_refsteps) ;
        

         T max_u_n_val = 0.0 ;
         T max_u_n_val_abs = 0.0 ;
         T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;

        T L1_normal_interface_status = 0. ;

         size_t counter_interface_pts = 0;
         for(auto& cl : msh_i.cells)
         {
             if(cl.user_data.location == element_location::ON_INTERFACE)
             {
                 ls_cell.cell_assignment(cl);
                 u_projected.cell_assignment(cl);
                 
                 auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
                 for(auto& qp:qps){
                     T u_n_val = u_projected(qp.first).first * ls_cell.normal(qp.first)(0) + u_projected(qp.first).second * ls_cell.normal(qp.first)(1) ;
                     L1_normal_interface_status += qp.second * std::abs(u_n_val) ;
                     max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                     if( std::abs(u_n_val) == max_u_n_val_abs )
                         max_u_n_val = u_n_val ;
                     
                     l1_normal_interface_status += std::abs(u_n_val) ;
                     counter_interface_pts ++ ;
                     
                 }
                 
//                 for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                 {
//                     T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
//                     max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
//                     if( std::abs(u_n_val) == max_u_n_val_abs )
//                         max_u_n_val = u_n_val ;
//
//                     l1_normal_interface_status += std::abs(u_n_val) ;
//                     l2_normal_interface_status += pow(u_n_val,2.0);
//                     counter_interface_pts ++ ;
//
//                 }
             }
         }

         if( time_step == 0 )
             max_u_n_val_new = max_u_n_val ;

         if(time_step > 0 )
         {
             max_u_n_val_old = max_u_n_val_new ;
             max_u_n_val_new = max_u_n_val ;
             std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
         }

         std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

         l1_normal_interface_status /= counter_interface_pts;
//         l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
         std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
//         std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
         std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;
        
        std::cout<<bold<<yellow<<"-----------------------------------> The L1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << L1_normal_interface_status <<reset << std::endl;




         if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
         {
             std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
             //exit(9) ;
         }

         //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

         //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
         if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
         {




             // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
             // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
             T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
             T dt_new = std::min(dt_one_cell , dt_M_new);

             bool forward = TRUE ;
             if( forward ) // GO FORWARD FROM THE TIME t^n
             {
                 dt = dt_new ;

                 std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                 std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                 tot_time -= sub_time ; // I erase the time previously calculated
                 sub_time = 0.;
                 sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                 //T sub_dt;
                 //if(tot_time <0.132)
                 //    sub_dt = std::min(4*1e-4 , dt ) ;
                 //else
                 //    sub_dt = std::min(5*1e-5 , dt ) ;

                 std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                 while(  sub_time < sub_dt*N_sub  )
                 {

                     if(high_order){
                         run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt , mapping );

                     }
                     else{
                         //if(degree_velocity == degree_FEM) // IT IS FASTER
                             run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb ,  sub_dt  );
                         //else
                         //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);


                     }


                     sub_time += sub_dt ;

                 }

                 tot_time += sub_time ; // the new time is substracted
                 level_set_function = level_set_tmp ;
                 std::cout<<'\n'<<std::endl;
                 //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
             }
             else // GO BACKWARD FROM THE TIME t^n + dt_M
             {

                 dt = dt_M - dt_new ;
                 std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                 std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                 sub_time = 0.;
                 sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                 //T sub_dt;
                 //if(tot_time <0.132)
                 //    sub_dt = std::min(4*1e-4 , dt ) ;
                 //else
                 //    sub_dt = std::min(5*1e-5 , dt ) ;

                 std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                 while(  sub_time < sub_dt*N_sub  )
                 {
                     T neg_time = -sub_dt ;
                     if(high_order){
                         run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time , mapping );

                     }
                     else{
                         //if(degree_velocity == degree_FEM) // IT IS FASTER
                             run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  neg_time  );
                         //else
                         //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time  , fe_data_Lagrange);


                     }



                     sub_time += sub_dt ;

                 }
                 std::cout<<'\n'<<std::endl;
                 tot_time -= sub_time ; // the new time is substracted

             }


             //-------------------------- NEW CALCULATION OF U*N --------------------------

             // Updating continuous normal function
             level_set_function.gradient_continuous_setting() ;
             // IF GRADIENT CONTINUOUS
//             level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//             // IF DIVERGENCE CONTINUOUS
//             level_set_function.divergence_continuous_setting(method_transport_pb_div) ;
             // Updating mesh data to check out differences in mass and areas
             crr_mesh.current_mesh = msh;
             msh_i =  crr_mesh.current_mesh;
             offset_definition(msh_i);

             tc.tic();
             detect_node_position3(msh_i, level_set_function); // In cuthho_geom
             detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


             if (agglomeration)
             {
                 detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                 
                 refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
                 set_integration_mesh(msh_i,degree_curve) ;
                 
                 detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                 make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                 
                 //refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                 make_agglomeration_no_double_points(msh_i, level_set_function,degree_det_jac_curve);
                 //make_agglomeration(msh_i, level_set_function); // Non serve modificarla
                 set_integration_mesh(msh_i,degree_curve) ;
             }
             else
             {
                 
                 detect_cut_cells3(msh_i, level_set_function);
                 //refine_interface2(msh_i2, level_set_function, int_refsteps);
                 //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                 //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
                 refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
             }

             tc.toc();
             std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

             if (dump_debug)
             {
                 dump_mesh(msh_i);
                 output_mesh_info(msh_i, level_set_function);
             }

             // Updating level set
             ls_cell.level_set = level_set_function;
             ls_cell.agglo_msh = msh_i;
             u_projected.set_agglo_mesh( msh_i );

             // Updating Parametric interface
//            Interface_parametrisation_mesh1d_global<Mesh> para_curve_tmp(msh_i,degree_curve);
//            para_curve_tmp.make_L2_proj_para_derivative(msh_i);
//            //        check_para_formulation_n_der_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
//            para_curve_tmp.make_L2_proj_para_curvature(msh_i);
//            check_para_formulation_n_cont(msh_i,para_curve_tmp ,degree_curve,degree_FEM,radius,int_refsteps) ;
                     

             max_u_n_val = 0.0 ;
             max_u_n_val_abs = 0.0 ;
             l1_normal_interface_status = 0. ;
             l2_normal_interface_status = 0. ;
             L1_normal_interface_status = 0. ;
             
             counter_interface_pts = 0;
             for(auto& cl : msh_i.cells)
             {
                 if(cl.user_data.location == element_location::ON_INTERFACE)
                 {
                     ls_cell.cell_assignment(cl);
                     u_projected.cell_assignment(cl);
                     
                     auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
                     for(auto& qp:qps){
                         T u_n_val = u_projected(qp.first).first * ls_cell.normal(qp.first)(0) + u_projected(qp.first).second * ls_cell.normal(qp.first)(1) ;
                         L1_normal_interface_status += qp.second * std::abs(u_n_val) ;
                         max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                         if( std::abs(u_n_val) == max_u_n_val_abs )
                             max_u_n_val = u_n_val ;

                         l1_normal_interface_status += std::abs(u_n_val) ;
                          counter_interface_pts ++ ;
                     }
                     
//                     for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                     {
//                         T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
//                         max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
//                         if( std::abs(u_n_val) == max_u_n_val_abs )
//                             max_u_n_val = u_n_val ;
//
//                         l1_normal_interface_status += std::abs(u_n_val) ;
//                         l2_normal_interface_status += pow(u_n_val,2.0);
//                         counter_interface_pts ++ ;
//
//                     }
                 }
             }


             max_u_n_val_new = max_u_n_val ;


             std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


             std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
             l1_normal_interface_status /= counter_interface_pts;
//             l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

             std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
//             std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
             std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

             std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;
             
             std::cout<<bold<<yellow<<"-----------------------------------> The L1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << L1_normal_interface_status <<reset << std::endl;


         }

        
        
        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;
        T L1_divergence_error_fin = 0.;

        T rise_vel0 = 0.0 , rise_vel1 = 0.0 ;
        T flux_interface = 0.0 ;

        size_t counter_interface_pts_fin = 0.0 ;

        check_goal_quantities_final( msh_i , ls_cell , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface,counter_interface_pts_fin,degree_curve,int_refsteps);
        
        
        testing_level_set_max_min(msh,level_set_function , time_step , min_max_vec );

        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts_fin;
//        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
//        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;
        
        std::cout<<"The L1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << L1_divergence_error_fin <<std::endl;





        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;

        //DA ADD BENE!!!! da qui

        circularity_time.push_back(M_PI*d_a/perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x/area_fin  , centre_mass_y/area_fin) );

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back( std::make_pair(rise_vel0/area_fin  , rise_vel1/area_fin) ) ;


    
        
    } // End of the temporal loop

   
    
    
    plotting_in_time_complete( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M ,min_max_vec ,  flux_interface_time , rise_velocity_time , centre_mass_err_time , perimeter_time , circularity_time , circularity_ref , perim_ref , area_ref , radius );



    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;

    tc_tot.toc();
    std::cout<<"Simulation time 0 t = "<<tc_tot <<std::endl;

    return 0;
}
#endif




// Interface Stokes Problem: INLET DIRICHLET BDRY CONDITIONS
// Generic Interface: Gamma = 0 or 1/2 or generic ( SEE MAX-MAX mapping)
// LAST UPDATE 03/11/2020 -> (GRADIENT AND NORMAL CONTINUOUS + DIVERGENCE CONT/DISC )

// NEW CURVE INTEGRATION :  POST GOAL QUANTITIES PARA
#if 0
int main(int argc, char **argv)
{
    using RealType = double;

    size_t degree           = 0;
    size_t int_refsteps     = 4;
    size_t degree_FEM       = 0;
    size_t degree_curve     = 2;
    bool dump_debug         = false;
    bool solve_interface    = false;
    bool solve_fictdom      = false;
    bool agglomeration      = false;

    bool high_order = false ; // IF FALSE IS PHI_L, IF TRUE  PHI_HP
    bool cut_off_active = false ; // IF FALSE IS SMOOTH, IF TRUE  CUT_OFF

    mesh_init_params<RealType> mip;
    mip.Nx = 5;
    mip.Ny = 5;
    size_t T_N = 0;
    int ch;
    while ( (ch = getopt(argc, argv, "k:q:M:N:r:T:l:ifDAdhc")) != -1 )
    {
        switch(ch)
        {
            case 'k':
                degree = atoi(optarg);
                break;

            case 'q':
                degree_FEM = atoi(optarg);
                break;

            case 'M':
                mip.Nx = atoi(optarg);
                break;

            case 'N':
                mip.Ny = atoi(optarg);
                break;

            case 'r':
                int_refsteps = atoi(optarg);
                break;

            case 'T':
                T_N = atoi(optarg);
                break;
                
            case 'l':
                degree_curve = atoi(optarg);
                break;

            case 'i':
                solve_interface = true;
                break;

            case 'f':
                solve_fictdom = true;
                break;

            case 'D':
                agglomeration = false;
                break;

            case 'A':
                agglomeration = true;
                break;

            case 'd':
                dump_debug = true;
                break;

            case 'h':
                high_order = true;
            break;

            case 'c':
                cut_off_active = true;
            break;


            case '?':
            default:
                std::cout << "wrong arguments" << std::endl;
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;



    timecounter tc;

    timecounter tc_tot;
    tc_tot.tic();


    /************** BUILD MESH **************/

    cuthho_poly_mesh<RealType> msh(mip);
    typedef cuthho_poly_mesh<RealType> Mesh;
    typedef RealType T;
//    typedef typename Mesh::point_type point_type;
    offset_definition(msh);
    std::cout<<"Mesh size = "<<mip.Nx<<"x"<<mip.Ny<<std::endl;
    std::cout<<"Number of refine interface points: r = "<<int_refsteps<<std::endl;

    /************** FINITE ELEMENT INITIALIZATION **************/
    auto fe_data = Finite_Element<RealType,Mesh>( msh , degree_FEM , mip ) ;
    typedef Finite_Element<RealType,Mesh> FiniteSpace;
    std::cout<<"Level Set (finite element approximation): degree FEM = "<<degree_FEM<<std::endl;

    /**************************************TRANSPORT PROBLEM METHOD *****************************************/
    auto method_transport_pb = Transport_problem_method<Mesh, FiniteSpace>(fe_data, msh) ;
    //typedef  Transport_problem_method<Mesh, FiniteSpace> Method_Transport;

    size_t  degree_gradient = degree_FEM - 1 ;
    auto fe_data_gradient = Finite_Element<RealType,Mesh>( msh , degree_gradient , mip ) ;
    auto method_transport_pb_grad = Transport_problem_method<Mesh, FiniteSpace>(fe_data_gradient, msh) ;

    size_t  degree_div = degree_FEM - 1 ;
    std::cout<<"grad deg = "<< degree_gradient <<" , div deg = " << degree_div <<std::endl;
    auto fe_data_div = Finite_Element<RealType,Mesh>( msh , degree_div , mip ) ;
    auto method_transport_pb_div = Transport_problem_method<Mesh, FiniteSpace>(fe_data_div, msh) ;


    /************** ANALYTIC LEVEL SET FUNCTION  **************/
   

    bool circle = false , ellipse = false ;
    bool flower = true;
    RealType radius_a , radius_b , radius ;
    RealType x_centre = 0.5;
    RealType y_centre = 0.5;
    //T h = std::max( fe_data.hx , fe_data.hy) ;
    if(circle)
    {
        radius = 1.0/3.0; // I ALWAYS USED 1.0/9.0
    }

    if(ellipse)
    {
        radius_a = 1.0/6.0;
        radius_b = 1.0/12.0;
//        T eps_circ = 1e-4;
//        radius_a = 1.0/3.0-eps_circ;
//        radius_b = 1.0/3.0+eps_circ;
        std::cout << bold << yellow << "Initial Analytic Area of the ELLIPSE: "<< M_PI*radius_a*radius_b << std::endl;
        radius = sqrt( radius_a * radius_b ) ;
        std::cout << bold << yellow << "Final radius expected of the circle : " << radius <<reset<<std::endl;
    }




    ///---------->!!!!!!!!  THIS DATA BELOW HAS TO BE UPLOAD DEPENDING ON THE PROBLEM:

    // ------------------------------------ CIRCLE LEVEL SET ------------------------------------
    
//    std::cout<<"Initial interface: CIRCLE"<<std::endl;
//    auto level_set_function_anal = circle_level_set<RealType>(radius, x_centre, y_centre );
//    typedef  circle_level_set<T> Fonction;
//
    // ------------------------------------ FLOWER LEVEL SET ------------------------------------
    
    radius = 0.31 ;
    std::cout<<"Initial interface: FLOWER"<<std::endl;
    auto level_set_function_anal = flower_level_set<T>(radius, x_centre, y_centre, 4, 0.04); //0.11
    typedef  flower_level_set<T> Fonction;
    flower = true ;
     
    // ------------------------------------ ELLIPTIC LEVEL SET -----------------------------------
//    std::cout<<"Initial interface: ELLIPSE"<<std::endl;
//    auto level_set_function_anal = elliptic_level_set<RealType>( radius_a, radius_b, x_centre, y_centre);
//    typedef  elliptic_level_set<T> Fonction;

    // ------------> OLD STUFF IMPLEMENTATION
    //auto level_set_function_anal = elliptic_distance_ls<RealType>( radius_a, radius_b, x_centre, y_centre , h);
    //typedef  elliptic_distance_ls<T> Fonction;
    //auto level_set_function_anal = circle_distance_ls<RealType>(radius, x_centre, y_centre ,2*h );
    //typedef  circle_distance_ls<T> Fonction;
     
    


    /**************  VELOCITY FIELD  INITIALISATION  **************/


    size_t  degree_velocity = degree_FEM ; // std::max(degree + 1 , degree_FEM) ;
    auto fe_data_Lagrange = Finite_Element<RealType,Mesh>( msh , degree_velocity , mip ) ;

    std::cout<<"Velocity field: high order Lagrange basis: degree = "<<degree_velocity<<std::endl;
    auto u_projected = velocity_high_order <Mesh,FiniteSpace,T> (fe_data_Lagrange , msh );



    /************** LEVEL SET FUNCTION DISCRETISATION **************/


    if(high_order)
        std::cout<<"--------------------> USING phi^H - HIGH ORDER TRANSPORT PB "<<std::endl;
    else
        std::cout<<"--------------------> USING phi^L - LOW ORDER TRANSPORT PB "<<std::endl;

    std::cout<<"Level set: high order Berstein x interpolated."<<std::endl;
    
//    auto level_set_function = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh , fe_data_gradient , fe_data_div );
//    typedef Level_set_berstein< Mesh , Fonction , FiniteSpace , T > Level_Set;
//     // IF GRADIENT CONTINUOUS
//    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div ) ;
    auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
    level_set_function.gradient_continuous_setting() ;
    typedef Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > Level_Set;
    
    
    std::cout<<"Parametric interface: degree_curve = "<<degree_curve<<std::endl;
    auto curve = Interface_parametrisation_mesh1d(degree_curve);
//    auto curve_old = Interface_parametrisation<  Mesh > (msh , degree_curve); // degree_FEM
    size_t degree_det_jac_curve = curve.degree_det ; // 2*degree_curve INUTILE PER ORA
    // integration CUT CELL degree += degree_curve
    // integration INTERFACE degree += degree_curve
    
    //auto level_set_function = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);
   //auto level_set_function = Level_set_berstein_high_order_interpolation< Mesh , Fonction , FiniteSpace , T > (fe_data , level_set_function_anal , msh);





    /************** LEVEL SET  MAPPING **************/
    // If mapping is false, in HIGH ORDER TRANSPORT CASE the mapping is needed
    bool mapping = false ;
    if(mapping)
        level_set_function.coefficients_mapping_MAX_MAX( );

    //level_set_function.iso_val_interface = 0.5 ;
    //level_set_function.coefficients_mapping_quadratic( );
    //level_set_function.coefficients_mapping_MAX_MAX( );
    //level_set_function.coefficients_sfasamento( );



    /************** MESH INITIALISATION FOR ROUTINE  **************/


    auto crr_mesh =  Current_Mesh<Mesh>(msh);
    crr_mesh.current_mesh = msh;
    Mesh msh_i =  crr_mesh.current_mesh;      // MESH at t=t^n (FOR THE PROCESSING)
    offset_definition(msh_i);


    /************** INITIAL DATA INITIALISATION (t = 0) **************/
    T  dt = 0. ;
    T initial_area = 0. , initial_mass = 0.;
    T d_a = 0. ;
    T perimeter_initial = 0. ;
    T centre_mass_x_inital = 0. , centre_mass_y_inital = 0. ;
    T max_u_n_val_old = 1e+6 , max_u_n_val_new  = 1e+5 ;
    T check = 10.0;
    T tot_time = 0.;

    /************** BOUNDARY CONDITIONS **************/
    bool bdry_bottom = false , bdry_up = false ;
    bool bdry_left = false , bdry_right = false ;
    check_inlet( msh , fe_data , bdry_bottom , bdry_right , bdry_up , bdry_left, 1e-14 );


    //************ DO cutHHO MESH PROCESSING **************
    tc.tic();
    detect_node_position3(msh_i, level_set_function); // In cuthho_geom
    //detect_node_position3_parallel(msh_i, level_set_function); // In cuthho_geom
    detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom
    
    if (agglomeration)
    {
        detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
        //detect_cut_cells3_parallelized(msh_i, level_set_function); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
        set_integration_mesh(msh_i,degree_curve);
        detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
        make_neighbors_info_cartesian(msh_i); // Non serve modificarla
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
       
        make_agglomeration_no_double_points(msh_i, level_set_function,degree_det_jac_curve);
        set_integration_mesh(msh_i,degree_curve) ; // TOLTO PER IL MOMENTO SENNO RADDOPPIO
//        make_agglomeration(msh_i, level_set_function); // Non serve modificarla

    }
    else
    {
        detect_cut_cells3(msh_i, level_set_function);
        //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
        refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
    }

    tc.toc();
    std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" <<'\n' << std::endl;

    if (dump_debug)
    {
        dump_mesh(msh_i);
        output_mesh_info(msh_i, level_set_function);
    }

    
//    Interface_parametrisation_mesh1d_global<Mesh> para_curve_cont(msh_i,degree_curve);
//    para_curve_cont.make_L2_proj_para_derivative(msh_i);
//    check_para_formulation_n_der_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
//    para_curve_cont.make_L2_proj_para_curvature(msh_i);
//    check_para_formulation_n_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
    
    // IN cuthho_export..Points/Nodes don't change-> it's fast
    output_mesh_info2_pre_FEM(msh_i, level_set_function); // IN cuthho_export

    /************** UPDATING  LEVEL SET  AND VELOCITY  **************/
    level_set_function.gradient_continuous_setting() ;
//    // IF GRADIENT CONTINUOUS
//    level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//    // IF DIVERGENCE CONTINUOUS
//    level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

    
    // --------------------- LS_CELL: CHOICE OF DISC/CONT ------------------------------- \\
    
// IF grad cont -> normal cont -> (divergence disc) -> divergence cont
    //auto ls_cell = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad cont -> normal cont -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);

// IF grad disc -> normal disc -> divergence disc
//    auto ls_cell = LS_cell_high_order_grad_disc_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
// IF grad disc -> normal disc -> divergence disc -> normal and grad cont
//    auto ls_cell = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i);
    
    // OLD CASE
    auto ls_cell = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_function,msh_i );

    
    
    ls_cell.radius = radius ;
    u_projected.set_agglo_mesh( msh_i );

    timecounter tc_initial ;
    tc_initial.tic();
    
    
    // ---------------------------------- CHECK bernstein 1d  -----------------------------------
    check_para_formulation(msh_i,curve ,degree_curve,degree_FEM,radius,int_refsteps) ;
            
    
    
    /************** PLOTTINGS + GOAL QUANTITIES  **************/
    std::vector<T> area_time , l1_err_u_n_time , linf_err_u_n_time , time_vec ;
    std::vector<T> max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time ;
    std::vector<T> circularity_time , flux_interface_time , perimeter_time;
    std::vector<std::pair<T,T>> centre_mass_err_time , rise_velocity_time , min_max_vec ;
    T circularity_ref = 0.0 , perim_ref = 0.0, area_ref = 0.0 ;
    T l1_divergence_error = 0. , l2_divergence_error = 0. ;
    T linf_divergence_error = -10. ;
    T L1_divergence_error = 0.;
    
    check_goal_quantities(msh_i, ls_cell, perimeter_initial,d_a, initial_area, centre_mass_x_inital, centre_mass_y_inital,degree_FEM, initial_mass , flower , l1_divergence_error , l2_divergence_error , linf_divergence_error , radius ,L1_divergence_error , ellipse,degree_curve,int_refsteps);
    
    //------------------------ CHECK REFERENCE QUANTITIES ---------------------------//
    {
        // calculus of circle REF in Q^k mesh N x M --> CIRCULARITY REF
        std::cout<<"------ NOTICE: The REF quantities are the numerical calculation of some important quantities for a circle interface. This is useful in the fixed-pont problem to check the convergence of the flower into the equivalent circle."<<std::endl;
        auto level_anal_ref = circle_level_set<T>(radius, x_centre, y_centre );
        std::cout<<"REF radius = " << radius <<std::endl;
        typedef  circle_level_set<T> Fonction_REF;
        auto level_set_ref = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > (fe_data , level_anal_ref , msh);

        Mesh msh_ref =  msh;
        offset_definition(msh_ref);
        detect_node_position3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_faces3(msh_ref, level_set_ref); // In cuthho_geom
        detect_cut_cells3(msh_ref, level_set_ref); // In cuthho_geom
        refine_interface_pro3_curve_para(msh_ref, level_set_ref, int_refsteps,degree_curve);
        set_integration_mesh(msh_ref,degree_curve) ;
        detect_cell_agglo_set(msh_ref, level_set_ref); // Non serve modificarla
        make_neighbors_info_cartesian(msh_ref); // Non serve modificarla
        make_agglomeration_no_double_points(msh_ref, level_set_ref,degree_det_jac_curve);
        set_integration_mesh(msh_ref,degree_curve) ;
        
        typedef Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction_REF , FiniteSpace , T > Level_Set_REF;
        auto ls_cell_ref = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set_REF, Fonction_REF , FiniteSpace >(level_set_ref,msh_ref);


        for(auto& cl : msh_ref.cells)
        {
            ls_cell_ref.cell_assignment(cl);


            if( location(msh_ref, cl) == element_location::IN_NEGATIVE_SIDE || location(msh_ref, cl) == element_location::ON_INTERFACE )
            {
                T partial_area = measure( msh_ref, cl, element_location::IN_NEGATIVE_SIDE);
                area_ref += partial_area;

            }
            if(cl.user_data.location == element_location::ON_INTERFACE)
            {
                perim_ref += measure_interface(msh_i,cl,element_location::ON_INTERFACE);
//                for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() -1 ; interface_point++ )
//                {
//                    perim_ref += ( *(interface_point+1) - *interface_point ).to_vector().norm();
//
//                }
            }
        }

        T d_a_REF = sqrt(4.0*area_ref/M_PI) ;
        std::cout<<"AREA REF = " << area_ref <<std::endl;
        std::cout<<"PERIMETER REF = " << perim_ref <<std::endl;
        std::cout<<"Error( perimetre_ref - perimeter_initial ) = " << perim_ref - perimeter_initial <<std::endl;
        std::cout<<"Error( area_ref - initial_area ) = " << area_ref - initial_area <<std::endl;
        circularity_ref = M_PI*d_a_REF/perim_ref ;
        std::cout<<"CIRCULARITY REF = " << circularity_ref <<std::endl;
        T area_anal = M_PI*radius*radius ;
        std::cout<<"Error( area_ref - area_analytic ) = " << area_ref - area_anal <<std::endl;
        

        T perimeter_anal = 2.0*M_PI*radius ;
        std::cout<<"Error( perimetre_ref - perimeter_anal ) = " << perim_ref - perimeter_anal <<std::endl;

    }
   
    tc_initial.toc();
    std::cout << "Time Machine for checking INITAL GOAL QUANTITIES: " << tc_initial << " seconds" << std::endl;

    circularity_time.push_back(M_PI*d_a/perimeter_initial);
    perimeter_time.push_back(perimeter_initial);
    centre_mass_err_time.push_back(std::make_pair(centre_mass_x_inital/initial_area  , centre_mass_y_inital/initial_area) );
    time_vec.push_back(0) ;
    area_time.push_back(initial_area) ;

    min_max_vec.push_back(std::make_pair(level_set_function.phi_min , level_set_function.phi_max) );

    l1_err_curvature_time.push_back(l1_divergence_error) ;
    linf_err_curvature_time.push_back(linf_divergence_error) ;
    
    T dt_M ;

    

    for (size_t time_step = 0; time_step<=T_N; time_step++)
    {

        std::cout<<'\n'<<bold<<yellow<<"Starting iteration numero  = "<<time_step<<" --> time t = "<<tot_time<<reset <<std::endl;
        
        //PLOTTING THE PROFILE y = 0.5 + min/max of level_set_function
        testing_level_set_time(msh,level_set_function,tot_time,time_step);

        testing_level_set(msh , level_set_function ) ; // PLOTTING THE INTERFACE. It saves  the last
        // -----------------------------------------------------------------------------------------
        // ----------------- RESOLUTION OF THE STOKES PROBLEM (HHO) ------------------
        // -----------------------------------------------------------------------------------------

        bool sym_grad = TRUE;
        auto prm = params<T>();
        prm.kappa_1 = 1.0;
        prm.kappa_2 = 1.0;
        T gamma = 1.0; // 0.05
        
//        check_para_formulation_time(msh_i, curve, degree_curve, degree_FEM , radius, time_step,int_refsteps);
        bool l2proj_para = false ;
        bool l2proj = false ;
        bool avg = true ;
       
           
       
        
        Interface_parametrisation_mesh1d_global<Mesh> para_curve_cont(msh_i,degree_curve);
        
        // *********************** DERIVATIVE / NORMAL PARA *************************//
        //------------- L2 cont curvature from parametric interface  r ---------- //
        para_curve_cont.make_L2_proj_para_derivative(msh_i);
        
        //---------------------------- L2 global Normal from LS  ----------------------- //
        if(l2proj)
            para_curve_cont.make_L2_proj_para_normal(msh_i,ls_cell);
               
        //---------------------------- Avg Normal from LS  ---------------------------- //
        if(avg)
             para_curve_cont.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);

        //        check_para_formulation_n_der_cont_time(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,time_step,int_refsteps) ;
        
        // *********************** CURVATURE PARA *************************//
        
        //------------- L2 cont curvature from parametric interface  r ---------- //
        if(l2proj_para)
            para_curve_cont.make_L2_proj_para_curvature(msh_i);

         
        //---------------------------- L2 global Curvature from LS  ----------------------- //
        if(l2proj)
            para_curve_cont.make_L2_proj_para_curvature(msh_i,ls_cell);
       
        //---------------------------- Avg Curvature from LS  ---------------------------- //
        if(avg){
            para_curve_cont.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
//            auto prova0 = para_curve_cont.curvature_field ;
//            para_curve_cont.make_avg_L2_local_proj_para_curvature_bis(msh_i, ls_cell);
//            auto prova1 = para_curve_cont.curvature_field ;
//            std::cout<<prova1 - prova0<<std::endl;
        }
        check_para_formulation_n_cont_time(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,time_step,int_refsteps) ;
        
// -------> TO CHECK CURVATURE STAZIONARIA
//        T mass_fin = 0. , area_fin = 0. ;
//        T centre_mass_x = 0. , centre_mass_y = 0. ;
//        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
//        T linf_divergence_error_fin = 0. ;
//        T perimeter = 0. ;
//        T L1_divergence_error_fin = 0.;
//
//        T rise_vel0 = 0.0 , rise_vel1 = 0.0 ;
//        T flux_interface = 0.0 ;
//
//        size_t counter_interface_pts_fin = 0.0 ;
//
//        check_goal_quantities_final( msh_i , ls_cell , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface,counter_interface_pts_fin,degree_curve,int_refsteps);
   
        
        
        
        // ------------------ OLD VERSIONS ------------------
        //auto test_case = make_test_case_eshelby(msh_i, ls_cell,  prm , sym_grad);
        // Non serve modificare Gamma = 1/2
        //auto test_case = make_test_case_eshelby_2(msh_i, ls_cell,  prm , sym_grad );
        //auto test_case = make_test_case_eshelby_analytic(msh_i, ls_cell,  prm , sym_grad , radius);
        // ------------- OLD GUILLAUME VERSIONS --------------
        // auto test_case = make_test_case_stokes_1(msh, level_set_function);
        // auto test_case = make_test_case_stokes_2(msh, ls_cell); //level_set_function);

        // ----------------- ESHELBY VERSION - CORRECT BUT PRESSURE ------------------
        //auto test_case_prova = make_test_case_eshelby_2_prova(msh_i, ls_cell,  prm , sym_grad );

        // ---------------------- ESHELBY VERSION LEVEL SET - CORRECT ------------------------
//        auto test_case = make_test_case_eshelby_correct(msh_i, ls_cell,  prm , sym_grad,gamma);
        
         // -------------------- ESHELBY VERSION PARAMETRIC (DISC) - CORRECT -------------------
//        auto test_case = make_test_case_eshelby_correct_parametric(msh_i, ls_cell,  prm , sym_grad,gamma);
        // -------------------- ESHELBY VERSION PARAMETRIC (CONT) - CORRECT -------------------
        auto test_case_prova = make_test_case_eshelby_correct_parametric_cont( msh_i, ls_cell , para_curve_cont, prm , sym_grad , gamma );
        
        
        // ------------------------ HHO METHOD FOR LEVEL SET  ---------------------------
//        auto method = make_sym_gradrec_stokes_interface_method(msh_i, 1.0, 0.0, test_case, sym_grad);
        // -------------------- HHO METHOD FOR DISC PARAMETRIC INTERFACE  -----------------------
//         auto method = make_sym_gradrec_stokes_interface_method_ref_pts(msh_i, 1.0, 0.0, test_case, sym_grad);
    
        // -------------------- HHO METHOD FOR CONT PARAMETRIC INTERFACE  -----------------------
        auto method_prova = make_sym_gradrec_stokes_interface_method_ref_pts_cont(msh_i, 1.0, 0.0, test_case_prova, sym_grad);
        
        
        
        
        //  ******************** - HHO RESOLUTION - ********************
        if(solve_interface){
            // ----------------- HHO RESOLUTION OLD CASE  --------------------------
//            TI = run_cuthho_interface_numerical_ls(msh_i, degree, method, test_case_prova , ls_cell ,  normal_analysis );
//            run_cuthho_interface_velocity_parallel(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad );
            
            // ----------------- HHO RESOLUTION LS / PARAMETRIC DISC  ---------------------
//            run_cuthho_interface_velocity_prova(msh_i, degree, method,test_case, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
            
            // ----------------- HHO RESOLUTION PARAMETRIC CONT  --------------------------
             run_cuthho_interface_velocity_new(msh_i, degree, method_prova,test_case_prova, ls_cell , u_projected ,sym_grad , time_step); // THE ONE CORRECT THAT I'M USING NOW
        }
//        if (solve_fictdom)
//            run_cuthho_fictdom(msh_i, degree, test_case);
        
        
        /************************************ FEM -  PRE-PROCESSING ******************************************/
        // ----------------- PROJECTION OF THE VELOCITY FIELD ------------------
        if(0)
            std::cout<<bold<<green<<"CASE WITH VELOCITY DISCONTINUOUS: ho solo sol_HHO, sol_FEM non salvato, va cambiato il transport pb!!!"<<reset<<std::endl;

        if( 1 ) //1 FIRST RESULT WITH THIS
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.smooth_converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>> NOTICE: NON SMOOTH OPERATOR FROM HHO TO FEM."<<std::endl;
            u_projected.converting_into_FE_formulation( u_projected.sol_HHO );
        }
        if( 0 )
        {
            std::cout<<'\n'<<"------------------>>>>NOTICE: L^2 PROJECTION FROM HHO TO FEM."<<std::endl;
            u_projected.L2_proj_into_FE_formulation(level_set_function , msh , method_transport_pb);
        }
        
        //testing_velocity_field(msh , u_projected) ;
        //auto u_prova = velocity_high_order <Mesh,FiniteSpace,T> (fe_data , msh);
        //u_prova.sol_HHO = u_projected.sol_HHO ;
        //u_prova.L2_proj_into_FE_formulation( level_set_function , msh );
        //testing_velocity_field_L2projected(msh , u_prova) ;

        
        // -----------------------------------------------------------------------------------------
        // ----------------- TIME EVOLUTION (u^n,phi^n) (FEM) ------------------
        // -----------------------------------------------------------------------------------------
//        auto level_set_tmp = Level_set_berstein< Mesh , Fonction , FiniteSpace , T > (level_set_function);
//         auto ls_cell_tmp = LS_cell_high_order_grad_cont_div_disc< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
//         auto ls_cell_tmp = LS_cell_high_order_div_disc_grad_n_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);

        //        auto ls_cell_tmp = LS_cell_high_order_curvature_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
//        auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont_fast< Mesh , Fonction , FiniteSpace , T > (level_set_function);
//        auto ls_cell_tmp = LS_cell_high_order_grad_cont_fast< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        
        
        auto level_set_tmp = Level_set_berstein_high_order_interpolation_grad_cont< Mesh , Fonction , FiniteSpace , T > (level_set_function);
        auto ls_cell_tmp = LS_cell_high_order_grad_cont< T , Mesh , Level_Set, Fonction , FiniteSpace >(level_set_tmp,msh_i);
        
        //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;

        // MACRO TIME STEP dt (before checking if it is too big, I need to find the new interface)
        //if(tot_time < 0.75)
        T eps = 0.48 ; // factor to be inside CFL stability zone
        T dt_one_cell = time_step_CFL_new( u_projected , mip , eps );
        dt_M = dt_one_cell * 0.1 ;
//        dt_M = 8*1e-3; //  4*1e-3;
        
        
        //std::cout<<"dt1 is "<<dt1<<std::endl;
        dt = std::min(dt_one_cell , dt_M);
        dt = std::min(0.1 , dt_M);
        std::cout<<"MACRO TIME STEP dt_MACRO = "<<dt<<", dt_heuristic (AT MAXIMUM ONE CELL DISPLACEMENT) = "<<dt_one_cell<<std::endl;

        // I can create a sub-time. I solve several time the FEM problem, given a Stokes field. The amount of time is s.t. at maximum there is a displacement of a cell of the interface and no more than a maximum T
        T sub_time = 0.;
        T N_sub = 10 ; //10 ;
        T sub_dt = dt / N_sub ; //std::min(4*1e-4 , dt ) ;
        if(sub_dt >1e-3)
        {
            sub_dt = 1e-3 ;
            N_sub = dt/sub_dt ;

        }
       

        std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
        /*
            while(  sub_time < sub_dt*N_sub  )
            {
                if(high_order){
                    run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                    //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_HP( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt , mapping );

                    //run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                    //run_FEM_BERNSTEIN_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);
                }
                else{
                    if(degree_velocity == degree_FEM) // IT IS FASTER
                        run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  );
                    else
                        run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt  , fe_data_Lagrange);

                }
                //run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST( level_set_function.msh , fe_data , level_set_function , u_projected , sub_dt);

                sub_time += sub_dt ;

            }
            */
            //std::cout<<"NOTICE: dt_MACRO = "<<dt<<" , dt_MICRO = "<< sub_dt<<" , ERROR( dt_MICRO*N_sub_loop == dt_MACRO ) = "<< std::abs( dt - N_sub * sub_dt)<<std::endl;

        // ------------- NEW IMPLEMENTATION WITH FAST LEVEL SET ---------------------
        while(  sub_time < sub_dt*N_sub  )
        {
            if(high_order){
                run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt , mapping );

            }
            else{
                //if(degree_velocity == degree_FEM) // IT IS FASTER
                    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  sub_dt  );
                //else
                //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);

                }


                sub_time += sub_dt ;

            }
            tot_time += sub_time ;


    

        /**************************************************   POST-PROCESSING **************************************************/


         // Updating continuous normal function
            level_set_function.gradient_continuous_setting() ;
         // IF GRADIENT CONTINUOUS
//         level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//         // IF DIVERGENCE CONTINUOUS
//         level_set_function.divergence_continuous_setting(method_transport_pb_div) ;

         // Updating mesh data to check out differences in mass and areas
         crr_mesh.current_mesh = msh;
         msh_i =  crr_mesh.current_mesh;
         offset_definition(msh_i);

         tc.tic();
         detect_node_position3(msh_i, level_set_function); // In cuthho_geom
         detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


         if (agglomeration)
         {
             detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
             
             refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
             set_integration_mesh(msh_i,degree_curve) ;
             
             detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
             make_neighbors_info_cartesian(msh_i); // Non serve modificarla
             //refine_interface_angle(msh_i2, level_set_function, int_refsteps); // IN cuthho_geom
             //refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
             make_agglomeration_no_double_points(msh_i, level_set_function,degree_det_jac_curve);
            // make_agglomeration(msh_i, level_set_function); // Non serve modificarla
             set_integration_mesh(msh_i,degree_curve) ;
         }
         else
         {
             move_nodes(msh_i, level_set_function);
             //detect_cut_faces2(msh_i2, level_set_function); //do it again to update intersection     points
             detect_cut_cells3(msh_i, level_set_function);
             //refine_interface2(msh_i2, level_set_function, int_refsteps);
             //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
             refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
             //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
         }

         tc.toc();
         std::cout<<'\n' << "cutHHO-specific mesh preprocessing: " << tc << " seconds"  << std::endl;

         if (dump_debug)
         {
             dump_mesh(msh_i);
             output_mesh_info(msh_i, level_set_function);
         }

         // Updating level set
         ls_cell.level_set = level_set_function;
         ls_cell.agglo_msh = msh_i;
         u_projected.set_agglo_mesh( msh_i );

       
        
//        Interface_parametrisation_mesh1d_global<Mesh> para_curve_tmp(msh_i,degree_curve);
//        para_curve_tmp.make_L2_proj_para_derivative(msh_i);
//       check_para_formulation_n_der_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
//        para_curve_tmp.make_L2_proj_para_curvature(msh_i);
//        check_para_formulation_n_cont(msh_i,para_curve_tmp ,degree_curve,degree_FEM,radius,int_refsteps) ;
        

         T max_u_n_val = 0.0 ;
         T max_u_n_val_abs = 0.0 ;
         T l1_normal_interface_status = 0. , l2_normal_interface_status = 0. ;

        T L1_normal_interface_status = 0. ;

         size_t counter_interface_pts = 0;
         for(auto& cl : msh_i.cells)
         {
             if(cl.user_data.location == element_location::ON_INTERFACE)
             {
                 ls_cell.cell_assignment(cl);
                 u_projected.cell_assignment(cl);
                 
                 auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
                 for(auto& qp:qps){
                     T u_n_val = u_projected(qp.first).first * ls_cell.normal(qp.first)(0) + u_projected(qp.first).second * ls_cell.normal(qp.first)(1) ;
                     L1_normal_interface_status += qp.second * std::abs(u_n_val) ;
                     max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                     if( std::abs(u_n_val) == max_u_n_val_abs )
                         max_u_n_val = u_n_val ;
                     
                     l1_normal_interface_status += std::abs(u_n_val) ;
                     counter_interface_pts ++ ;
                     
                 }
                 
//                 for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                 {
//                     T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
//                     max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
//                     if( std::abs(u_n_val) == max_u_n_val_abs )
//                         max_u_n_val = u_n_val ;
//
//                     l1_normal_interface_status += std::abs(u_n_val) ;
//                     l2_normal_interface_status += pow(u_n_val,2.0);
//                     counter_interface_pts ++ ;
//
//                 }
             }
         }

         if( time_step == 0 )
             max_u_n_val_new = max_u_n_val ;

         if(time_step > 0 )
         {
             max_u_n_val_old = max_u_n_val_new ;
             max_u_n_val_new = max_u_n_val ;
             std::cout<<bold<<yellow<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<reset <<std::endl;
         }

         std::cout<<"number of interface points is " << counter_interface_pts << std::endl;

         l1_normal_interface_status /= counter_interface_pts;
//         l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);
         std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
//         std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
         std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;
        
        std::cout<<bold<<yellow<<"-----------------------------------> The L1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << L1_normal_interface_status <<reset << std::endl;




         if( ( std::signbit(max_u_n_val_new) ==  std::signbit(max_u_n_val_old) ) && std::abs( max_u_n_val_new )> std::abs( max_u_n_val_old ) )
         {
             std::cout<< "I do not know what to do precisely.. FOR THE MOMENT IT CONTINUES NORMALLY."<<std::endl;
             //exit(9) ;
         }

         //if( ( std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old) ) && std::abs(max_u_n_val_new) > std::abs(max_u_n_val_old) )

         //else // IF I DO else I consider also  case in which  + + e diminuisce e - - e aumenta
         if( (tot_time > 1.8) && (std::signbit(max_u_n_val_new) !=  std::signbit(max_u_n_val_old)) )
         {




             // -------- IN THIS CASE, IT MEANS THE dt_MACRO WAS TOO BIG. I CALCULATE A NEW dt_MACRO.
             // DEVO SALVARE ULTIMA level_set (prima dello spostamento) e togliere da tot_time il sub_time!
             T dt_M_new = dt_M + (max_u_n_val_new * dt_M )/(max_u_n_val_old - max_u_n_val_new) ;
             T dt_new = std::min(dt_one_cell , dt_M_new);

             bool forward = TRUE ;
             if( forward ) // GO FORWARD FROM THE TIME t^n
             {
                 dt = dt_new ;

                 std::cout<<bold<<yellow<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<reset<<std::endl;
                 std::cout<<"I go back in time of sub_time = "<<sub_time<<". NEW STARTING TIME = "<<tot_time - sub_time<<std::endl;
                 tot_time -= sub_time ; // I erase the time previously calculated
                 sub_time = 0.;
                 sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                 //T sub_dt;
                 //if(tot_time <0.132)
                 //    sub_dt = std::min(4*1e-4 , dt ) ;
                 //else
                 //    sub_dt = std::min(5*1e-5 , dt ) ;

                 std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                 while(  sub_time < sub_dt*N_sub  )
                 {

                     if(high_order){
                         run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt , mapping );

                     }
                     else{
                         //if(degree_velocity == degree_FEM) // IT IS FASTER
                             run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb ,  sub_dt  );
                         //else
                         //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_tmp.msh , fe_data , level_set_tmp , u_projected , method_transport_pb , sub_dt  , fe_data_Lagrange);


                     }


                     sub_time += sub_dt ;

                 }

                 tot_time += sub_time ; // the new time is substracted
                 level_set_function = level_set_tmp ;
                 std::cout<<'\n'<<std::endl;
                 //testing_level_set_disc(msh, level_set_function, level_set_tmp) ;
             }
             else // GO BACKWARD FROM THE TIME t^n + dt_M
             {

                 dt = dt_M - dt_new ;
                 std::cout<<"NEW MACRO TIME STEP dt_MACRO = "<<dt_new<<std::endl;
                 std::cout<<"I go back in time of dt = "<<dt<<std::endl;
                 sub_time = 0.;
                 sub_dt =  dt / N_sub ; //std::min(4*1e-4 , dt ) ;

                 //T sub_dt;
                 //if(tot_time <0.132)
                 //    sub_dt = std::min(4*1e-4 , dt ) ;
                 //else
                 //    sub_dt = std::min(5*1e-5 , dt ) ;

                 std::cout<<"-----> Implemented sub time dt_MICRO = "<<sub_dt<<std::endl;
                 while(  sub_time < sub_dt*N_sub  )
                 {
                     T neg_time = -sub_dt ;
                     if(high_order){
                         run_FEM_BERNSTEIN_CORRECT_FAST_NEW_D_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time , mapping );

                     }
                     else{
                         //if(degree_velocity == degree_FEM) // IT IS FASTER
                             run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb ,  neg_time  );
                         //else
                         //    run_FEM_BERNSTEIN_LOW_ORDER_CORRECT_FAST_NEW_DIRICHLET_COND_NEW_LS( level_set_function.msh , fe_data , level_set_function , u_projected , method_transport_pb , neg_time  , fe_data_Lagrange);


                     }



                     sub_time += sub_dt ;

                 }
                 std::cout<<'\n'<<std::endl;
                 tot_time -= sub_time ; // the new time is substracted

             }


             //-------------------------- NEW CALCULATION OF U*N --------------------------

             // Updating continuous normal function
             level_set_function.gradient_continuous_setting() ;
             // IF GRADIENT CONTINUOUS
//             level_set_function.gradient_continuous_setting(method_transport_pb_grad) ;
//             // IF DIVERGENCE CONTINUOUS
//             level_set_function.divergence_continuous_setting(method_transport_pb_div) ;
             // Updating mesh data to check out differences in mass and areas
             crr_mesh.current_mesh = msh;
             msh_i =  crr_mesh.current_mesh;
             offset_definition(msh_i);

             tc.tic();
             detect_node_position3(msh_i, level_set_function); // In cuthho_geom
             detect_cut_faces3(msh_i, level_set_function); // In cuthho_geom


             if (agglomeration)
             {
                 detect_cut_cells3(msh_i, level_set_function); // In cuthho_geom
                 
                 refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
                 set_integration_mesh(msh_i,degree_curve) ;
                 
                 detect_cell_agglo_set(msh_i, level_set_function); // Non serve modificarla
                 make_neighbors_info_cartesian(msh_i); // Non serve modificarla
                 
                 //refine_interface_pro3(msh_i, level_set_function, int_refsteps); // IN cuthho_geom
                 make_agglomeration_no_double_points(msh_i, level_set_function,degree_det_jac_curve);
                 //make_agglomeration(msh_i, level_set_function); // Non serve modificarla
                 set_integration_mesh(msh_i,degree_curve) ;
             }
             else
             {
                 
                 detect_cut_cells3(msh_i, level_set_function);
                 //refine_interface2(msh_i2, level_set_function, int_refsteps);
                 //refine_interface_angle(msh_i2, level_set_function, int_refsteps);
                 //refine_interface_pro3(msh_i, level_set_function, int_refsteps);
                 refine_interface_pro3_curve_para(msh_i, level_set_function, int_refsteps,degree_curve);
             }

             tc.toc();
             std::cout << "cutHHO-specific mesh preprocessing: " << tc << " seconds" << std::endl;

             if (dump_debug)
             {
                 dump_mesh(msh_i);
                 output_mesh_info(msh_i, level_set_function);
             }

             // Updating level set
             ls_cell.level_set = level_set_function;
             ls_cell.agglo_msh = msh_i;
             u_projected.set_agglo_mesh( msh_i );

             // Updating Parametric interface
//            Interface_parametrisation_mesh1d_global<Mesh> para_curve_tmp(msh_i,degree_curve);
//            para_curve_tmp.make_L2_proj_para_derivative(msh_i);
//            //        check_para_formulation_n_der_cont(msh_i,para_curve_cont ,degree_curve,degree_FEM,radius,int_refsteps) ;
//            para_curve_tmp.make_L2_proj_para_curvature(msh_i);
//            check_para_formulation_n_cont(msh_i,para_curve_tmp ,degree_curve,degree_FEM,radius,int_refsteps) ;
                     

             max_u_n_val = 0.0 ;
             max_u_n_val_abs = 0.0 ;
             l1_normal_interface_status = 0. ;
             l2_normal_interface_status = 0. ;
             L1_normal_interface_status = 0. ;
             
             counter_interface_pts = 0;
             for(auto& cl : msh_i.cells)
             {
                 if(cl.user_data.location == element_location::ON_INTERFACE)
                 {
                     ls_cell.cell_assignment(cl);
                     u_projected.cell_assignment(cl);
                     
                     auto qps = integrate_interface(msh_i, cl, degree_FEM + degree_velocity, element_location::ON_INTERFACE);
                     for(auto& qp:qps){
                         T u_n_val = u_projected(qp.first).first * ls_cell.normal(qp.first)(0) + u_projected(qp.first).second * ls_cell.normal(qp.first)(1) ;
                         L1_normal_interface_status += qp.second * std::abs(u_n_val) ;
                         max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
                         if( std::abs(u_n_val) == max_u_n_val_abs )
                             max_u_n_val = u_n_val ;

                         l1_normal_interface_status += std::abs(u_n_val) ;
                          counter_interface_pts ++ ;
                     }
                     
//                     for(auto interface_point = cl.user_data.interface.begin() ; interface_point < cl.user_data.interface.end() ; interface_point++ )
//                     {
//                         T u_n_val = u_projected(*(interface_point)).first * ls_cell.normal(*(interface_point))(0) + u_projected(*(interface_point)).second * ls_cell.normal(*(interface_point))(1) ;
//                         max_u_n_val_abs = std::max( max_u_n_val_abs , std::abs(u_n_val) ) ;
//                         if( std::abs(u_n_val) == max_u_n_val_abs )
//                             max_u_n_val = u_n_val ;
//
//                         l1_normal_interface_status += std::abs(u_n_val) ;
//                         l2_normal_interface_status += pow(u_n_val,2.0);
//                         counter_interface_pts ++ ;
//
//                     }
                 }
             }


             max_u_n_val_new = max_u_n_val ;


             std::cout<<"l^{inf} u*n(t^n) = "<<max_u_n_val_old<<" , l^{inf} u*n(t^{n+1}) = "<<max_u_n_val_new<<std::endl;


             std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
             l1_normal_interface_status /= counter_interface_pts;
//             l2_normal_interface_status = sqrt(l2_normal_interface_status/counter_interface_pts);

             std::cout<<bold<<yellow<<"-----------------------------------> The l1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l1_normal_interface_status <<reset << std::endl;
//             std::cout<<"-----------------------------------> The l2 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << l2_normal_interface_status << std::endl;
             std::cout<<bold<<yellow<<"-----------------------------------> The linf error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val_abs <<reset << std::endl;

             std::cout<<"-----------------------------------> The max error (with sign) of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << max_u_n_val  << std::endl;
             
             std::cout<<bold<<yellow<<"-----------------------------------> The L1 error of u*n over the INTERFACE, at time t = "<< tot_time <<" is " << L1_normal_interface_status <<reset << std::endl;


         }

        
        
        // ----------------- CHECKING GOAL QUANTITIES FOR t = t^{n+1} ------------------



        check = l1_normal_interface_status ;
        /// DA AGGIUNGERE UNA VOLTA SISTEMATO IL CODICE

        //if(check < 1e-8 )
        //{
        //    std::cout<<" check = "<<check<<" , STOP!"<<std::endl;
        //    return 0;
        //}



        output_mesh_info2_time(msh_i, level_set_function,tot_time,time_step);

        T mass_fin = 0. , area_fin = 0. ;
        T centre_mass_x = 0. , centre_mass_y = 0. ;
        T l1_divergence_error_fin = 0. , l2_divergence_error_fin = 0. ;
        T linf_divergence_error_fin = 0. ;
        T perimeter = 0. ;
        T L1_divergence_error_fin = 0.;

        T rise_vel0 = 0.0 , rise_vel1 = 0.0 ;
        T flux_interface = 0.0 ;

        size_t counter_interface_pts_fin = 0.0 ;
        
        // Updating Parametric interface
        Interface_parametrisation_mesh1d_global<Mesh> para_curve_tmp(msh_i,degree_curve);
        para_curve_tmp.make_L2_proj_para_derivative(msh_i);
        //---------------------------- L2 global Normal from LS  ----------------------- //
        if(l2proj)
            para_curve_tmp.make_L2_proj_para_normal(msh_i,ls_cell);
                              
        //---------------------------- Avg Normal from LS  ---------------------------- //
        if(avg)
            para_curve_tmp.make_avg_L2_local_proj_para_normal(msh_i, ls_cell);
              
                       
        // *********************** CURVATURE PARA *************************//
                       
        //------------- L2 cont curvature from parametric interface  r ---------- //
        if(l2proj_para)
            para_curve_tmp.make_L2_proj_para_curvature(msh_i);

                        
        //---------------------------- L2 global Curvature from LS  ----------------------- //
        if(l2proj)
            para_curve_tmp.make_L2_proj_para_curvature(msh_i,ls_cell);
                      
        //---------------------------- Avg Curvature from LS  ---------------------------- //
        if(avg)
            para_curve_tmp.make_avg_L2_local_proj_para_curvature(msh_i, ls_cell);
        
        check_goal_quantities_final_para( msh_i ,ls_cell, para_curve_tmp , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface,counter_interface_pts_fin,degree_curve,int_refsteps);

         std::cout<<"FLUX at the INTERFACE, at time "<< tot_time <<" is " << flux_interface <<std::endl;
        
        
//        check_goal_quantities_final( msh_i , ls_cell , u_projected, perimeter, d_a,  area_fin, centre_mass_x ,   centre_mass_y , degree_FEM , mass_fin , degree_velocity , l1_divergence_error_fin , l2_divergence_error_fin , linf_divergence_error_fin , radius , L1_divergence_error_fin ,  time_step ,rise_vel0 , rise_vel1 ,flux_interface,counter_interface_pts_fin,degree_curve,int_refsteps);
//
        
        testing_level_set_max_min(msh,level_set_function , time_step , min_max_vec );

        //std::cout<<"number of interface points is " << counter_interface_pts << std::endl;
        l1_divergence_error_fin /= counter_interface_pts_fin;
//        l2_divergence_error_fin = sqrt(l2_divergence_error_fin/counter_interface_pts);



        std::cout<<"The l1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l1_divergence_error_fin <<std::endl;
//        std::cout<<"The l2 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << l2_divergence_error_fin <<std::endl;
        std::cout<<"The linf error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << linf_divergence_error_fin <<std::endl;
        
        std::cout<<"The L1 error of the CURVATURE at the INTERFACE, at time "<< tot_time <<" is " << L1_divergence_error_fin <<std::endl;
        
        
       





        std::cout<<"The PERIMETER, at time "<< tot_time <<" is " << perimeter << ", Initial PERIMETER =  "<<perimeter_initial<<std::endl;

        std::cout<<"NORMALISED DIFFERENCE PERIMETER, at time "<< tot_time <<" is " << (perimeter - perimeter_initial)/perimeter_initial <<std::endl;

        d_a = sqrt(4.0*area_fin/M_PI) ;

        std::cout<<"The CIRCULARITY, at time "<< tot_time <<" is " << M_PI*d_a/perimeter <<std::endl;

        std::cout  << "Area at time step: " <<tot_time<<" is "<< area_fin << std::endl;
        std::cout << "Internal mass at time step: "<<tot_time<<" is "<< mass_fin << std::endl;

        std::cout  << "NORMALISED Difference in AREA AT TIME "<<tot_time<<" IS "<< (area_fin - initial_area)/initial_area << std::endl;
        std::cout << "NORMALISED Difference in INTERNAL MASS AT TIME "<<tot_time<<" IS "<< (std::abs(mass_fin - initial_mass))/(std::abs( initial_mass )) << std::endl;
        std::cout << "CENTRE OF MASS at time step: "<<tot_time<<" is "<<" ( " << centre_mass_x/area_fin <<" , " << centre_mass_y/area_fin<<" ). " << std::endl;
        std::cout << "TRANSLATION OF THE CENTRE OF MASS at time step: "  <<tot_time<<" is "<<" ( " << centre_mass_x/area_fin - centre_mass_x_inital/initial_area <<" , " << centre_mass_y/area_fin - centre_mass_y_inital/initial_area<<" ). " << std::endl;
        std::cout  << "Abs error over expected radius = "<< std::abs( sqrt(area_fin/M_PI) - radius ) <<'\n' << std::endl;

        time_vec.push_back(tot_time);
        area_time.push_back(area_fin) ;
        l1_err_u_n_time.push_back(l1_normal_interface_status) ;
        linf_err_u_n_time.push_back(max_u_n_val_abs) ;

        max_val_u_n_time.push_back(max_u_n_val) ;
        l1_err_curvature_time.push_back(l1_divergence_error_fin) ;
        linf_err_curvature_time.push_back(linf_divergence_error_fin) ;

        //DA ADD BENE!!!! da qui

        circularity_time.push_back(M_PI*d_a/perimeter);
        perimeter_time.push_back(perimeter);
        centre_mass_err_time.push_back(std::make_pair(centre_mass_x/area_fin  , centre_mass_y/area_fin) );

        flux_interface_time.push_back(flux_interface);
        rise_velocity_time.push_back( std::make_pair(rise_vel0/area_fin  , rise_vel1/area_fin) ) ;


    
        
    } // End of the temporal loop

   
    
    
    plotting_in_time_complete( time_vec , area_time , l1_err_u_n_time , linf_err_u_n_time , max_val_u_n_time , l1_err_curvature_time , linf_err_curvature_time , dt_M ,min_max_vec ,  flux_interface_time , rise_velocity_time , centre_mass_err_time , perimeter_time , circularity_time , circularity_ref , perim_ref , area_ref , radius );



    std::cout<<"FINAL TIME IS t = "<<tot_time<<std::endl;

    tc_tot.toc();
    std::cout<<"Simulation time 0 t = "<<tc_tot <<std::endl;

    return 0;
}
#endif

